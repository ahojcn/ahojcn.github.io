<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/12/04/hello-world/"/>
      <url>/2022/12/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>字节混动工程分享笔记</title>
      <link href="/2022/01/22/%E5%AD%97%E8%8A%82%E6%B7%B7%E5%8A%A8%E5%B7%A5%E7%A8%8B%E5%88%86%E4%BA%AB%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/01/22/%E5%AD%97%E8%8A%82%E6%B7%B7%E5%8A%A8%E5%B7%A5%E7%A8%8B%E5%88%86%E4%BA%AB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>建立稳定状态的假设</p><p>多样化现实世界事件</p><p>在生产环境运行实验</p><p>持续自动化运行实验</p><p>最小化“爆炸半径”</p><p><strong>为什么在生产环境进行？</strong></p><blockquote><p>没办法百分百的模拟出生产环境的分布式系统的情况。在测试环境中做的实验是没有意义的。</p></blockquote><p><strong>如何做到故障的精准控制？</strong></p><blockquote><p>1）要做到指哪打哪<br>可以打到集群/实例/特定请求（结合 RPC 框架、service mesh、流量染色技术）。</p><p>2）防止故障扩散<br>例如：优惠系统、支付系统都依赖于公共服务用户中心，那要做支付系统对用户中心的故障注入就不应该影响到优惠系统<br>在支付系统对用户中心发起请求的那一刻进行干扰，在支付系统的机器/节点/Client里面进行出流量干扰</p><p>3）自动化指标观察，自动巡检相关指标</p></blockquote><p>降低风险成本：设计可扩展的故障中心，实现精准可控的爆炸半径控制</p><p>降低时间成本：屏蔽业务细节，抽象故障模型</p><p><img src="https://raw.githubusercontent.com/ahojcn/picgo-upload/main/202201222359795.png" alt="故障中心"></p><p>业务链路为视角的混沌工程？</p><p>面向人的混沌工程？</p><ul><li>红蓝对抗</li><li>故障期间无通知的随机的故障注入</li></ul><p><img src="https://raw.githubusercontent.com/ahojcn/picgo-upload/main/202201230015686.png"></p><p><img src="https://raw.githubusercontent.com/ahojcn/picgo-upload/main/202201230018862.png"></p><hr><p>EOF</p>]]></content>
      
      
      <categories>
          
          <category> 混沌工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> chaos </tag>
            
            <tag> 混沌工程 </tag>
            
            <tag> 大厂案例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>容器高手实战课-容器和内存</title>
      <link href="/2022/01/18/%E5%AE%B9%E5%99%A8%E9%AB%98%E6%89%8B%E5%AE%9E%E6%88%98%E8%AF%BE-%E5%AE%B9%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98/"/>
      <url>/2022/01/18/%E5%AE%B9%E5%99%A8%E9%AB%98%E6%89%8B%E5%AE%9E%E6%88%98%E8%AF%BE-%E5%AE%B9%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<ul><li>OOM Killer</li><li>Memory Cgroup</li></ul><h1 id="容器被-oom-killer-干掉了"><a href="#容器被-oom-killer-干掉了" class="headerlink" title="容器被 oom killer 干掉了"></a>容器被 oom killer 干掉了</h1><h2 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h2><p><a href="https://github.com/chengyli/training/tree/main/memory/oom">https://github.com/chengyli/training/tree/main/memory/oom</a></p><p>1）编译 <code>make mem_alloc</code><br>2）构建容器镜像 <code>make image</code><br>3）运行测试容器 <code>sh start_container.sh</code></p><p>在 <code>start_container.sh</code> 中将容器的 Cgroup 内存上限设置为 512MB。</p><p>现象：<br>容器启动 30s 后会不断申请内存，当申请的内存超过 512MB 时，容器 <code>exited</code>。<br>使用 <code>docker inspect [容器ID] | grep -i Status -A 10</code> 可以看到 <code>&quot;OOMKilled: true&quot;</code>。</p><h2 id="OOM-Killer"><a href="#OOM-Killer" class="headerlink" title="OOM Killer"></a>OOM Killer</h2><p>out of memory killer，在 Linux 系统里如果内存不足时，就需要杀死一个正在运行的进程来释放一些内存。</p><blockquote><p><strong>申请内存调用 <code>malloc()</code> 为什么内存不够不返回错误/失败？而要去杀死正在运行的进程？</strong></p><p>Linux 进程的内存申请策略相关。<br>Linux 允许进程在申请内存的时候是 overcommit 的，允许申请超过实际物理内存上限的内存。<br>每次 malloc 申请的是虚拟地址，系统只给了一个地址范围，没有写入数据，所以并不会真正使用。<br>overcommit 的内存申请模式可以有效提高系统的内存利用率。</p></blockquote><h3 id="选择被杀进程的标准"><a href="#选择被杀进程的标准" class="headerlink" title="选择被杀进程的标准"></a>选择被杀进程的标准</h3><p>Linux 内核里 <code>oom_badness()</code> 定义了选择进程的标准。</p><p>1）进程已使用的物理内存页面数<br>2）每个进程的 OOM 校准值 oom_score_adj，每个进程都有一个接口文件 <code>/proc/&lt;pid&gt;/oom_score_adj</code>，取值范围 [-1000, 1000]</p><p>具体计算方法：值越大被 OOM kill 的几率也越大！</p><p>$$<br>系统总可用页面数 * OOM校准值 + 已使用的物理页面数<br>$$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">adj = (<span class="type">long</span>)p-&gt;signal-&gt;oom_score_adj;</span><br><span class="line"></span><br><span class="line">points = get_mm_rss(p-&gt;mm) + get_mm_counter(p-&gt;mm, MM_SWAPENTS) +mm_pgtables_bytes(p-&gt;mm) / PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">adj *= totalpages / <span class="number">1000</span>;</span><br><span class="line">points += adj;</span><br></pre></td></tr></table></figure><h2 id="Memory-Cgroup"><a href="#Memory-Cgroup" class="headerlink" title="Memory Cgroup"></a>Memory Cgroup</h2><p>挂载点一般在 <code>/sys/fs/cgroup/memory</code>。</p><p>Memory Cgroup 各配置说明：<a href="https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v1/memory.html">https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v1/memory.html</a></p><p>跟 OOM 最相关的 3 个参数：</p><ul><li><p><strong>memory.limit_in_bytes</strong>，控制组最大内存使用量</p></li><li><p><strong>memory.oom_control</strong>，当控制组中的进程内存使用达到上限时，是否触发 OOM Killer</p><p>  缺省值为会触发控制组内的 OOM Killer，和系统的 OOM Killer 功能差不多，差别是杀死进程的选择范围</p><p>  You can disable the OOM-killer by writing “1” to memory.oom_control file, as:</p><p>  #echo 1 &gt; memory.oom_control</p><p>  这会导致正在申请物理内存页面的进程 hang/wait！！！</p></li><li><p><strong>memory.usage_in_bytes</strong>，只读，当前控制组里所有进程实际使用的内存总和</p></li></ul><p><img src="https://raw.githubusercontent.com/ahojcn/picgo-upload/main/202201182203004.png"></p><h2 id="如何快速定位容器-OOM？"><a href="#如何快速定位容器-OOM？" class="headerlink" title="如何快速定位容器 OOM？"></a>如何快速定位容器 OOM？</h2><p>查看内核日志 <code>journalctl -k</code> 或者直接查看日志文件 <code>/var/log/message</code>。</p><p>当容器发生 OOM Kill 时候会输出以下相关信息：</p><p><img src="https://raw.githubusercontent.com/ahojcn/picgo-upload/main/202201182222513.png"></p><h1 id="Linux-用户态内存类型"><a href="#Linux-用户态内存类型" class="headerlink" title="Linux 用户态内存类型"></a>Linux 用户态内存类型</h1><p>内核需要分配内存给页表、内核栈、slab，也就是内核各种数据结构的 Cache Pool；<br>用户态进程里的堆、栈、共享库的内存、文件读写的 Page Cache。</p><h2 id="RSS"><a href="#RSS" class="headerlink" title="RSS"></a>RSS</h2><p>Resident Set Size，就是进程真正申请到物理页面的内存大小。</p><p>RSS 包含了进程的代码段、栈、堆、共享库内存。</p><p>在 <code>top</code> 命令中显示的是 RES(Resident 缩写)。</p><p>具体每一部分的 RSS 内存大小可以查看 <code>/proc/[pid]/smaps</code> 文件。</p><p>先 <code>malloc</code> 了 100MB 内存(堆上)，然后使用 <code>top</code> 查看此进程内存使用情况：<br>虚拟地址空间 VIRT 使用了约 106728KB ≈ 100MB，但实际物理内存 RSS 只有 688KB。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="built_in">malloc</span>(<span class="number">100</span> * MB);</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ahojcn/picgo-upload/main/202201191953681.png"></p><p>在向申请的空间里写入 20MB 数据，再次查看：<br>VIRT 没变，RSS 变成了 21432KB ≈ 20MB。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sleep(<span class="number">30</span>);</span><br><span class="line"><span class="built_in">memset</span>(p, <span class="number">0x00</span>, <span class="number">20</span> * MB)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ahojcn/picgo-upload/main/202201191956843.png"></p><h2 id="Page-Cache"><a href="#Page-Cache" class="headerlink" title="Page Cache"></a>Page Cache</h2><p>每个进程除了各自独立分配到的 RSS 内存外，如果进程对磁盘上的文件做了读写操作，Linux 还会分配内存，把磁盘上读写到的页面存放在内存中，这部分的内存就是 Page Cache。</p><p>Page Cache 的主要作用是提高磁盘文件的读写性能，因为系统调用 read() 和 write() 的缺省行为都会把读过或者写过的页面存放在 Page Cache 里。</p><p>Linux 的内存管理有一种内存页面回收机制（page frame reclaim），会根据系统里空闲物理内存是否低于某个阈值（wartermark），来决定是否启动内存的回收。</p><h1 id="Memcgroup-和-RSS、Page-Cache"><a href="#Memcgroup-和-RSS、Page-Cache" class="headerlink" title="Memcgroup 和 RSS、Page Cache"></a>Memcgroup 和 RSS、Page Cache</h1><p>Linux 内核代码：<code>mem_cgroup_charge_statistics()</code>，可以看到 Memory Cgroup 也的确只是统计了 RSS 和 Page Cache 这两部分的内存。Cgroup 中的 <code>memory.stat</code> 可以看到当前控制组里各种内存类型的实际的开销。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memory.usage_in_bytes = RSS + Page Cache</span><br></pre></td></tr></table></figure><p>当控制组里的进程需要申请新的物理内存，而且 memory.usage_in_bytes 里的值超过控制组里的内存上限值 memory.limit_in_bytes，这时 Linux 的内存回收（page frame reclaim）就会被调用起来。</p><p>free里的cache/buffer就是page cache, 早期Linux文件相关的cache内存分buffer cache和page cache, 现在统一成page cache了。 shared内存一般是tmpfs 内存文件系统的用到的内存。</p>]]></content>
      
      
      <categories>
          
          <category> 容器高手实战课笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 容器 </tag>
            
            <tag> Cgroups </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开源分享-proxy pool</title>
      <link href="/2022/01/14/%E5%BC%80%E6%BA%90%E5%88%86%E4%BA%AB-proxy-pool/"/>
      <url>/2022/01/14/%E5%BC%80%E6%BA%90%E5%88%86%E4%BA%AB-proxy-pool/</url>
      
        <content type="html"><![CDATA[<p>最近在爬一些需要的数据，常遇到 IP 被封的情况，在网上找了一些代理网站发现白嫖的代理很难保持可用。</p><p>项目地址：<a href="https://github.com/Python3WebSpider/ProxyPool">https://github.com/Python3WebSpider/ProxyPool</a></p><p>代理池实现：<a href="https://cuiqingcai.com/7048.html">https://cuiqingcai.com/7048.html</a></p><p>按照 readme 尝试了一下发现很 nice，在此推荐给大家。</p><p><img src="https://raw.githubusercontent.com/ahojcn/picgo-upload/main/202201142350956.png" alt="random"></p><p><img src="https://raw.githubusercontent.com/ahojcn/picgo-upload/main/202201142351436.png" alt="count"></p><hr><p>EOF</p>]]></content>
      
      
      <categories>
          
          <category> 开源分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开源分享 </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> 代理池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>容器高手实战课-容器和CPU</title>
      <link href="/2022/01/04/%E5%AE%B9%E5%99%A8%E9%AB%98%E6%89%8B%E5%AE%9E%E6%88%98%E8%AF%BE-%E5%AE%B9%E5%99%A8%E5%92%8CCPU/"/>
      <url>/2022/01/04/%E5%AE%B9%E5%99%A8%E9%AB%98%E6%89%8B%E5%AE%9E%E6%88%98%E8%AF%BE-%E5%AE%B9%E5%99%A8%E5%92%8CCPU/</url>
      
        <content type="html"><![CDATA[<p>问题引入：在容器中执行 top 查看 CPU 使用情况，top user space 却显示 58.5%（12core * 58.5% ≈ 7core），但容器中实际两个进程 200% %CPU 只占用了 2core。</p><p><img src="https://raw.githubusercontent.com/ahojcn/picgo-upload/main/202201042112195.png"></p><h1 id="如何正确得到容器的-CPU-开销？"><a href="#如何正确得到容器的-CPU-开销？" class="headerlink" title="如何正确得到容器的 CPU 开销？"></a>如何正确得到容器的 CPU 开销？</h1><h2 id="top-命令输出结果"><a href="#top-命令输出结果" class="headerlink" title="top 命令输出结果"></a>top 命令输出结果</h2><p><code>0.0 us, 0.0 sy, 0.0 ni, 99.9 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st</code></p><p><img src="https://raw.githubusercontent.com/ahojcn/picgo-upload/main/202201042110807.png"></p><ul><li>us（user）用户态 CPU 使用，普通用户程序代码只要不调用系统调用（system call），这些代码的消耗就属于 us</li><li>sy（system）内核态 CPU 使用，当用户代码中使用 <code>read()</code> 读取文件时这个用户进程就会从用户态切换到内核态，内核态 <code>read()</code> 在读到真正的文件前还会进行一些文件系统层的操作，这些消耗就属于 sy</li><li>wa（iowait）进程在进行读文件的时候会被设置成 <code>TASK_UNINTERRUPTIBLE</code> 状态，这段等待 I/O 的时间标记为 wa，磁盘返回数据时进程在内核态拿到数据处于 sy</li><li>id（idle）空闲状态</li><li>hi（hardware irq）机器在收到一个网络数据包，网卡会发送一个中断（interrupt），CPU 响应中断后进入中断处理程序，中断处理程序需要关闭中断，所以这个硬中断时间不能太长</li><li>si（soft irq）软中断来完成一些耗时比较长的工作，从网卡收数据包的大部分工作都是由软终端来处理</li></ul><p>无论是 hi 还是 si 他们在处理的时候不属于任何一个进程。</p><ul><li>ni（nice）优先级，正值 1-19</li><li>st（steal）是在虚拟机里用的一个 CPU 使用类型，表示有多少时间是被同一个宿主机上的其他虚拟机抢走的</li></ul><h2 id="CPU-CGroup-是如何工作的"><a href="#CPU-CGroup-是如何工作的" class="headerlink" title="CPU CGroup 是如何工作的"></a>CPU CGroup 是如何工作的</h2><p>每个 Cgroup 子系统都是通过一个虚拟文件系统挂载点的方式，一般在 /sys/fs/cgroup/cpu 目录下</p><p><img src="https://raw.githubusercontent.com/ahojcn/picgo-upload/main/202201042110423.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-2-centos cpu]<span class="comment"># pwd</span></span><br><span class="line">/sys/fs/cgroup/cpu</span><br><span class="line">[root@VM-0-2-centos cpu]<span class="comment"># mkdir test-cgroup1 test-cgroup2</span></span><br><span class="line">[root@VM-0-2-centos cpu]<span class="comment"># ls test-cgroup2/</span></span><br><span class="line">cgroup.clone_children  cgroup.procs  cpuacct.usage         cpu.cfs_period_us  cpu.rt_period_us   cpu.shares  notify_on_release</span><br><span class="line">cgroup.event_control   cpuacct.stat  cpuacct.usage_percpu  cpu.cfs_quota_us   cpu.rt_runtime_us  cpu.stat    tasks</span><br><span class="line">[root@VM-0-2-centos cpu]<span class="comment"># cd test-cgroup2/ &amp;&amp; mkdir test-cgroup3 test-cgroup4</span></span><br><span class="line">[root@VM-0-2-centos test-cgroup2]<span class="comment"># cd test-cgroup3/ &amp;&amp; ls cpu.*</span></span><br><span class="line">cpu.cfs_period_us  cpu.cfs_quota_us  cpu.rt_period_us  cpu.rt_runtime_us  cpu.shares  cpu.stat</span><br><span class="line">[root@VM-0-2-centos test-cgroup3]<span class="comment"># cat cpu.cfs_period_us</span></span><br><span class="line">100000</span><br><span class="line">[root@VM-0-2-centos test-cgroup3]<span class="comment"># cat cpu.cfs_quota_us</span></span><br><span class="line">-1</span><br><span class="line">[root@VM-0-2-centos test-cgroup3]<span class="comment"># cat cpu.shares</span></span><br><span class="line">1024</span><br></pre></td></tr></table></figure><p>文件名中的 cfs 是 Linux 中普通调度算法中的一种，<strong>CFS（Completely Fair Scheduler，即完全公平调度器）</strong>，CGroup 中和 CFS 相关的参数一共三个：</p><ul><li><p>cpu.cfs_period_us，调度周期，一般值是 100k，单位 microseconds，也就是 100ms</p></li><li><p>cpu.cfs_quota_us，在一个调度周期里这个控制组被允许的运行时间，比如这个值为 50000 时，就是 50ms，默认 -1 表示不限制</p><p><em>50ms/100ms = 0.5，这样这个控制组被允许使用的 CPU 最大配额就是 0.5 个 CPU</em></p><p><em>cpu.cfs_quota_us 和 cpu.cfs_period_us 这两个值决定了每个控制组中所有进程的可使用 CPU 资源的最大值</em></p></li><li><p>cpu.shares，是 CPU  Cgroup 对于控制组之间的 CPU 分配比例，它的缺省值是 1024。</p><p><em>group3 中的 cpu.shares 是 1024，而 group4 中的 cpu.shares 是 3072，那么 group3:group4=1:3</em></p><p><em>cpu.shares 这个值决定了 CPU Cgroup 子系统下控制组可用 CPU 的相对比例，不过只有当系统上 CPU 完全被占满的时候，这个比例才会在各个控制组间起作用</em></p></li></ul><blockquote><p>Linux 中调度类型：</p><ul><li>普通调度，SCHED_NORMAL</li><li>实时调度<ul><li>SCHED_FIFO</li><li>SCHED_RR</li></ul></li></ul><p>进程如果设置为SCHED_FIFO 或者SCHED_RR实时调度类型，那么只要进程任务不结束，就不会把cpu资源让给SCHED_NORMAL进程。这种实时的进程，在实时性要比较高的嵌入式系统中会用到</p></blockquote><h2 id="Linux-如何计算进程-CPU-使用率和系统-CPU-使用率"><a href="#Linux-如何计算进程-CPU-使用率和系统-CPU-使用率" class="headerlink" title="Linux 如何计算进程 CPU 使用率和系统 CPU 使用率"></a>Linux 如何计算进程 CPU 使用率和系统 CPU 使用率</h2><h3 id="进程-CPU-使用率"><a href="#进程-CPU-使用率" class="headerlink" title="进程 CPU 使用率"></a>进程 CPU 使用率</h3><ul><li><p>top 命令源码：<a href="https://gitlab.com/procps-ng/procps">https://gitlab.com/procps-ng/procps</a></p></li><li><p>Linux proc 目录文档：<a href="https://man7.org/linux/man-pages/man5/proc.5.html">https://man7.org/linux/man-pages/man5/proc.5.html</a></p></li></ul><p>top 命令会读取 <code>/proc/[pid]/stat</code> 中的两个值（这个 stat 文件实时输出了进程的状态信息，比如进程的运行态（Running 还是 Sleeping）、父进程 PID、进程优先级、进程使用的内存等等总共 50 多项）。</p><p>utime 是表示进程的用户态部分在 Linux 调度中获得 CPU 的 ticks，stime 是表示进程的内核态部分在 Linux 调度中获得 CPU 的 ticks，utime 和 stime 都是一个累计值，也就是说从进程启动开始，这两个值就是一直在累积增长的。</p><p><strong>这个 ticks 可以使用 <code>getconf CLK_TCK</code> 取到。</strong></p><p>ticks 就是 Linux 操作系统中的一个时间单位，在 Linux 中有个自己的时钟，它会周期性地产生中断。每次中断都会触发 Linux 内核去做一次进程调度，而这一次中断就是一个 tick。</p><p>$$<br>进程的 CPU 使用率 =\frac{进程的 ticks}{单个 CPU 总 ticks}*100.0<br>$$</p><p>进程的 ticks = (utime_2 - utime_1) + (stime_2 - stime_1)；</p><p>单个CPU总 ticks = (HZ * et * 1)，HZ 是 1s ticks 次数，一般是 100，et 是时间；</p><p>举例：top threads-cpu 占用 200% CPU，使用 stat 文件中的 utime 和 stime 计算一下</p><p><img src="https://raw.githubusercontent.com/ahojcn/picgo-upload/main/202201042111668.png"></p><p><img src="https://raw.githubusercontent.com/ahojcn/picgo-upload/main/202201042111579.png"></p><p>utime_1 = 399，stime_1=0，utime_2=600，stime_2=0，((600 – 399) + (0 – 0)) * 100.0 / (100 * 1 * 1) =201，也就是 201% 和 top 一致。</p><h3 id="系统-CPU-使用率"><a href="#系统-CPU-使用率" class="headerlink" title="系统 CPU 使用率"></a>系统 CPU 使用率</h3><p>系统级别的在 /proc/stat 文件下，10 列数据，前 8 列对应 top 中 %Cpu(s) 这一行。</p><p><code>user/system/nice/idle/iowait/irq/softirq/steal</code></p><p>同样，在 /proc/stat 里的每一项的数值，就是系统自启动开始的 ticks。那么要计算出“瞬时”的 CPU 使用率，首先就要算出这个“瞬时”的 ticks，比如 1 秒钟的“瞬时”，我们可以记录开始时刻 T1 的 ticks, 然后再记录 1 秒钟后 T2 时刻的 ticks，再把这两者相减，就可以得到这 1 秒钟的 ticks 了。</p><p><img src="https://raw.githubusercontent.com/ahojcn/picgo-upload/main/202201042111367.png"></p><hr><p>回到问题，如何正确得到容器的 CPU 开销？</p><p>对于系统总的 CPU 使用率，需要读取 /proc/stat 文件，但是这个文件中的各项 CPU ticks 是反映整个节点的，并且这个 /proc/stat 文件也不包含在任意一个 Namespace 里。对于 top 命令来说，它只能显示整个节点中各项 CPU 的使用率，不能显示单个容器的各项 CPU 的使用率。</p><p>容器 cpu cgroup 下的 <code>cpuacct.stat</code> 文件，包含了两个统计值，这两个值分别是这个控制组里所有进程的内核态 ticks 和用户态的 ticks。</p><p><code>catcpuacct.stat;sleep1;catcpuacct.stat</code></p><hr><p>EOF</p>]]></content>
      
      
      <categories>
          
          <category> 容器高手实战课笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>容器高手实战课-容器的退出</title>
      <link href="/2021/12/26/%E5%AE%B9%E5%99%A8%E9%AB%98%E6%89%8B%E5%AE%9E%E6%88%98%E8%AF%BE-%E5%AE%B9%E5%99%A8%E7%9A%84%E9%80%80%E5%87%BA/"/>
      <url>/2021/12/26/%E5%AE%B9%E5%99%A8%E9%AB%98%E6%89%8B%E5%AE%9E%E6%88%98%E8%AF%BE-%E5%AE%B9%E5%99%A8%E7%9A%84%E9%80%80%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<p>问题：<code>docker stop 容器ID</code> 容器中的进程是如何退出的？</p><p>验证一下：</p><p>c 语言程序作为 init 进程，fork 一个子进程。使用上面的 c 程序作为容器 init 进程，构建镜像。</p><p>启动容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-0-2-centos fwd_sig]<span class="comment"># docker run -d --name fwd_sig_1 fwd_sig /c-init-sig</span></span><br><span class="line">2ed370d83b453b45eff4a51967bb791de32791b4ec27dbb75ffb682d0ebc8940</span><br></pre></td></tr></table></figure><p>宿主机上查看容器中两个进程的 PID：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@2ed370d83b45 /]<span class="comment"># ps -ef | grep c-init-sig</span></span><br><span class="line">root         1     0  0 14:44 ?        00:00:00 /c-init-sig</span><br><span class="line">root         6     1  0 14:44 ?        00:00:00 /c-init-sig</span><br><span class="line">root        22     7  0 14:45 pts/0    00:00:00 grep --color=auto c-init-sig</span><br></pre></td></tr></table></figure><p>使用 strace 来监控 init 进程和另一个进程收到的信号情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 终端 1， strace -p &lt;init进程pid&gt;</span></span><br><span class="line">[root@VM-0-2-centos ~]<span class="comment"># strace -p 17208</span></span><br><span class="line">strace: Process 17208 attached</span><br><span class="line">restart_syscall(&lt;... resuming interrupted <span class="built_in">read</span> ...&gt;) = 0</span><br><span class="line">nanosleep(&#123;tv_sec=100, tv_nsec=0&#125;, &#123;tv_sec=69, tv_nsec=910103396&#125;) = ? ERESTART_RESTARTBLOCK (Interrupted by signal)</span><br><span class="line">--- SIGTERM &#123;si_signo=SIGTERM, si_code=SI_USER, si_pid=0, si_uid=0&#125; ---</span><br><span class="line">write(1, <span class="string">&quot;To create 1 processes\nParent cre&quot;</span>..., 82) = 82</span><br><span class="line">exit_group(0)                           = ?</span><br><span class="line">+++ exited with 0 +++</span><br><span class="line"></span><br><span class="line"><span class="comment"># 终端 2， strace -p &lt;另一个进程pid&gt;</span></span><br><span class="line">[root@VM-0-2-centos fwd_sig]<span class="comment"># strace -p 17234</span></span><br><span class="line">strace: Process 17234 attached</span><br><span class="line">restart_syscall(&lt;... resuming interrupted <span class="built_in">read</span> ...&gt;) = ?</span><br><span class="line">+++ killed by SIGKILL +++</span><br></pre></td></tr></table></figure><p>init 进程收到 SIGTERM 信号退出，这时内核处理进程退出的入口点是 <code>do_exit()</code> 函数，<code>do_exit()</code> 会释放进程的相关资源（内存、文件句柄、信号量等）。在做完这些工作之后，它会调用一个 exit_notify() 函数，用来通知和这个进程相关的父子进程等。</p><p>对于容器来说，还要考虑 Pid Namespace 里的其他进程。这里调用的就是 zap_pid_ns_processes() 这个函数，而在这个函数中，如果是处于退出状态的 init 进程，它会向 Namespace 中的其他进程都发送一个 SIGKILL 信号。</p><p><img src="https://raw.githubusercontent.com/ahojcn/picgo-upload/main/202112262319721.png" alt="进程退出流程"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The last thread in the cgroup-init thread group is terminating.</span></span><br><span class="line"><span class="comment">     * Find remaining pid_ts in the namespace, signal and wait for them</span></span><br><span class="line"><span class="comment">     * to exit.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note:  This signals each threads in the namespace - even those that</span></span><br><span class="line"><span class="comment">     *        belong to the same thread group, To avoid this, we would have</span></span><br><span class="line"><span class="comment">     *        to walk the entire tasklist looking a processes in this</span></span><br><span class="line"><span class="comment">     *        namespace, but that could be unnecessarily expensive if the</span></span><br><span class="line"><span class="comment">     *        pid namespace has just a few processes. Or we need to</span></span><br><span class="line"><span class="comment">     *        maintain a tasklist for each pid namespace.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    read_lock(&amp;tasklist_lock);</span><br><span class="line">    nr = <span class="number">2</span>;</span><br><span class="line">    idr_for_each_entry_continue(&amp;pid_ns-&gt;idr, pid, nr) &#123;</span><br><span class="line">            task = pid_task(pid, PIDTYPE_PID);</span><br><span class="line">            <span class="keyword">if</span> (task &amp;&amp; !__fatal_signal_pending(task))</span><br><span class="line">                    group_send_sig_info(SIGKILL, SEND_SIG_PRIV, task, PIDTYPE_MAX);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>SIGKILL 信号是个特权信号，是无法捕获的，那么如何让容器中进程 graceful shutdown？或者说怎样让容器中的其他进程收到 SIGTERM 信号？</p><p>转发。</p><p>init 进程将收到的 SIGTERM 信号转发给子进程。比如 Docker Container 中使用的 tini 作为 init 进程，tini 会调<br>用 <code>sigtimedwait()</code> 来查看自己收到的信号然后调用 <code>kill()</code> 转发给子进程。</p><p>init 进程自己退出，还是会调用do_exit()的。所以呢，为了保证子进程先收到转发的SIGTERM, 类似tini的做法是，自己在收到SIGTERM的时候不退出，转发SIGTERM给子进程，子进程收到SIGTERM退出之后会给父进程发送SIGCHILD， tini是收到SIGCHILD之后主动整个程序退出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="type">int</span> <span class="title function_">wait_and_forward_signal</span><span class="params">(<span class="type">sigset_t</span> <span class="type">const</span>* <span class="type">const</span> parent_sigset_ptr, <span class="type">pid_t</span> <span class="type">const</span> child_pid)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">siginfo_t</span> sig;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sigtimedwait(parent_sigset_ptr, &amp;sig, &amp;ts) == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (errno) &#123;</span><br><span class="line">…</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* There is a signal to handle here */</span></span><br><span class="line">                <span class="keyword">switch</span> (sig.si_signo) &#123;</span><br><span class="line">                        <span class="keyword">case</span> SIGCHLD:</span><br><span class="line">                                <span class="comment">/* Special-cased, as we don&#x27;t forward SIGCHLD. Instead, we&#x27;ll</span></span><br><span class="line"><span class="comment">                                 * fallthrough to reaping processes.</span></span><br><span class="line"><span class="comment">                                 */</span></span><br><span class="line">                                PRINT_DEBUG(<span class="string">&quot;Received SIGCHLD&quot;</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                                PRINT_DEBUG(<span class="string">&quot;Passing signal: &#x27;%s&#x27;&quot;</span>, strsignal(sig.si_signo));</span><br><span class="line">                                <span class="comment">/* Forward anything else */</span></span><br><span class="line">                                <span class="keyword">if</span> (kill(kill_process_group ? -child_pid : child_pid, sig.si_signo)) &#123;</span><br><span class="line">                                        <span class="keyword">if</span> (errno == ESRCH) &#123;</span><br><span class="line">                                                PRINT_WARNING(<span class="string">&quot;Child was dead when forwarding signal&quot;</span>);</span><br><span class="line">                                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                                PRINT_FATAL(<span class="string">&quot;Unexpected error when forwarding signal: &#x27;%s&#x27;&quot;</span>, strerror(errno));</span><br><span class="line"></span><br><span class="line">                                                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>胖容器/富容器。</p></blockquote><blockquote><p>胖容器的init进程其实是一个bash脚本run.sh, 由它来启动jvm的程序。<br>但是run.sh本身没有注册SIGTERM handler, 也不forward SIGTERM给子进程jvm。<br>当stop容器的时候，run.sh先收到一个SIGTERM, run.sh没有注册SIGTERM, 所以呢对SIGTERM没有反应，contaienrd过30秒，会发SIGKILL给run.sh, 这样run.sh退出do_exit()，在退出的时候同样给子进程jvm程序发送了SIGKILL而不是SIGTERM。其实呢，jvm的程序是注册了SIGTERM handler的，但是没有机会调用handler了。</p></blockquote><p>EOF</p>]]></content>
      
      
      <categories>
          
          <category> 容器高手实战课笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>容器高手实战课-为什么不能kill掉1号进程</title>
      <link href="/2021/12/20/%E5%AE%B9%E5%99%A8%E9%AB%98%E6%89%8B%E5%AE%9E%E6%88%98%E8%AF%BE-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BDkill%E6%8E%891%E5%8F%B7%E8%BF%9B%E7%A8%8B/"/>
      <url>/2021/12/20/%E5%AE%B9%E5%99%A8%E9%AB%98%E6%89%8B%E5%AE%9E%E6%88%98%E8%AF%BE-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BDkill%E6%8E%891%E5%8F%B7%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>提出问题：</p><p>想修改容器镜像里的一个 bug，但是因为网络配置的问题，又不想为了重建 pod 而改变 pod IP。在 k8s 上没有 restart pod 这个指令。所以使用 <code>kill pid 1</code> 让容器原地重启。</p><p>测试想法：</p><p>使用 github 案例 <a href="https://github.com/chengyli/training/blob/main/init_proc/handle_sig/Dockerfile">Dockerfile</a> 构建镜像。</p><p>使用 init.sh 作为容器的 init 进程，执行 kill 1 和 kill -9 1，发现容器并未停止。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ahojliu@ubuntu:~/Downloads/training/init_proc/handle_sig$ docker run --name sig-proc -d sig-proc:v1 /init.sh</span><br><span class="line">36a9190fcd53ff9d8a0c6469708750ba5b856d6d72020997e6333a1f17bdb81b</span><br><span class="line">ahojliu@ubuntu:~/Downloads/training/init_proc/handle_sig$ docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE         COMMAND      CREATED         STATUS         PORTS     NAMES</span><br><span class="line">36a9190fcd53   sig-proc:v1   <span class="string">&quot;/init.sh&quot;</span>   3 seconds ago   Up 2 seconds             sig-proc</span><br><span class="line">ahojliu@ubuntu:~/Downloads/training/init_proc/handle_sig$ docker <span class="built_in">exec</span> -it 36a9190fcd53 bash</span><br><span class="line">[root@36a9190fcd53 /]<span class="comment"># ps -ef</span></span><br><span class="line">UID          PID    PPID  C STIME TTY          TIME CMD</span><br><span class="line">root           1       0  0 14:22 ?        00:00:00 /bin/bash /init.sh</span><br><span class="line">root           9       1  0 14:22 ?        00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=<span class="built_in">sleep</span> /usr/bin/sleep</span><br><span class="line">root          10       0  1 14:22 pts/0    00:00:00 bash</span><br><span class="line">root          26      10  0 14:22 pts/0    00:00:00 ps -ef</span><br><span class="line">[root@36a9190fcd53 /]<span class="comment"># kill 1</span></span><br><span class="line">[root@36a9190fcd53 /]<span class="comment"># kill -9 1</span></span><br><span class="line">[root@36a9190fcd53 /]<span class="comment"># ps -ef</span></span><br><span class="line">UID          PID    PPID  C STIME TTY          TIME CMD</span><br><span class="line">root           1       0  0 14:22 ?        00:00:00 /bin/bash /init.sh</span><br><span class="line">root           9       1  0 14:22 ?        00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=<span class="built_in">sleep</span> /usr/bin/sleep</span><br><span class="line">root          10       0  0 14:22 pts/0    00:00:00 bash</span><br><span class="line">root          27      10  0 14:22 pts/0    00:00:00 ps -ef</span><br></pre></td></tr></table></figure><p>使用 c 程序作为 init 进程，尝试上述操作，发现无法杀死这个 1 号进程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ahojliu@ubuntu:~/Downloads/training/init_proc/handle_sig$ docker run --name sig-proc-c -d sig-proc:v1 /c-init-nosig</span><br><span class="line">37db12aba7a59ed093c1934b2b316c3f1718db775d5536ef3c675acd9fdfe58c</span><br><span class="line">ahojliu@ubuntu:~/Downloads/training/init_proc/handle_sig$ docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE         COMMAND           CREATED         STATUS         PORTS     NAMES</span><br><span class="line">37db12aba7a5   sig-proc:v1   <span class="string">&quot;/c-init-nosig&quot;</span>   3 seconds ago   Up 2 seconds             sig-proc-c</span><br><span class="line">36a9190fcd53   sig-proc:v1   <span class="string">&quot;/init.sh&quot;</span>        9 minutes ago   Up 9 minutes             sig-proc</span><br><span class="line">ahojliu@ubuntu:~/Downloads/training/init_proc/handle_sig$ docker <span class="built_in">exec</span> -it 37db12aba7a5 bash</span><br><span class="line">[root@37db12aba7a5 /]<span class="comment"># ps -ef</span></span><br><span class="line">UID          PID    PPID  C STIME TTY          TIME CMD</span><br><span class="line">root           1       0  0 14:32 ?        00:00:00 /c-init-nosig</span><br><span class="line">root           8       0  2 14:32 pts/0    00:00:00 bash</span><br><span class="line">root          23       8  0 14:32 pts/0    00:00:00 ps -ef</span><br><span class="line">[root@37db12aba7a5 /]<span class="comment"># kill -9 1</span></span><br><span class="line">[root@37db12aba7a5 /]<span class="comment"># kill 1</span></span><br><span class="line">[root@37db12aba7a5 /]<span class="comment"># ps -ef</span></span><br><span class="line">UID          PID    PPID  C STIME TTY          TIME CMD</span><br><span class="line">root           1       0  0 14:32 ?        00:00:00 /c-init-nosig</span><br><span class="line">root           8       0  0 14:32 pts/0    00:00:00 bash</span><br><span class="line">root          24       8  0 14:32 pts/0    00:00:00 ps -ef</span><br><span class="line">[root@37db12aba7a5 /]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>使用 go 程序作为 init 进程，再次执行上述操作，发现 kill -9 1 不能杀死，但是 kill 1 可以杀死进程，容器退出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ahojliu@ubuntu:~/Downloads/training/init_proc/handle_sig$ docker run --name sig-proc -d sig-proc:v1 /go-init</span><br><span class="line">e292f5c65155839804c4f4de582fbd01a7ab4843a2645d1a5ec5d7b77a6d185b</span><br><span class="line">ahojliu@ubuntu:~/Downloads/training/init_proc/handle_sig$ docker <span class="built_in">exec</span> -it e292f5c651558 bash</span><br><span class="line">[root@e292f5c65155 /]<span class="comment"># ps -ef</span></span><br><span class="line">UID          PID    PPID  C STIME TTY          TIME CMD</span><br><span class="line">root           1       0  0 14:34 ?        00:00:00 /go-init</span><br><span class="line">root          11       0  1 14:34 pts/0    00:00:00 bash</span><br><span class="line">root          26      11  0 14:34 pts/0    00:00:00 ps -ef</span><br><span class="line">[root@e292f5c65155 /]<span class="comment"># kill -9 1</span></span><br><span class="line">[root@e292f5c65155 /]<span class="comment"># kill 1</span></span><br><span class="line">ahojliu@ubuntu:~/Downloads/training/init_proc/handle_sig$</span><br></pre></td></tr></table></figure><p>干货：</p><p><code>kill 1</code> 向 1 号进程发送了 SIGTERM(15) 信号；<br><code>kill -9 1</code> 向 1 号进程发送 SIGKILL(9) 信号；<br><code>Ctrl+c</code> 是 SIGINT(2) 信号。</p><p>查看信号编号和名称：<code>kill -l</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ahojliu@ubuntu:~/Downloads/training/init_proc/handle_sig$ <span class="built_in">kill</span> -l</span><br><span class="line"> 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP</span><br><span class="line"> 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL10) SIGUSR1</span><br><span class="line">11) SIGSEGV12) SIGUSR213) SIGPIPE14) SIGALRM15) SIGTERM</span><br><span class="line">16) SIGSTKFLT17) SIGCHLD18) SIGCONT19) SIGSTOP20) SIGTSTP</span><br><span class="line">21) SIGTTIN22) SIGTTOU23) SIGURG24) SIGXCPU25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM27) SIGPROF28) SIGWINCH29) SIGIO30) SIGPWR</span><br><span class="line">31) SIGSYS34) SIGRTMIN35) SIGRTMIN+136) SIGRTMIN+237) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+439) SIGRTMIN+540) SIGRTMIN+641) SIGRTMIN+742) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+944) SIGRTMIN+1045) SIGRTMIN+1146) SIGRTMIN+1247) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+1449) SIGRTMIN+1550) SIGRTMAX-1451) SIGRTMAX-1352) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-1154) SIGRTMAX-1055) SIGRTMAX-956) SIGRTMAX-857) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-659) SIGRTMAX-560) SIGRTMAX-461) SIGRTMAX-362) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-164) SIGRTMAX</span><br></pre></td></tr></table></figure><p>进程在收到信号后的处理方式：<br>1）忽略(Ignore)，对于信号不作任何处理，但是除 SIGKILL 和 SIGSTOP 两个特权信号(这两个作用是为 kernel 和 超级用户提供删除任意进程的特权)；<br>2）捕获(Catch)，用户进程可以注册针对这个信号的 handler(特权信号不能有用户自己的处理代码，只能执行系统缺省行为)；<br>3）缺省(Default)，Linux 系统对每一个信号都定义了一个缺省行为(<code>man 7 signal</code>查看)。</p><p>运行 <code>kill 1</code> 命令时候，Linux 调用 <code>kill()</code> 系统调用进入内核函数 <code>sys_kill()</code>，内核会调用 <code>sig_task_ignored()</code> 函数来判断是否将信号发送给 1 号进程。<code>sig_task_ignored()</code> 实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">kernel/signal.c</span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">sig_task_ignored</span><span class="params">(<span class="keyword">struct</span> task_struct *t, <span class="type">int</span> sig, <span class="type">bool</span> force)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">void</span> __user *handler;</span><br><span class="line">        handler = sig_handler(t, sig);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* SIGKILL and SIGSTOP may not be sent to the global init */</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(is_global_init(t) &amp;&amp; sig_kernel_only(sig)))</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(t-&gt;signal-&gt;flags &amp; SIGNAL_UNKILLABLE) &amp;&amp;</span><br><span class="line">            handler == SIG_DFL &amp;&amp; !(force &amp;&amp; sig_kernel_only(sig)))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Only allow kernel generated signals to this kthread */</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely((t-&gt;flags &amp; PF_KTHREAD) &amp;&amp;</span><br><span class="line">                     (handler == SIG_KTHREAD_KERNEL) &amp;&amp; !force))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sig_handler_ignored(handler, sig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个 if：如果是 SIGKILL(9) 和 SIGSTOP(19) 并且发送给 init 进程就忽略。<br>第三个 if：仅允许内核生成的信号发送到 kthread。<br><strong>重点</strong>是第二个 if：</p><ol><li><code>!(force &amp;&amp; sig_kernel_only(sig))</code> 其中 <code>force</code> 对于同一个 Namespace 发送的信号来说是 0，不同 Namespace 发出的是 1。</li><li><code>handler==SIG_DFL</code> 判断是否为系统缺省的 handler，用户如果不注册自己的 handler 此项为 true。</li><li><code>t-&gt;signal-&gt;flags &amp; SIGNAL_UNKILLABLE</code> 进程必须是 UNKILLABLE 的，这个 flag 在每个 Namespace 的 init 进程建立的时候就会打上，也就是只要是 1 号进程就会有这个 flag(参考一下代码：kernel/fork.c)。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">kernel/fork.c</span><br><span class="line">                       <span class="title function_">if</span> <span class="params">(is_child_reaper(pid))</span> &#123;</span><br><span class="line">                                ns_of_pid(pid)-&gt;child_reaper = p;</span><br><span class="line">                                p-&gt;signal-&gt;flags |= SIGNAL_UNKILLABLE;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * is_child_reaper returns true if the pid is the init process</span></span><br><span class="line"><span class="comment"> * of the current namespace. As this one could be checked before</span></span><br><span class="line"><span class="comment"> * pid_ns-&gt;child_reaper is assigned in copy_process, we check</span></span><br><span class="line"><span class="comment"> * with the pid number.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">is_child_reaper</span><span class="params">(<span class="keyword">struct</span> pid *pid)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> pid-&gt;numbers[pid-&gt;level].nr == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>总结：最关键一点就是 <code>handler==SIG_DFL</code>，所以 init 进程是永远不能被 SIGKILL 杀掉，但是可以被 SIGTERM 杀掉(SIGKILL 不允许注册 handler)。</li></ol><p>查看进程注册了那些信号：<code>cat /proc/&lt;pid&gt;/status | grep SigCgt</code>，掩码位解释：<a href="https://qastack.cn/unix/85364/how-can-i-check-what-signals-a-process-is-listening-to">qastack.cn</a>。</p><p>bash 程序注册了 2 个 handler，SIGINT(2) 和 SIGCHLD(17)，但是没有注册 SIGTERM 所以 <code>kill 1</code> 杀不掉；<br>c 程序缺省状态下，没有注册任何信号的 handler，所以默认都被系统忽略；<br>go 程序中注册了很多 handler，包括了 SIGTERM(15) 所以可以被 <code>kill 1</code> 干掉。</p><p>给 c 程序增加 SIGTERM 的 handler，在 handler 中主动退出，运行 <code>kill 1</code> 如期：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sig_handler</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (signo == SIGTERM) &#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;received SIGTERM\n&quot;</span>);</span><br><span class="line">           <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    signal(SIGTERM, sig_handler);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Process is sleeping\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">           sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ahojliu@ubuntu:~$ docker <span class="built_in">exec</span> -it 6b07b9b46a43 bash</span><br><span class="line">[root@6b07b9b46a43 /]<span class="comment"># ps -ef</span></span><br><span class="line">UID          PID    PPID  C STIME TTY          TIME CMD</span><br><span class="line">root           1       0  0 15:22 ?        00:00:00 /c-init-sig</span><br><span class="line">root           8       0  0 15:22 pts/0    00:00:00 bash</span><br><span class="line">root          23       8  0 15:22 pts/0    00:00:00 ps -ef</span><br><span class="line">[root@6b07b9b46a43 /]<span class="comment"># cat /proc/1/status | grep SigCgt</span></span><br><span class="line">SigCgt:0000000000004000</span><br><span class="line">[root@6b07b9b46a43 /]<span class="comment"># kill 1</span></span><br><span class="line">[root@6b07b9b46a43 /]<span class="comment"># ahojliu@ubuntu:~$ docker ps</span></span><br><span class="line">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span><br><span class="line">ahojliu@ubuntu:~$</span><br><span class="line">ahojliu@ubuntu:~$ docker logs 6b07b9b46a43</span><br><span class="line">Process is sleeping</span><br><span class="line">received SIGTERM</span><br></pre></td></tr></table></figure><p>在宿主机上 <code>kill &lt;pid&gt;</code> 不可以杀掉容器 init 进程，<code>!(force &amp;&amp; sig_kernel_only(sig))</code> 中 force 为 1 且 SIGTERM 不是内核信号，所以忽略；<code>kill -9 &lt;pid&gt;</code> 可以杀掉容器 init 进程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ahojliu@ubuntu:~/Downloads/training/init_proc/handle_sig$ docker ps</span><br><span class="line">CONTAINER ID   IMAGE         COMMAND           CREATED         STATUS        PORTS     NAMES</span><br><span class="line">9136344690d9   sig-proc:v1   &quot;/c-init-nosig&quot;   3 seconds ago   Up 1 second             sig-proc</span><br><span class="line">ahojliu@ubuntu:~/Downloads/training/init_proc/handle_sig$ pstree -stp | grep c-init</span><br><span class="line">           |-containerd-shim(66795)-+-c-init-nosig(66817)</span><br><span class="line">ahojliu@ubuntu:~/Downloads/training/init_proc/handle_sig$ ps -ef | grep 66817</span><br><span class="line">root       66817   66795  0 07:38 ?        00:00:00 /c-init-nosig</span><br><span class="line">ahojliu    66858   60688  0 07:38 pts/1    00:00:00 grep --color=auto 66817</span><br><span class="line">ahojliu@ubuntu:~/Downloads/training/init_proc/handle_sig$ kill 66817</span><br><span class="line">-bash: kill: (66817) - Operation not permitted</span><br><span class="line">ahojliu@ubuntu:~/Downloads/training/init_proc/handle_sig$ sudo -i</span><br><span class="line">[sudo] password for ahojliu:</span><br><span class="line">root@ubuntu:~# kill 66817</span><br><span class="line">root@ubuntu:~# ps -ef | grep 66817</span><br><span class="line">root       66817   66795  0 07:38 ?        00:00:00 /c-init-nosig</span><br><span class="line">root       66870   66860  0 07:39 pts/1    00:00:00 grep --color=auto 66817</span><br><span class="line">root@ubuntu:~# kill -9 66817</span><br><span class="line">root@ubuntu:~# ps -ef | grep 66817</span><br><span class="line">root       66892   66860  0 07:39 pts/1    00:00:00 grep --color=auto 66817</span><br><span class="line">root@ubuntu:~# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span><br></pre></td></tr></table></figure><p>但是其实在生产中很多普通用户是没有宿主机权限的。</p><hr><p>EOF</p>]]></content>
      
      
      <categories>
          
          <category> 容器高手实战课笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>容器高手实战课-Docker容器实现原理</title>
      <link href="/2021/12/13/%E5%AE%B9%E5%99%A8%E9%AB%98%E6%89%8B%E5%AE%9E%E6%88%98%E8%AF%BE-Docker%E5%AE%B9%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2021/12/13/%E5%AE%B9%E5%99%A8%E9%AB%98%E6%89%8B%E5%AE%9E%E6%88%98%E8%AF%BE-Docker%E5%AE%B9%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h1><p>Namespace 其实就是一种隔离机制，将运行在同一宿主机上的容器隔离开，不同 Namespace 下容器间不能访问彼此的资源。</p><p>隔离的两个作用：</p><ol><li>充分利用系统资源（同一台宿主机上可以运行多个用户容器）；</li><li>安全性（访问资源控制）。</li></ol><p><img src="https://raw.githubusercontent.com/ahojcn/picgo-upload/main/202112131757057.png" alt="Namespace类型"></p><p>查看系统支持的 Namespace：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l /proc/self/ns/</span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx 1 ahojliu ahojliu 0 Dec 13 01:59 cgroup -&gt; <span class="string">&#x27;cgroup:[4026531835]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 ahojliu ahojliu 0 Dec 13 01:59 ipc -&gt; <span class="string">&#x27;ipc:[4026531839]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 ahojliu ahojliu 0 Dec 13 01:59 mnt -&gt; <span class="string">&#x27;mnt:[4026531840]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 ahojliu ahojliu 0 Dec 13 01:59 net -&gt; <span class="string">&#x27;net:[4026531992]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 ahojliu ahojliu 0 Dec 13 01:59 pid -&gt; <span class="string">&#x27;pid:[4026531836]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 ahojliu ahojliu 0 Dec 13 01:59 pid_for_children -&gt; <span class="string">&#x27;pid:[4026531836]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 ahojliu ahojliu 0 Dec 13 01:59 time -&gt; <span class="string">&#x27;time:[4026531834]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 ahojliu ahojliu 0 Dec 13 01:59 time_for_children -&gt; <span class="string">&#x27;time:[4026531834]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 ahojliu ahojliu 0 Dec 13 01:59 user -&gt; <span class="string">&#x27;user:[4026531837]&#x27;</span></span><br><span class="line">lrwxrwxrwx 1 ahojliu ahojliu 0 Dec 13 01:59 uts -&gt; <span class="string">&#x27;uts:[4026531838]</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ahojcn/picgo-upload/main/202112131754061.png" alt="PID Namespace Demo"></p><h1 id="cgroups"><a href="#cgroups" class="headerlink" title="cgroups"></a>cgroups</h1><p>cgroups 可以对指定的 <strong>进程</strong> 做各种计算机资源的限制，如 CPU 使用率、内存使用量、IO 设备的流量等等。</p><p>cgroups 通过不同的子系统限制了不同的资源，每个子系统限制一种资源。每个子系统限制资源的方式都是类似的，就是把相关的一组进程分配到一个控制组里，然后通过树结构进行管理，每个控制组都设有自己的资源控制参数。</p><p>定义：<a href="https://man7.org/linux/man-pages/man7/cgroups.7.html">Linux manual page - cgroups</a></p><ul><li>CPU 子系统，用来限制一个控制组（一组进程，你可以理解为一个容器里所有的进程）可使用的最大 CPU。</li><li>memory 子系统，用来限制一个控制组最大的内存使用量。</li><li>pids 子系统，用来限制一个控制组里最多可以运行多少个进程。</li><li>cpuset 子系统， 这个子系统来限制一个控制组里的进程可以在哪几个物理 CPU 上运行。</li></ul><p>Cgroups 有 v1 和 v2 两个版本：</p><ul><li>Cgroups v1 在 Linux 中很早就实现了，各种子系统比较独立，每个进程在各个 Cgroups 子系统中独立配置，可以属于不同的 group。虽然这样比较灵活，但是也存在问题，会导致对同一进程的资源协调比较困难（比如 memory Cgroup 与 blkio Cgroup 之间就不能协作）。虽然 v1 有缺陷，但是在主流的生产环境中，大部分使用的还是 v1。</li><li>Cgroups v2 做了设计改进，解决了 v1 的问题，使各个子系统可以协调统一地管理资源。不过 Cgroups v2 在生产环境的应用还很少，因为该版本很多子系统的实现需要较新版本的 Linux 内核，还有无论是主流的 Linux 发行版本还是容器云平台，比如 Kubernetes，对 v2 的支持也刚刚起步。</li></ul><blockquote><p>对于启动的每个容器，都会在 Cgroups 子系统下建立一个目录，在 Cgroups 中这个目录也被称作控制组，比如下图里的”docker-<id1>“”docker-<id2>“等。然后我们设置这个控制组的参数，通过这个方式，来限制这个容器的内存资源。</p></blockquote><p><img src="https://raw.githubusercontent.com/ahojcn/picgo-upload/main/202112131807098.png" alt="memory cgroups demo"></p><p>在 Ubuntu 20.04，我安装 Docker 是使用 get-docker.com 脚本安装的，默认使用 systemd 来管理的，所以目录和图中有一些不同。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /sys/fs/cgroup/memory/docker/&lt;容器ID&gt;</span></span><br><span class="line"></span><br><span class="line">ahojliu@ubuntu:/sys/fs/cgroup/memory/docker/210401ffb15b18832b6a104d8aebac98cd29ff20fe0bc779f4ddfe04923faf46$ <span class="built_in">ls</span></span><br><span class="line">cgroup.clone_children               memory.memsw.failcnt</span><br><span class="line">cgroup.event_control                memory.memsw.limit_in_bytes</span><br><span class="line">cgroup.procs                        memory.memsw.max_usage_in_bytes</span><br><span class="line">memory.failcnt                      memory.memsw.usage_in_bytes</span><br><span class="line">memory.force_empty                  memory.move_charge_at_immigrate</span><br><span class="line">memory.kmem.failcnt                 memory.numa_stat</span><br><span class="line">memory.kmem.limit_in_bytes          memory.oom_control</span><br><span class="line">memory.kmem.max_usage_in_bytes      memory.pressure_level</span><br><span class="line">memory.kmem.slabinfo                memory.soft_limit_in_bytes</span><br><span class="line">memory.kmem.tcp.failcnt             memory.stat</span><br><span class="line">memory.kmem.tcp.limit_in_bytes      memory.swappiness</span><br><span class="line">memory.kmem.tcp.max_usage_in_bytes  memory.usage_in_bytes</span><br><span class="line">memory.kmem.tcp.usage_in_bytes      memory.use_hierarchy</span><br><span class="line">memory.kmem.usage_in_bytes          notify_on_release</span><br><span class="line">memory.limit_in_bytes               tasks</span><br><span class="line">memory.max_usage_in_bytes</span><br></pre></td></tr></table></figure><p>案例：将这个控制组 memory 最大用量设置为 2GB。</p><p>设置后，cgroup.procs 里面所有进程 Memory 使用量之和，最大也不会超过 2GB。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># （2* 1024 * 1024 * 1024 = 2147483648）</span></span><br><span class="line"><span class="comment"># 注意要使用 root</span></span><br><span class="line">root@ubuntu:~<span class="comment"># cd /sys/fs/cgroup/memory/docker/210401ffb15b18832b6a104d8aebac98cd29ff20fe0bc779f4ddfe04923faf46</span></span><br><span class="line"></span><br><span class="line">root@ubuntu:/sys/fs/cgroup/memory/docker/210401ffb15b18832b6a104d8aebac98cd29ff20fe0bc779f4ddfe04923faf46<span class="comment"># echo 2147483648 &gt; memory.limit_in_bytes</span></span><br><span class="line"></span><br><span class="line">root@ubuntu:/sys/fs/cgroup/memory/docker/210401ffb15b18832b6a104d8aebac98cd29ff20fe0bc779f4ddfe04923faf46<span class="comment"># cat memory.limit_in_bytes</span></span><br><span class="line">2147483648</span><br></pre></td></tr></table></figure><hr><p>EOF</p>]]></content>
      
      
      <categories>
          
          <category> 容器高手实战课笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用docker搭建ansible学习环境</title>
      <link href="/2020/10/16/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAansible%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/"/>
      <url>/2020/10/16/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAansible%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p>最近装了 Win10 + Ubuntu20.04 双系统，Win10 用来打游戏，Ubuntu 用来学习。</p><p>/手动狗头</p><p>环境：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ubuntu20.04  Linux Kernel 5.4.0-48-generic</span><br><span class="line">Docker Version 19.03.13</span><br></pre></td></tr></table></figure><h2 id="1、启动-2-个-centos7-镜像"><a href="#1、启动-2-个-centos7-镜像" class="headerlink" title="1、启动 2 个 centos7 镜像"></a>1、启动 2 个 centos7 镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos:7</span><br><span class="line">docker run -itd --name centos7-1 centos:7</span><br><span class="line">docker run -itd --name centos7-2 centos:7</span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure><h2 id="2、容器中安装-openssh"><a href="#2、容器中安装-openssh" class="headerlink" title="2、容器中安装 openssh"></a>2、容器中安装 openssh</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it centos7-1 bash</span><br><span class="line">yum install net-tools</span><br><span class="line">yum install passwd openssl openssh-server -y</span><br></pre></td></tr></table></figure><p>修改 ssh 服务配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yum install vim</span><br><span class="line">vim /etc/ssh/sshd_config</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启 22 端口监听(Port)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">允许 any 地址登录(AddressFamily &amp;&amp; ListenAddress)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">允许 root 用户登录(PermitRootLogin)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">UseDNS no 或者注释掉</span></span><br></pre></td></tr></table></figure><p>启动 ssh 服务报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@ b3426410ff43 /]# /usr/sbin/sshd</span><br><span class="line">Could not load host key: /etc/ssh/ssh_host_rsa_key</span><br><span class="line">Could not load host key: /etc/ssh/ssh_host_ecdsa_key</span><br><span class="line">Could not load host key: /etc/ssh/ssh_host_ed25519_key</span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@b3426410ff43 /]# ssh-keygen -q -t rsa -b 2048 -f /etc/ssh/ssh_host_rsa_key -N &#x27;&#x27;</span><br><span class="line">[root@b3426410ff43 /]# ssh-keygen -q -t ecdsa -f /etc/ssh/ssh_host_ecdsa_key -N &#x27;&#x27;</span><br><span class="line">[root@b3426410ff43 /]# ssh-keygen -t dsa -f /etc/ssh/ssh_host_ed25519_key -N &#x27;&#x27;</span><br></pre></td></tr></table></figure><p>然后再次启动 ssh 服务即可。</p><h2 id="3、宿主机安装-ansible-并测试"><a href="#3、宿主机安装-ansible-并测试" class="headerlink" title="3、宿主机安装 ansible 并测试"></a>3、宿主机安装 ansible 并测试</h2><p>安装 ansible：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方法 1(如果宿主机是 centos 注意安装一下 epel-release)</span></span><br><span class="line">sudo apt-get install ansible</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方法 2</span></span><br><span class="line">pip install ansible</span><br></pre></td></tr></table></figure><p>生成 ssh key：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拷贝宿主机 public key 到两个容器内</span></span><br><span class="line">ssh-copt-id root@container-ip1</span><br><span class="line">ssh-copt-id root@container-ip2</span><br></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible all -i root@172.17.0.2,root@172.17.0.3 -m ping</span><br></pre></td></tr></table></figure><hr><p>待续</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正向代理和反向代理</title>
      <link href="/2020/07/18/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
      <url>/2020/07/18/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>转载自：<a href="https://www.cnblogs.com/taostaryu/p/10547132.html">https://www.cnblogs.com/taostaryu/p/10547132.html</a></p><h2 id="什么是代理"><a href="#什么是代理" class="headerlink" title="什么是代理"></a>什么是代理</h2><p>代理其实就是一个中介，A和B本来可以直连，中间插入一个C，C就是中介。<br>刚开始的时候，代理多数是帮助内网client访问外网server用的<br>后来出现了反向代理，”反向”这个词在这儿的意思其实是指方向相反，即代理将来自外网客户端的请求转发到内网服务器，从外到内</p><h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><p>正向代理类似一个跳板机，代理访问外部资源</p><p>比如我们国内访问谷歌，直接访问访问不到，我们可以通过一个正向代理服务器，请求发到代理服，代理服务器能够访问谷歌，这样由代理去谷歌取到返回数据，再返回给我们，这样我们就能访问谷歌了</p><p><img src="https://i.loli.net/2020/07/18/nhzMFwQHLNsYqav.png"></p><p><strong>正向代理的用途：</strong></p><p>（1）访问原来无法访问的资源，如google</p><p>（2） 可以做缓存，加速访问资源</p><p>（3）对客户端访问授权，上网进行认证</p><p>（4）代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息</p><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器</p><p><img src="https://i.loli.net/2020/07/18/baUfvLdgEqt1rny.png"></p><p><strong>反向代理的作用：</strong></p><p>（1）保证内网的安全，阻止web攻击，大型网站，通常将反向代理作为公网访问地址，Web服务器是内网</p><p>（2）负载均衡，通过反向代理服务器来优化网站的负载</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>正向代理即是客户端代理, 代理客户端, 服务端不知道实际发起请求的客户端.</strong><br><strong>反向代理即是服务端代理, 代理服务端, 客户端不知道实际提供服务的服务端</strong></p><p><img src="https://i.loli.net/2020/07/18/OHabJhWNQP3MtL7.png"></p><p><img src="https://i.loli.net/2020/07/18/cMlfiLoTWgY5Ikz.png"></p><p>正向代理中，proxy和client同属一个LAN，对server透明；<br>反向代理中，proxy和server同属一个LAN，对client透明。<br>实际上proxy在两种代理中做的事都是代为收发请求和响应，不过从结构上来看正好左右互换了下，所以把后出现的那种代理方式叫成了反向代理</p><p>正向代理: 买票的黄牛</p><p>反向代理: 租房的代理</p><p>EOF</p>]]></content>
      
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx配置实例</title>
      <link href="/2020/07/18/Nginx%E9%85%8D%E7%BD%AE%E5%AE%9E%E4%BE%8B/"/>
      <url>/2020/07/18/Nginx%E9%85%8D%E7%BD%AE%E5%AE%9E%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例 1"></a>实例 1</h3><p><strong>实现效果</strong></p><p>打开浏览器，输入地址，跳转到 Linux 的 Tomcat 的主页面中。</p><p><img src="https://i.loli.net/2020/07/18/mcLFe9oyCOBHqkT.png"></p><p><strong>准备工作</strong></p><p>安装 Tomcat，使用默认端口 8080。</p><p>下载、解压、运行 /bin/startup.sh 即可。</p><p>开放防火墙的 8080 端口，重启防火墙。</p><p>验证完了 tomcat 安装好后，可以关闭 8080 端口。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --remove-port=8080/tcp --permanent</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/07/18/YDROMrLmEx9nbXe.png"></p><p><strong>配置 nginx</strong></p><p>保存配置文件，reload 即可。</p><p><img src="https://i.loli.net/2020/07/18/bqHJYkBIuiShpyL.png"></p><p><img src="https://i.loli.net/2020/07/18/e7Lk2ZKFScPEoHs.png"></p><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例 2"></a>实例 2</h3><p><strong>实现效果</strong></p><p>使用 nginx 反向代理，根据访问的路径跳转到不同端口的服务中</p><p>nginx 监听端口 80</p><p>访问 <a href="http://ip/edu/">http://ip/edu/</a> 跳转到 127.0.0.1:8080</p><p>访问 <a href="http://ip/vod/">http://ip/vod/</a> 跳转到 127.0.0.1:8081</p><p><strong>准备工作</strong></p><p>创建两个 tomcat 服务器，一个 8080，一个 8081(修改配置文件)，复制两个 tomcat 文件夹，启动 tomcat。</p><p>创建文件夹和测试页面，放在 tomcat 下的 webapps 目录下即可。</p><p><img src="https://i.loli.net/2020/07/18/zCoLsqmXMfb6av7.png"></p><p><img src="https://i.loli.net/2020/07/18/cvThDunSd5bOEak.png"></p><p><strong>配置</strong> <strong>nginx</strong></p><p><img src="https://i.loli.net/2020/07/18/8f2DHsAbJymSuKh.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">= 用户不含正则表达式的 uri 前，要求请求字符串与 uri 严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求。</span><br><span class="line"></span><br><span class="line">~ 用于表示 uri 包含正则表达式，并且区分大小写。</span><br><span class="line"></span><br><span class="line">~* 用于表示 uri 包含正则表达式，不区分大小写。</span><br><span class="line"></span><br><span class="line">^~ 用于不含正则表达式的 uri 前，要求 nginx 服务器找到标识 uri 和请求字符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再使用 location 块中的正则 uri 和请求字符串做匹配。</span><br><span class="line"></span><br><span class="line">注意：如果 uri 包含正则表达式，则必须要有 ~ 或者 ~* 标识！</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/07/18/XTy8t2vsuOE9Z7a.png"></p><p><img src="https://i.loli.net/2020/07/18/IpdMPTfH5zC7ay3.png"></p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>Linux 下提供负载均衡的东西有：Nginx、LVS、Haproxy 等。</p><p>nginx 提供的几种负载均衡分配策略：</p><ul><li><p>轮询（默认）</p><p>每个请求按时间顺序逐一分配到不同的服务器上，如果后端 down 掉，就自动剔除。</p></li><li><p>weight</p><p>权重，默认权重为 1，权重越高被分配的客户端越多。</p><p>指定轮询几率，weight 和访问比例成正比，用于后端服务器性能不均的情况。</p><p>配置方式就是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream myserver &#123;</span><br><span class="line">server 127.0.0.1:8080;</span><br><span class="line">server 127.0.0.1:8081;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ip_hash</p><p>每个请求按 ip 的 hash 结果分配，这样每个访客固定一个后端服务器，可以解决 session 共享的问题。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream myserver &#123;</span><br><span class="line">ip_hash;</span><br><span class="line">server 127.0.0.1:8080;</span><br><span class="line">server 127.0.0.1:8081;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>fair（第三方）</p><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream myserver &#123;</span><br><span class="line">server 127.0.0.1:8080;</span><br><span class="line">server 127.0.0.1:8081;</span><br><span class="line">fair;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>实现效果</strong></p><p>浏览器输入地址，负载均衡效果，访问平均到 8080 和 8081 中。</p><p><strong>准备工作</strong></p><p>两台 tomcat 服务器，8080 和 8081，创建统一的页面 edu/a.html。</p><p><img src="https://i.loli.net/2020/07/18/C6leUZYzGxBIWfb.png"></p><p><strong>配置 nginx</strong></p><p>http 块中配置 upstream，在 location 中增加 proxy_pass。</p><p><img src="https://i.loli.net/2020/07/18/US5CeJZGDjyd614.png"></p><p><img src="https://i.loli.net/2020/07/18/JBWfYczj2w4T9Cm.gif"></p><h2 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h2><p><strong>什么是动静分离？</strong></p><p>简单来说就是动态和静态请求分来，不能理解成知识单纯的把动态页面和静态页面物理分离。</p><p>严格来说是动态请求跟静态请求分开，可以理解成用 nginx 处理静态页面，tomcat 处理动态页面。</p><p>动静分离从目前实现角度来说大致分为 2 种。</p><ol><li><p>纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流的方案。</p><img src="https://i.loli.net/2020/07/18/x9hIqsVmdPXZ6lN.png" style="zoom:25%;" /></li><li><p>动态和静态文件混合在一起发布，通过 nginx 分开。</p><p>通过 location 指定不同的后缀实现不同的请求转发。通过 expires 参数设置，可以使浏览器缓存过期时间，减少与服务器之间的请求和流量。具体 expires 定义：是给一个资源设置一个过期时间，无需去服务端验证，直接通过浏览器自身确认是否过期即可，不会产生额外的流量。此种方法非常适合不经常变动的资源。（如果经常更新的文件，不建议使用 expires 来缓存），我这里设置 3d，表示 3 天内访问这个 url，发送一个请求，比对服务器该文件最后更新时间有没有变换，没有变化则不从服务器专区，返回状态码 304，如果有修改，直接从服务器重新下载，返回状态码 200。</p></li></ol><p><strong>准备工作</strong></p><p>准备静态资源，等会访问。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-7 data]# ls image/</span><br><span class="line">1.jpg</span><br><span class="line">[root@centos-7 data]# ls www/</span><br><span class="line">a.html</span><br><span class="line">[root@centos-7 data]# pwd</span><br><span class="line">/data</span><br><span class="line">[root@centos-7 data]#</span><br></pre></td></tr></table></figure><p><strong>配置 nginx</strong></p><p>当然，要加 expires 也是在 location 中加入。</p><img src="https://i.loli.net/2020/07/18/D7R1mT5yHxGLYOw.png" style="zoom:33%;" /><img src="https://i.loli.net/2020/07/18/reaoNEO8AHQKpsc.png" style="zoom:33%;" /><h2 id="高可用配置"><a href="#高可用配置" class="headerlink" title="高可用配置"></a>高可用配置</h2><p>如果只有一个 nginx 来做代理，挂了怎么办？</p><p>nginx 可以做主备使用的方案。</p><p><img src="https://i.loli.net/2020/07/18/QTLFAbEijPn86Go.png"></p><p>这两个 nginx 都需要需要用到 keepalived。</p><p>这两个 nginx 对外需要提供一个虚拟 ip。</p><p><strong>准备工作</strong></p><p>1、需要两台 nginx 服务器</p><p>2、需要在两台服务器上安装 keepalived</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install keepalived</span><br></pre></td></tr></table></figure><p>查看是否安装好</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-7 nginx]# rpm -q -a keepalived</span><br><span class="line">keepalived-1.3.5-16.el7.x86_64</span><br></pre></td></tr></table></figure><p>默认的 keepalived 配置在 /etc/keepalived/keepalived.conf</p><p>3、需要虚拟 ip</p><p>高可用配置</p><p>​    主要修改 keepalived 的配置文件。</p><p>​    配置文件如下文，注意有的 keeplived 使用 shell 来检测的，shell 脚本如下文。</p><p>然后将两台服务器上的 nginx 和 keepalived 都启动。</p><p>​    启动 keepalived</p><p>​    systemctl start keepalived.service</p><p>​    然后通过虚拟 IP 访问，虚拟 IP 在 keepalived 的配置文件中的虚拟ip。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">A=`ps -C nginx --no-header | wc -l`</span><br><span class="line">if [ $A -eq 0 ]; then</span><br><span class="line">/usr/local/nginx/sbin/nginx</span><br><span class="line">  sleep 2</span><br><span class="line">  if [ `ps -C nginx --no-header | wc -l` -eq 0 ]; then</span><br><span class="line">  killall keepalived</span><br><span class="line">  fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">! <span class="attribute">Configuration</span> File for keepalived</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局定义</span></span><br><span class="line">global_defs &#123;</span><br><span class="line">   <span class="section">notification_email</span> &#123;</span><br><span class="line">     acassen@firewall.<span class="attribute">loc</span></span><br><span class="line">     failover<span class="variable">@firewall</span>.loc</span><br><span class="line">     sysadmin<span class="variable">@firewall</span>.loc</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from Alexandre.Cassen<span class="variable">@firewall</span>.loc</span><br><span class="line">   smtp_server <span class="number">192.168.200.1</span></span><br><span class="line">   smtp_connect_timeout <span class="number">30</span></span><br><span class="line">   router_id LVS_DEVEL   <span class="comment"># 服务器的名字，这个就是全局的唯一值，在 /etc/hosts 中，也可以随便</span></span><br><span class="line">   vrrp_skip_check_adv_addr</span><br><span class="line">   vrrp_strict</span><br><span class="line">   vrrp_garp_interval <span class="number">0</span></span><br><span class="line">   vrrp_gna_interval <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 虚拟 ip 配置</span></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    <span class="attribute">state</span> MASTER  <span class="comment"># 备份服务器上将这里改为 BACKUP</span></span><br><span class="line">    interface eth0 <span class="comment"># 网卡，</span></span><br><span class="line">    virtual_router_id <span class="number">51</span>  <span class="comment"># 主、备机器的 virtual_router_id 必须相同，唯一标识</span></span><br><span class="line">    priority <span class="number">100</span>  <span class="comment"># 主、备机器取不同的优先级，主机值较大，备份机器较小</span></span><br><span class="line">    advert_int <span class="number">1</span> <span class="comment"># 时间间隔，每隔多少秒发送一个心跳</span></span><br><span class="line">    authentication &#123;  <span class="comment"># 权限校验方式，用的是 pass，密码是 1111</span></span><br><span class="line">        <span class="attribute">auth_type</span> PASS</span><br><span class="line">        auth_pass <span class="number">1111</span></span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;  <span class="comment"># VRRP H 虚拟地址，也可以绑定一个ip</span></span><br><span class="line">        192.168.200.16</span><br><span class="line">        192.168.200.17</span><br><span class="line">        192.168.200.18</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果使用 shell 脚本的方式检测，取消注释如下配置</span></span><br><span class="line"><span class="attribute">vrrp_script</span> chk_http_port &#123;</span><br><span class="line">  <span class="attribute">script</span> <span class="string">&quot;/usr/local/src/nginx_check.sh&quot;</span>  <span class="comment"># 上文中的 shell 路径</span></span><br><span class="line">  interval <span class="number">2</span>  <span class="comment"># 检测脚本执行的间隔</span></span><br><span class="line">  weight <span class="number">2</span>  <span class="comment"># 权重，比如 -20 当脚本条件成立，当前主机的权重降低 20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 如果不使用上面的这个 vrrp_script 就使用下面的配置</span></span><br><span class="line"></span><br><span class="line">virtual_server <span class="number">192.168.200.100</span> <span class="number">443</span> &#123;</span><br><span class="line">    <span class="attribute">delay_loop</span> <span class="number">6</span></span><br><span class="line">    lb_algo rr</span><br><span class="line">    lb_kind NAT</span><br><span class="line">    persistence_timeout <span class="number">50</span></span><br><span class="line">    protocol TCP</span><br><span class="line"></span><br><span class="line">    real_server <span class="number">192.168.201.100</span> <span class="number">443</span> &#123;</span><br><span class="line">        <span class="attribute">weight</span> <span class="number">1</span></span><br><span class="line">        SSL_GET &#123;</span><br><span class="line">            <span class="section">url</span> &#123;</span><br><span class="line">              <span class="attribute">path</span> /</span><br><span class="line">              digest ff20ad2481f97b1754ef3e12ecd3a9cc</span><br><span class="line">            &#125;</span><br><span class="line">            url &#123;</span><br><span class="line">              <span class="attribute">path</span> /mrtg/</span><br><span class="line">              digest 9b3a0c85a887a256d6939da88aabd8cd</span><br><span class="line">            &#125;</span><br><span class="line">            connect_timeout <span class="number">3</span></span><br><span class="line">            nb_get_retry <span class="number">3</span></span><br><span class="line">            delay_before_retry <span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual_server <span class="number">10.10.10.2</span> <span class="number">1358</span> &#123;</span><br><span class="line">    <span class="attribute">delay_loop</span> <span class="number">6</span></span><br><span class="line">    lb_algo rr</span><br><span class="line">    lb_kind NAT</span><br><span class="line">    persistence_timeout <span class="number">50</span></span><br><span class="line">    protocol TCP</span><br><span class="line"></span><br><span class="line">    sorry_server <span class="number">192.168.200.200</span> <span class="number">1358</span></span><br><span class="line"></span><br><span class="line">    real_server <span class="number">192.168.200.2</span> <span class="number">1358</span> &#123;</span><br><span class="line">        <span class="attribute">weight</span> <span class="number">1</span></span><br><span class="line">        HTTP_GET &#123;</span><br><span class="line">            <span class="section">url</span> &#123;</span><br><span class="line">              <span class="attribute">path</span> /testurl/test.jsp</span><br><span class="line">              digest 640205b7b0fc66c1ea91c463fac6334d</span><br><span class="line">            &#125;</span><br><span class="line">            url &#123;</span><br><span class="line">              <span class="attribute">path</span> /testurl2/test.jsp</span><br><span class="line">              digest 640205b7b0fc66c1ea91c463fac6334d</span><br><span class="line">            &#125;</span><br><span class="line">            url &#123;</span><br><span class="line">              <span class="attribute">path</span> /testurl3/test.jsp</span><br><span class="line">              digest 640205b7b0fc66c1ea91c463fac6334d</span><br><span class="line">            &#125;</span><br><span class="line">            connect_timeout <span class="number">3</span></span><br><span class="line">            nb_get_retry <span class="number">3</span></span><br><span class="line">            delay_before_retry <span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    real_server <span class="number">192.168.200.3</span> <span class="number">1358</span> &#123;</span><br><span class="line">        <span class="attribute">weight</span> <span class="number">1</span></span><br><span class="line">        HTTP_GET &#123;</span><br><span class="line">            <span class="section">url</span> &#123;</span><br><span class="line">              <span class="attribute">path</span> /testurl/test.jsp</span><br><span class="line">              digest 640205b7b0fc66c1ea91c463fac6334c</span><br><span class="line">            &#125;</span><br><span class="line">            url &#123;</span><br><span class="line">              <span class="attribute">path</span> /testurl2/test.jsp</span><br><span class="line">              digest 640205b7b0fc66c1ea91c463fac6334c</span><br><span class="line">            &#125;</span><br><span class="line">            connect_timeout <span class="number">3</span></span><br><span class="line">            nb_get_retry <span class="number">3</span></span><br><span class="line">            delay_before_retry <span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual_server <span class="number">10.10.10.3</span> <span class="number">1358</span> &#123;</span><br><span class="line">    <span class="attribute">delay_loop</span> <span class="number">3</span></span><br><span class="line">    lb_algo rr</span><br><span class="line">    lb_kind NAT</span><br><span class="line">    persistence_timeout <span class="number">50</span></span><br><span class="line">    protocol TCP</span><br><span class="line"></span><br><span class="line">    real_server <span class="number">192.168.200.4</span> <span class="number">1358</span> &#123;</span><br><span class="line">        <span class="attribute">weight</span> <span class="number">1</span></span><br><span class="line">        HTTP_GET &#123;</span><br><span class="line">            <span class="section">url</span> &#123;</span><br><span class="line">              <span class="attribute">path</span> /testurl/test.jsp</span><br><span class="line">              digest 640205b7b0fc66c1ea91c463fac6334d</span><br><span class="line">            &#125;</span><br><span class="line">            url &#123;</span><br><span class="line">              <span class="attribute">path</span> /testurl2/test.jsp</span><br><span class="line">              digest 640205b7b0fc66c1ea91c463fac6334d</span><br><span class="line">            &#125;</span><br><span class="line">            url &#123;</span><br><span class="line">              <span class="attribute">path</span> /testurl3/test.jsp</span><br><span class="line">              digest 640205b7b0fc66c1ea91c463fac6334d</span><br><span class="line">            &#125;</span><br><span class="line">            connect_timeout <span class="number">3</span></span><br><span class="line">            nb_get_retry <span class="number">3</span></span><br><span class="line">            delay_before_retry <span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    real_server <span class="number">192.168.200.5</span> <span class="number">1358</span> &#123;</span><br><span class="line">        <span class="attribute">weight</span> <span class="number">1</span></span><br><span class="line">        HTTP_GET &#123;</span><br><span class="line">            <span class="section">url</span> &#123;</span><br><span class="line">              <span class="attribute">path</span> /testurl/test.jsp</span><br><span class="line">              digest 640205b7b0fc66c1ea91c463fac6334d</span><br><span class="line">            &#125;</span><br><span class="line">            url &#123;</span><br><span class="line">              <span class="attribute">path</span> /testurl2/test.jsp</span><br><span class="line">              digest 640205b7b0fc66c1ea91c463fac6334d</span><br><span class="line">            &#125;</span><br><span class="line">            url &#123;</span><br><span class="line">              <span class="attribute">path</span> /testurl3/test.jsp</span><br><span class="line">              digest 640205b7b0fc66c1ea91c463fac6334d</span><br><span class="line">            &#125;</span><br><span class="line">            connect_timeout <span class="number">3</span></span><br><span class="line">            nb_get_retry <span class="number">3</span></span><br><span class="line">            delay_before_retry <span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EOF</p>]]></content>
      
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx基础知识</title>
      <link href="/2020/07/18/Nginx%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2020/07/18/Nginx%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装 pcre</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">下载</span><br><span class="line">解压</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>更新依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel</span><br></pre></td></tr></table></figure><p>安装 nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">下载</span><br><span class="line">解压</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>CentOS7 的默认防火墙改成了 firewall，不再使用 iptables 为默认防火墙了</p><p>安装好 nginx 后需要打开 80 端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --list-all #查看开发的端口号</span><br><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent # 开发 80 端口 tcp 协议</span><br><span class="line"># --zone #作用域</span><br><span class="line"># --add-port=80/tcp #添加端口，格式：端口/通讯协议</span><br><span class="line"># --permanent #永久生效，没有此参数重启后失效</span><br></pre></td></tr></table></figure><p>firewall 相关命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld.service # 停止</span><br><span class="line">systemctl start firewalld.service # 启动</span><br><span class="line">systemctl status Firewalld.service # 状态</span><br><span class="line">systemctl restart firewalld.service # 重启</span><br></pre></td></tr></table></figure><h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><p>查看版本号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-7 sbin]# ./nginx -v</span><br><span class="line">nginx version: nginx/1.19.1</span><br></pre></td></tr></table></figure><p>停止：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-7 sbin]# ./nginx -s stop</span><br><span class="line">[root@centos-7 sbin]# ps aux | grep nginx</span><br><span class="line">root     16465  0.0  0.0 112824   980 pts/0    S+   21:31   0:00 grep --color=auto nginx</span><br></pre></td></tr></table></figure><p>启动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-7 sbin]# ./nginx</span><br><span class="line">[root@centos-7 sbin]# ps aux | grep nginx</span><br><span class="line">root     16475  0.0  0.0  20568   620 ?        Ss   21:32   0:00 nginx: master process ./nginx</span><br><span class="line">nobody   16476  0.0  0.0  23092  1380 ?        S    21:32   0:00 nginx: worker process</span><br><span class="line">root     16478  0.0  0.0 112824   976 pts/0    S+   21:32   0:00 grep --color=auto nginx</span><br></pre></td></tr></table></figure><p>重加载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-7 sbin]# ./nginx -s reload</span><br><span class="line">[root@centos-7 sbin]# ps aux | grep nginx</span><br><span class="line">root     16475  0.0  0.0  20708  1344 ?        Ss   21:32   0:00 nginx: master process ./nginx</span><br><span class="line">nobody   16480  0.0  0.0  23208  1492 ?        S    21:33   0:00 nginx: worker process</span><br></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>一般在<code>/usr/local/nginx/conf</code>下。</p><p>注意：如果在 nginx 安装过程中指定了<code>--prefix=/path/</code>的情况下，这个目录就在指定的 path 下。</p><p>注意：yum 安装的可能不在这个目录下。</p><p>配置文件分为 3 个部分：</p><ul><li><p>全局块（对应下文中配置文件的 1-10 行）</p><p>从配置文件开始到 events 块之间的内容，主要会设置一些影响 nginx 服务器整体运行的配置指令。</p><p>主要包括配置运行 nginx 服务器的用户(组)、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型、配置文件的引入等。</p><p>比如：<code>worker_processes 1;</code>是 nginx 服务器并发处理服务的关键配置，值越大，可以支持的并发处理量也越多，但是会受到硬件、软件等设备的制约。（和 CPU 核心数量一致比较合理？）</p></li><li><p>events 块</p><p>主要影响 nginx 服务器与用户的网络连接。</p><p>比如：<code>worker_connections  1024;</code> 支持的最大连接数。</p></li><li><p>http 块</p><p>配置中最频繁的步伐，代理、缓存、日志定义绝大多数功能和第三方模块的配置都在这里</p><p>注意：http 块也可以包括 http 全局块、server 块。</p></li><li><ul><li>http 全局块（下文中 17-33 行）</li><li>包括文件引入、mime-type 定义、日志自定义、连接超时时间、单链接请求数上限等。</li></ul></li><li><ul><li><p>server 块</p></li><li><p>和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。</p></li><li><p>每个 http 块可以包括多个 server 块，每个 server 块就相当于一个虚拟主机。</p></li><li><p>每个 server 块也分为全局 server 块以及可以同时包含多个 location 块。</p></li><li><p>全局 server 块（下文 35-41 行）最常见的就是配置本虚拟主机的监听配置和本虚拟主机的名称或 IP 配置。</p></li><li><p>location 块，一个 server 块可以包含多个 location 块，主要是基于 nginx 服务器接收到的请求字符串(例如 server_name/uri-string)，对虚拟主机名称（也可以是IP别名）之外的字符串（例如前面的/uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行。</p></li></ul></li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">    <span class="comment">#                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">    <span class="comment">#                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  logs/access.log  main;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#keepalive_timeout  0;</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">        <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">        <span class="comment">#    proxy_pass   http://127.0.0.1;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">        <span class="comment">#    root           html;</span></span><br><span class="line">        <span class="comment">#    fastcgi_pass   127.0.0.1:9000;</span></span><br><span class="line">        <span class="comment">#    fastcgi_index  index.php;</span></span><br><span class="line">        <span class="comment">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span></span><br><span class="line">        <span class="comment">#    include        fastcgi_params;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># deny access to .htaccess files, if Apache&#x27;s document root</span></span><br><span class="line">        <span class="comment"># concurs with nginx&#x27;s one</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location ~ /\.ht &#123;</span></span><br><span class="line">        <span class="comment">#    deny  all;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># another virtual host using mix of IP-, name-, and port-based configuration</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#server &#123;</span></span><br><span class="line">    <span class="comment">#    listen       8000;</span></span><br><span class="line">    <span class="comment">#    listen       somename:8080;</span></span><br><span class="line">    <span class="comment">#    server_name  somename  alias  another.alias;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    location / &#123;</span></span><br><span class="line">    <span class="comment">#        root   html;</span></span><br><span class="line">    <span class="comment">#        index  index.html index.htm;</span></span><br><span class="line">    <span class="comment">#    &#125;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># HTTPS server</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#server &#123;</span></span><br><span class="line">    <span class="comment">#    listen       443 ssl;</span></span><br><span class="line">    <span class="comment">#    server_name  localhost;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    ssl_certificate      cert.pem;</span></span><br><span class="line">    <span class="comment">#    ssl_certificate_key  cert.key;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    ssl_session_cache    shared:SSL:1m;</span></span><br><span class="line">    <span class="comment">#    ssl_session_timeout  5m;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    ssl_ciphers  HIGH:!aNULL:!MD5;</span></span><br><span class="line">    <span class="comment">#    ssl_prefer_server_ciphers  on;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    location / &#123;</span></span><br><span class="line">    <span class="comment">#        root   html;</span></span><br><span class="line">    <span class="comment">#        index  index.html index.htm;</span></span><br><span class="line">    <span class="comment">#    &#125;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NGINX-原理"><a href="#NGINX-原理" class="headerlink" title="NGINX 原理"></a>NGINX 原理</h2><h3 id="master-amp-worker"><a href="#master-amp-worker" class="headerlink" title="master &amp; worker"></a>master &amp; worker</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/556124/1595064451918-54dc0056-5445-4e4f-8e83-30576f79657f.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-7 keepalived]# ps aux | grep nginx</span><br><span class="line">root     11262  0.0  0.0  20612  1424 ?        Ss   14:14   0:00 nginx: master process ./nginx</span><br><span class="line">nobody   18694  0.0  0.0  23124  1664 ?        S    16:27   0:00 nginx: worker process</span><br></pre></td></tr></table></figure><h3 id="worker-是如何工作的？"><a href="#worker-是如何工作的？" class="headerlink" title="worker 是如何工作的？"></a>worker 是如何工作的？</h3><p>争抢。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/556124/1595064458993-3da280b1-598b-4e94-ad45-53817501c635.png" alt="image.png"></p><h3 id="一个-master-和多个-worker-的好处？"><a href="#一个-master-和多个-worker-的好处？" class="headerlink" title="一个 master 和多个 worker 的好处？"></a>一个 master 和多个 worker 的好处？</h3><p>1、可以使用 nginx -s reload 热部署</p><p>当使用了热部署后，之前有 client 请求的 worker 还是按照之前的规则进行处理请求，空闲的 worker 就可以根据新的配置来进行处理 client 的请求。</p><p>2、对于每个worker进程来说，独立的进程，不需要加锁，所以省掉了锁带来的开销，同时在编程以及问题查找时，也会方便很多。</p><p>3、采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，master进程则很快启动新的worker进程。</p><p>当然，worker进程的异常退出，肯定是程序有bug了，异常退出，会导致当前worker上的所有请求失败，不过不会影响到所有请求，所以降低了风险。</p><h3 id="设置多少个-worker-合适？"><a href="#设置多少个-worker-合适？" class="headerlink" title="设置多少个 worker 合适？"></a>设置多少个 worker 合适？</h3><p>Nginx同redis类似都采用了io多路复用机制，每个worker都是一个独立的进程，但每个进程里只有一个主线程，通过异步非阻塞的方式来处理请求，即使是 千上万个请求也不在话下。</p><p>每个worker的线程可以把一个cpu的性能发挥到极致。所以<strong>worker数和服务器的cpu数相等是最为适宜的</strong>。设少了会浪费cpu，设多了会造成cpu频繁切换上下文带来的损耗。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置worker数量</span></span><br><span class="line">worker_processes 4</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">work绑定cpu(4work绑定4cpu)</span></span><br><span class="line">worker_cpu_affinity 0001 0010 0100 1000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">work绑定cpu (4work绑定8cpu中的4个)</span></span><br><span class="line">worker_cpu_affinity 0000001 00000010 00000100 00001000</span><br></pre></td></tr></table></figure><h3 id="连接数-worker-connection"><a href="#连接数-worker-connection" class="headerlink" title="连接数 worker_connection"></a>连接数 worker_connection</h3><p>这个值是表示每个worker进程所能建立连接的最大值。</p><p>所以，一个nginx 能建立的最大连接数，应该是<code>worker.connections * worker processes</code>。</p><p>当然，这里说的是最大连接数，对于HTTP 请求本地资源来说，能够支持的最大并发数量是<code>worker.connections * worker processes</code>。</p><p>如果是支持http1.1的浏览器每次访问要占两个连接，所以普通的静态访问最大并发数是<code>worker.connections * worker.processes / 2</code>。</p><p>而如果是HTTP作为反向代理来说，最大并发数量应该是<code>worker.connections * worker_proceses/4</code>。</p><p>因为作为反向代理服务器，每个并发会建立与客户端的连接和与后端服务的连接，会占用两个连接。</p><p><strong>发送请求，占用了woker的几个连接数?</strong></p><p>2 个或者 4 个。</p><p>比如请求的是静态资源，一来一回是两个连接数。</p><p>如果访问别的资源比如说是 tomcat，则 worker 和 tomcat 也有一来一回两个连接，所以是 4 个连接数。</p><p><strong>nginx有一个master,有四个woker,每个woker支持最大的连接数1024,支持的最大并发数是多少?</strong></p><p>普通的静态访问最大并发数是: worker connections * worker processes/2</p><p>而如果是HTTP作为反向代理来说，最大并发数量应该是worker connections * worker processes/4</p><p>EOF</p>]]></content>
      
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网站伸缩性架构-永无止境</title>
      <link href="/2020/06/09/%E7%BD%91%E7%AB%99%E4%BC%B8%E7%BC%A9%E6%80%A7%E6%9E%B6%E6%9E%84-%E6%B0%B8%E6%97%A0%E6%AD%A2%E5%A2%83/"/>
      <url>/2020/06/09/%E7%BD%91%E7%AB%99%E4%BC%B8%E7%BC%A9%E6%80%A7%E6%9E%B6%E6%9E%84-%E6%B0%B8%E6%97%A0%E6%AD%A2%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h1 id="6、伸缩性-永无止境"><a href="#6、伸缩性-永无止境" class="headerlink" title="6、伸缩性-永无止境"></a>6、伸缩性-永无止境</h1><h2 id="架构的伸缩性设计"><a href="#架构的伸缩性设计" class="headerlink" title="架构的伸缩性设计"></a>架构的伸缩性设计</h2><h3 id="不同功能进行物理分离实现伸缩"><a href="#不同功能进行物理分离实现伸缩" class="headerlink" title="不同功能进行物理分离实现伸缩"></a>不同功能进行物理分离实现伸缩</h3><p>纵向分离（分层后分离）<br>横向分离（业务分割后分离）<br><img src="https://img-blog.csdnimg.cn/20200609210649909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhbm9pX2Fob2o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200609210656214.png" alt="在这里插入图片描述"></p><h3 id="单一功能通过集群规模实现伸缩"><a href="#单一功能通过集群规模实现伸缩" class="headerlink" title="单一功能通过集群规模实现伸缩"></a>单一功能通过集群规模实现伸缩</h3><p>当一头牛拉不动车的时候，不要去寻找一头更强壮的牛，而是用两头牛来拉车。</p><h2 id="应用服务器集群的伸缩性设计"><a href="#应用服务器集群的伸缩性设计" class="headerlink" title="应用服务器集群的伸缩性设计"></a>应用服务器集群的伸缩性设计</h2><h3 id="HTTP-重定向负载均衡"><a href="#HTTP-重定向负载均衡" class="headerlink" title="HTTP 重定向负载均衡"></a>HTTP 重定向负载均衡</h3><p><img src="https://img-blog.csdnimg.cn/20200609210707395.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhbm9pX2Fob2o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>根据请求，计算一个服务器地址，利用 HTTP 302 重定向到服务器地址。<br>优点：<br>比较简单。<br>缺点：<br>浏览器需要两次请求服务器才能完成一次访问，性能较差；<br>重定向服务器自身的处理能力可能成为性能瓶颈；<br>302 重定向可能被搜索引擎判断为 SEO 作弊，降低搜索排名。</p><h3 id="DNS-域名解析负载均衡"><a href="#DNS-域名解析负载均衡" class="headerlink" title="DNS 域名解析负载均衡"></a>DNS 域名解析负载均衡</h3><p><img src="https://img-blog.csdnimg.cn/20200609210715772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhbm9pX2Fob2o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在 DNS 服务器中配置多个 A 记录，如： <a href="http://www.xxx.com/">www.xxx.com</a> IN A 114.100.80.1 和 <a href="http://www.xxx.com/">www.xxx.com</a> IN A 114.100.80.2。每次域名解析请求都会根据负载均衡算法计算一个不同的 IP 地址返回。<br>优点：<br>负载均衡工作转交给 DNS，省去了一些工作内容。<br>DNS 还支持基于地理位置的域名解析。<br>缺点：<br>DNS 多级解析，每一级 DNS 都可能缓存 A 记录，当某台服务器下线后，即使修改了 A 记录，也得等一会才能生效。</p><p>可以部分使用 DNS 域名解析，解析作为第一级负载均衡手段，即解析得到的一组服务器并不是真正提供 Web 服务的物理服务器，而是同样提供负载均衡的内部服务器。</p><h3 id="反向代理负载均衡"><a href="#反向代理负载均衡" class="headerlink" title="反向代理负载均衡"></a>反向代理负载均衡</h3><p><img src="https://img-blog.csdnimg.cn/20200609210723143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhbm9pX2Fob2o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>反向代理服务器转发请求在 HTTP 协议层面，因此也称为 <strong>应用层负载均衡。</strong><br>优点：<br>和反向代理服务器功能集成在一起，部署简单。<br>缺点：<br>反向代理服务器是所有请求和响应的中转站，性能可能会成为瓶颈。</p><h3 id="IP-负载均衡"><a href="#IP-负载均衡" class="headerlink" title="IP 负载均衡"></a>IP 负载均衡</h3><p><img src="https://img-blog.csdnimg.cn/20200609210730677.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhbm9pX2Fob2o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>SNAT 源地址转换！<br>优点：<br>IP 负载均衡在内核进程中完成数据分发，比反向代理负载均衡（在应用层分发）有更好的性能；<br>缺点：<br>所有请求和响应都要经过负载均衡服务器，集群最大相应数据屯独立受制于负载均衡服务器网卡带宽；</p><h3 id="数据链路负载均衡"><a href="#数据链路负载均衡" class="headerlink" title="数据链路负载均衡"></a>数据链路负载均衡</h3><p><img src="https://img-blog.csdnimg.cn/2020060921073852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhbm9pX2Fob2o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在通信协议的数据链路层修改 mac 地址进行负载均衡。<br>这种负载均衡方式又称作直接路由方式（DR）。<br>也称为三角模式。<br>在 Linux 上比较好的开源产品是 LVS（Linux Virtual Server）</p><h3 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h3><p>负载均衡服务器的实现可以分为 2 个部分：<br>1、根据负载均衡算法和 Web 服务器列表得到集群中一台 Web 服务器的地址。<br>2、将请求数据发送到该地址对应的 Web 服务器上。</p><h4 id="轮询（Round-Robin，RR）"><a href="#轮询（Round-Robin，RR）" class="headerlink" title="轮询（Round Robin，RR）"></a>轮询（Round Robin，RR）</h4><p>适用于所有服务器硬件都相同的场景。</p><h4 id="加权轮询（Weighted-Round-Robin，WRR）"><a href="#加权轮询（Weighted-Round-Robin，WRR）" class="headerlink" title="加权轮询（Weighted Round Robin，WRR）"></a>加权轮询（Weighted Round Robin，WRR）</h4><p>根据硬件性能，高性能服务器能分配更多请求。</p><h4 id="随机（Random）"><a href="#随机（Random）" class="headerlink" title="随机（Random）"></a>随机（Random）</h4><p>简单实用，随机数本身就很均衡。<br>也可以改一改成为加权随机法。</p><h4 id="最少连接（Least-Connections）"><a href="#最少连接（Least-Connections）" class="headerlink" title="最少连接（Least Connections）"></a>最少连接（Least Connections）</h4><p>记录每个服务器正在处理的连接数（请求数），新请求发给连接数最少的那个。<br>同样可以实现个加权最少连接。</p><h4 id="源地址散列（Source-Hashing）"><a href="#源地址散列（Source-Hashing）" class="headerlink" title="源地址散列（Source Hashing）"></a>源地址散列（Source Hashing）</h4><p>一个 IP 地址进行 Hash 得到应用服务器地址，这样来自同一个 IP 地址的请求总在同一个服务器上处理，该请求的上下文信息可以存储在这台服务器上，在一个会话周期内复用，从而实现会话粘滞。</p><h2 id="分布式缓存集群的伸缩性设计"><a href="#分布式缓存集群的伸缩性设计" class="headerlink" title="分布式缓存集群的伸缩性设计"></a>分布式缓存集群的伸缩性设计</h2><h3 id="Memcached-分布式缓存集群的访问模型"><a href="#Memcached-分布式缓存集群的访问模型" class="headerlink" title="Memcached 分布式缓存集群的访问模型"></a>Memcached 分布式缓存集群的访问模型</h3><p>set(key, data)、get(key)<br>路由根据 key 计算对应应该从哪台服务器写缓存，从哪台服务器读缓存。</p><h3 id="Memcached-分布式缓存集群的伸缩性挑战"><a href="#Memcached-分布式缓存集群的伸缩性挑战" class="headerlink" title="Memcached 分布式缓存集群的伸缩性挑战"></a>Memcached 分布式缓存集群的伸缩性挑战</h3><p>对于集群的管理，路由算法至关重要，决定着究竟该访问集群中的哪台服务器。<br>简单的路由算法就是余数 Hash。<br>对于余数 Hash，当集群需要扩容的时候，事情就比较糟糕了。<br>假设 3 台缓存服务器需要扩容到 4 台，更改服务器列表，依然使用余数 Hash，用 4/key 的 Hash 值大约有 75%(3/4) 不能正确命中，随着服务器集群规模的增大，这个比例直线上升！<br>当 100 台集群中增加一台，不能命中的概率是 99%( n/(n+1) )。</p><p>大部分的业务数据读操作请求事实上是通过缓存获取的，只有少量的操作请求会访问数据库。<br>当大量的缓存出现不能命中时，对于数据库的压力就很大了，甚至宕机。</p><p>一种解决方法就是在网站访问了最少的时候进行缓存服务器集群扩容，然后通过模拟请求的方法来预热缓存。<br>另一种方法就是通过下面的算法了！</p><h3 id="分布式缓存的一致性-Hash-算法"><a href="#分布式缓存的一致性-Hash-算法" class="headerlink" title="分布式缓存的一致性 Hash 算法"></a>分布式缓存的一致性 Hash 算法</h3><p>一致性 Hash 算法通过一个叫做一致性 Hash 环的数据结构实现 KEY 到缓存服务器的 Hash 映射。<br>![image.png](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAyMC9wbmcvNTU2MTI0LzE1OTE1MTM2NzA1OTAtZDU0NmMyMzEtOTMwZS00OTNjLWFkZGItNDc1ZTQ2M2ZiMTY1LnBuZw?x-oss-process=image/format,png#align=left&amp;display=inline&amp;height=231&amp;margin=[object">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAyMC9wbmcvNTU2MTI0LzE1OTE1MTM2NzA1OTAtZDU0NmMyMzEtOTMwZS00OTNjLWFkZGItNDc1ZTQ2M2ZiMTY1LnBuZw?x-oss-process=image/format,png#align=left&amp;display=inline&amp;height=231&amp;margin=[object</a> Object]&amp;name=image.png&amp;originHeight=922&amp;originWidth=918&amp;size=115943&amp;status=done&amp;style=none&amp;width=230)<br>具体算法过程为：<br>先构造一个长度为 2^32 的整数环，这个环被称为一致性 Hash 环。<br>根据节点名称的 Hash 值（其分布范围为[0, 2^32-1]）将缓存服务器节点放置在这个 Hash 环上。<br>然后根据需要缓存的数据 KEY 的值计算得到其 Hash 值（分布范围同上）。<br>然后在 Hash 环上顺时针找举例这个 KEY 的 Hash 值最近的缓存服务器节点，完成 KEY 服务器的 Hash 映射查找。</p><p>当缓存服务器集群需要扩容的时候，只需要将新加入的节点名称（NODE3）的 Hash 值放入一致性 Hash 环中，由于 KEY 是顺时针查找举例其最近的节点，因此新加入的节点只影响整个环中的一小段。<br>![image.png](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAyMC9wbmcvNTU2MTI0LzE1OTE1MTQyNzYxODgtZTdmNTE2OWItYmExYi00ODA5LWIxZmEtZmM3ZmExODgxZDI0LnBuZw?x-oss-process=image/format,png#align=left&amp;display=inline&amp;height=251&amp;margin=[object">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAyMC9wbmcvNTU2MTI0LzE1OTE1MTQyNzYxODgtZTdmNTE2OWItYmExYi00ODA5LWIxZmEtZmM3ZmExODgxZDI0LnBuZw?x-oss-process=image/format,png#align=left&amp;display=inline&amp;height=251&amp;margin=[object</a> Object]&amp;name=image.png&amp;originHeight=1002&amp;originWidth=1026&amp;size=138950&amp;status=done&amp;style=none&amp;width=257)<br>3台 -&gt; 4台扩容时候的命中率是 75%，远高于余数 Hash 的 25%。</p><p>在具体应用中，这个长度为 2^32 的一致性 Hash 环通常使用二叉查找树实现，Hash 查找过程实际上是在二叉查找树中查找<strong>不小于查找数的最小数值，</strong>这个数的最左叶子节点和最右叶子节点连接构成环。</p><p>但是！这个过程还存在一些小问题！</p><p>新加入的节点 NODE3 只影响了原来的节点 NODE1，也就是说一部分原来需要访问 NODE1 的缓存数据现在需要访问 NODE3（概率上市 50%）。<br>但是原来的节点 NODE0 和 NODE2 不受影响，这就意味着 NODE0 和 NODE2 缓存数据量和负载压力是 NODE1 和 NODE3 的两倍。<br>如果这 4 台机器性能是一样的，那么这种结果不是想要的。</p><p>怎么办？</p><p>计算机的任何问题都可以通过增加一个虚拟层来解决！<br>计算机硬件、计算机网络、计算机软件都莫过于此。<br>计算机网络7层，每一层可以看做是下一层的虚拟层；计算机操作系统可以看做是硬件的虚拟层；JVM 可以看作是操作系统的虚拟层；分层软件架构事实上也是如此。</p><p>将每台物理缓存服务器虚拟为一组虚拟缓存服务器，将虚拟服务器的 Hash 值放置在 Hash 环上，KEY 在环上先找到虚拟服务器节点，再得到物理服务器信息。</p><p>这样在新加入物理服务器节点时，是将一组虚拟节点加入环中，如果虚拟节点的树木足够多，这组虚拟节点将会影响同样多树木的已经在换上存在的虚拟节点，这些已经存在的虚拟节点又对应不同的物理节点。<br>最终结果是：新加入一台缓存服务器，将会较为均匀的影响原来及群众已经存在的所有服务器，也就是说分摊原有缓存服务器集群中所有服务器的一小部分负载。</p><p>![image.png](<a href="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAyMC9wbmcvNTU2MTI0LzE1OTE1MTU0MDY5MzktNTExZmIwNmMtODIxYS00M2NjLTk3NWEtY2RlZmU3MWJiZDhmLnBuZw?x-oss-process=image/format,png#align=left&amp;display=inline&amp;height=253&amp;margin=[object">https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlLzAvMjAyMC9wbmcvNTU2MTI0LzE1OTE1MTU0MDY5MzktNTExZmIwNmMtODIxYS00M2NjLTk3NWEtY2RlZmU3MWJiZDhmLnBuZw?x-oss-process=image/format,png#align=left&amp;display=inline&amp;height=253&amp;margin=[object</a> Object]&amp;name=image.png&amp;originHeight=1010&amp;originWidth=1370&amp;size=112263&amp;status=done&amp;style=none&amp;width=343)<br>如上图，加入 NODE3 对应的一组虚拟节点为 V30 V32 V32，加入到一致性 Hash 环上后，影响 V01 V12 V22<br>这三个被影响的虚拟节点对应 NODE0 NODE1 NODE2 三个物理节点。<br>最终加入一个节点，影响三个物理节点，理想情况下，每个物理节点收到影响的缓存数据量是 1/4 (x/ (x+n))，N 为原物理节点数，X 为新加入物理节点数。也就是及群众已经被缓存的数据有 75% 可以被命中。</p><p>理论上虚拟节点数越多，物理节点之间的负载就越均衡。<br>但是太多影响性能，太少负载不均衡，一般来说经验是 150，根据集群规模和均衡的精度需求，具体对待。</p><h2 id="数据存储服务器集群的伸缩性设计"><a href="#数据存储服务器集群的伸缩性设计" class="headerlink" title="数据存储服务器集群的伸缩性设计"></a>数据存储服务器集群的伸缩性设计</h2><h3 id="关系数据库集群的伸缩性设计"><a href="#关系数据库集群的伸缩性设计" class="headerlink" title="关系数据库集群的伸缩性设计"></a>关系数据库集群的伸缩性设计</h3><p>分库分表，质数。</p><h3 id="NoSQL-数据库的伸缩性设计"><a href="#NoSQL-数据库的伸缩性设计" class="headerlink" title="NoSQL 数据库的伸缩性设计"></a>NoSQL 数据库的伸缩性设计</h3><p>NoSQL 更关注高可用性和可伸缩性。<br>舍弃了以关系代数为基础的结构化查询语言（SQL）和事务一致性保证（ACID）。</p><hr><p>EOF！</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高可用网站架构-万无一失</title>
      <link href="/2020/06/09/%E9%AB%98%E5%8F%AF%E7%94%A8%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84-%E4%B8%87%E6%97%A0%E4%B8%80%E5%A4%B1/"/>
      <url>/2020/06/09/%E9%AB%98%E5%8F%AF%E7%94%A8%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84-%E4%B8%87%E6%97%A0%E4%B8%80%E5%A4%B1/</url>
      
        <content type="html"><![CDATA[<h1 id="高可用-万无一失"><a href="#高可用-万无一失" class="headerlink" title="高可用-万无一失"></a>高可用-万无一失</h1><p>廉价的服务器硬件故障是常态，网站的高可用架构设计的主要目的就是保证服务器硬件故障时服务依然可用、数据依然保存并能够访问。<br />实现上述高可用方案的主要数据和服务的手段是冗余备份和失效转移。<br /><br><br />应用层：应对高并发，负载均衡，心跳检测监控，不可用时候剔除。<br />服务层：通过集群方式实现高可用，被应用层通过分布式调用框架访问，分布式调用框架会在客户端程序中实现软件负载均衡、心跳检测。<br />数据层：同步复制，冗余备份。<br /></p><h2 id="高可用的应用"><a href="#高可用的应用" class="headerlink" title="高可用的应用"></a>高可用的应用</h2><p>健身房小姐姐填表单的栗子。<br /><strong>无状态性！！！</strong><br /><br><br /><strong>可以直接通过负载均衡实现无状态服务的负载均衡。</strong><br /><br><br /><strong>应用服务器集群的 Session 管理</strong><br />事实上，业务总是有状态的，在交易类的电商网站需要有购物车记录的购买信息，用户每次购买请求都是向购物车中增加商品；在社交类网站中，需要记录用户的当前登录状态、最新发布的消息和好友列表等，每次刷新页面都需要更新这些信息。</p><ol><li>Session 复制</li></ol><p>应用服务器开启 Web 容器的 Session 复制功能，在集群中的几台服务器之间同步 Session 对象，每台服务器保存所有用户的 Session 信息。<br />当集群规模较大时候，大量的 Session 复制通信占用服务器的网络资源较大，甚至有内存不够存 Session 情况。</p><ol start="2"><li>Session 绑定</li></ol><p>Session 绑定可以利用负载均衡的源地址 Hash 算法实现，总是将同一个 IP 的请求分发到同一台服务器上，也可以根据 Cookie 信息将同一个用户的请求分发到同一台服务器上。这个负载均衡服务器必须工作在 HTTP 协议层上。这样就能保证这个用户的请求都在同一台服务器上，这种方法又被成为会话粘滞。<br />但是 Session 绑定的方案不符合高可用程序，某台服务器宕机后一些依赖此服务器的用户的服务就不可用了。</p><ol start="3"><li>利用 Cookie 记录 Session<ol><li>Cookie 大小限制，记录信息有限</li><li>每次响应都要传输 Cookie，影响性能</li><li>如果用户关闭 Cookie 功能，访问就会不正常</li></ol></li><li>Session 分离</li></ol><p>独立的 Session 服务器或者集群，基础服务平台。<br /></p><h2 id="高可用的服务"><a href="#高可用的服务" class="headerlink" title="高可用的服务"></a>高可用的服务</h2><p>可复用的服务和应用一样，也是无状态的服务，此可以使用类似负载均衡的失效转移策略实现高可用服务。</p><ol><li>分级管理<ol><li>核心应用和服务优先使用更好的硬件，运维响应时间也要迅速</li></ol></li><li>超时设置<ol><li>超时后继续重试或者将请求失效转移到提供相同服务的其他服务器上</li></ol></li><li>异步调用<ol><li>消息队列等异步调用的方式</li></ol></li><li>服务降级<ol><li>拒绝服务？关闭服务？</li><li>拒绝服务：拒绝优先级低的应用调用，减少服务器的并发数，保证核心功能正常调用；或者随机拒绝部分请求调用，节约资源。</li><li>关闭服务：关闭不中哟的部分服务，或者服务内部关闭部分不重要的功能。</li></ol></li><li>幂等性设计<ol><li>服务重复调用是无法避免的，应用层也不需要关心服务是否真的失效，只要没有得到调用成功的响应，就可以认为调用失效，并充实服务调用。因此必须在服务层保证服务重复调用和调用一次产生的结果相同，即服务具有幂等性。</li></ol></li></ol><h2 id="高可用的数据"><a href="#高可用的数据" class="headerlink" title="高可用的数据"></a>高可用的数据</h2><p><br />数据备份和失效转移机制。<br /><br><br />为了保证数据的高可用，网站通常会牺牲另一个很重要的指标：数据一致性。<br />**<br /><strong>CAP 原理</strong><br /><strong>数据持久性</strong><br /><strong>数据可访问性</strong><br /><strong>数据一致性</strong></p><ol><li>数据强一致</li><li>数据用户一致</li><li>数据最终一致</li></ol><h3 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h3><p>异步热备份、同步热备份<br><img src="https://img-blog.csdnimg.cn/20200609210451646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhbm9pX2Fob2o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200609210512181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhbm9pX2Fob2o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="失效确认"><a href="#失效确认" class="headerlink" title="失效确认"></a>失效确认</h3><p><img src="https://img-blog.csdnimg.cn/20200609210518606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhbm9pX2Fob2o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="访问转移"><a href="#访问转移" class="headerlink" title="访问转移"></a>访问转移</h3><p>转移到存储的数据完全一样的服务器上（对等服务器）<br />如果服务不对等，就需要重新计算路由，选择存储服务器。</p><h3 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h3><p>。。。<br /></p><h2 id="软件质量保证"><a href="#软件质量保证" class="headerlink" title="软件质量保证"></a>软件质量保证</h2><h3 id="网站发布"><a href="#网站发布" class="headerlink" title="网站发布"></a>网站发布</h3><p>飞行中给飞机换个引擎。</p><h3 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h3><p>全面的回归测试。</p><h3 id="预发布验证"><a href="#预发布验证" class="headerlink" title="预发布验证"></a>预发布验证</h3><p>预发布机器。</p><h3 id="代码控制"><a href="#代码控制" class="headerlink" title="代码控制"></a>代码控制</h3><p>主干发布，分支开发。<br /><del>主干开发，分支发布。</del><br />~~</p><h3 id="自动化发布"><a href="#自动化发布" class="headerlink" title="自动化发布"></a>自动化发布</h3><h3 id="灰度发布"><a href="#灰度发布" class="headerlink" title="灰度发布"></a>灰度发布</h3><p>第一天发布 0<del>999 服务器，遇到故障回滚。<br />第二天发布 1000</del>1999 服务器，遇到故障回滚。<br />。。。<br /></p><h2 id="网站运行监控"><a href="#网站运行监控" class="headerlink" title="网站运行监控"></a>网站运行监控</h2><p>不允许没有监控的系统上线。</p><h3 id="监控数据采集"><a href="#监控数据采集" class="headerlink" title="监控数据采集"></a>监控数据采集</h3><ol><li>用户行为日志收集<ol><li>服务端日志手机</li><li>客户端浏览器日志收集</li></ol></li><li>服务器性能监控</li><li>运行数据报告</li></ol><h3 id="监控管理"><a href="#监控管理" class="headerlink" title="监控管理"></a>监控管理</h3><ol><li>系统报警</li><li>失效转移</li><li>自动优雅降级</li></ol><p>EOF！<br /></p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高性能网站架构-瞬时响应</title>
      <link href="/2020/06/09/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84-%E7%9E%AC%E6%97%B6%E5%93%8D%E5%BA%94/"/>
      <url>/2020/06/09/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84-%E7%9E%AC%E6%97%B6%E5%93%8D%E5%BA%94/</url>
      
        <content type="html"><![CDATA[<h1 id="高性能-瞬时响应"><a href="#高性能-瞬时响应" class="headerlink" title="高性能-瞬时响应"></a>高性能-瞬时响应</h1><p>检查请求各个环节的诶之，分析哪个环节响应时间不合理、超出预期；<br />检查监控数据，分析影响性能的主要因素是内存、磁盘、网络、还是 CPU，是代码问题还是架构设计不合理，或者系统资源确实不足。</p><h2 id="性能测试指标"><a href="#性能测试指标" class="headerlink" title="性能测试指标"></a>性能测试指标</h2><p>响应时间、并发数、吞吐量、性能计数器等。</p><h3 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h3><p>每个响应时间比较短不好测试，常用方法是重复请求很多次，求平均时间。</p><h3 id="并发数"><a href="#并发数" class="headerlink" title="并发数"></a>并发数</h3><p>系统能够同时处理请求的数目，对于网站而言，指同时提交请求的用户数目。<br /><br><br />测试程序通过多线程/协成模拟并发用户的办法来测试系统的并发处理能力，为了真实的模拟用户行为，测试程序并不是启动多线程后不停地发送请求，而是再两次请求中间加入一个随机等待时间，被称为<strong>思考时间。</strong></p><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p>TPS（每秒事务数）<br />HPS（每秒HTTP请求数）<br />QPS（每秒查询数）<br /></p><h3 id="性能计数器"><a href="#性能计数器" class="headerlink" title="性能计数器"></a>性能计数器</h3><p>System Load、对象与县城数、内存使用、CPU 使用、磁盘与网络 I/O 等指标。<br />系统监控、报警。<br /><br><br />System Load（系统负载），指当前正在被 CPU 执行和等待被执行的进程数目总和，是反应系统忙闲程度的重要指标。<br />Load 理想值是 CPU 数目，Load 高于 CPU 数目的时候表示系统资源不足，影响程序的执行性能。</p><p>top 命令查看，3 个浮点数，表示最近 1min、5min、15min 运行队列平均进程数。</p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h3><h4 id="减少-HTTP-请求"><a href="#减少-HTTP-请求" class="headerlink" title="减少 HTTP 请求"></a>减少 HTTP 请求</h4><p>合并 CSS 文件、合并 JS 文件、合并图片、懒加载等。</p><h4 id="使用浏览器缓存"><a href="#使用浏览器缓存" class="headerlink" title="使用浏览器缓存"></a>使用浏览器缓存</h4><p>缓存 CSS、JS、Logo、图表等静态资源。<br />通过设置 HTTP 头中的 Cache-Control 和 Expires 属性，控制浏览器的缓存。</p><blockquote><p>有时候静态资源变化需要及时应用到浏览器，可以通过修改文件名实现，即更新 JS 文件并不更新 JS 文件内容。</p></blockquote><p>逐渐更新：一次更新一部分图标文件等等。</p><h4 id="启用压缩"><a href="#启用压缩" class="headerlink" title="启用压缩"></a>启用压缩</h4><p>文本文件的压缩可达 80% 以上，因此 HTML、CSS、JS 通过启用 GZip 压缩可以达到好的效果，但是压缩对服务器和浏览器会产生一定的压力，在网络状况好的情况下要权衡考虑。</p><h4 id="CSS-放在页面最上面，JS-放在页面最下面"><a href="#CSS-放在页面最上面，JS-放在页面最下面" class="headerlink" title="CSS 放在页面最上面，JS 放在页面最下面"></a>CSS 放在页面最上面，JS 放在页面最下面</h4><p>浏览器会在下载完全部的 CSS 后才对网页进行渲染。<br />浏览器在加载 JS 后立即执行，有可能阻塞整个页面。</p><h4 id="减少-Cookie-传输"><a href="#减少-Cookie-传输" class="headerlink" title="减少 Cookie 传输"></a>减少 Cookie 传输</h4><p>减少 Cookie 次数。Cookie 会包含在每次的请求和响应中，太大的 cookie 会影像数据传输。<br />静态资源的传输，有时候带上 Cookie 没有意义，有的时候有意义（比如图片验证码）。</p><h4 id="CDN-加速"><a href="#CDN-加速" class="headerlink" title="CDN 加速"></a>CDN 加速</h4><p>emmm 类似于缓存</p><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><p>emmm 类似于缓存<br /></p><h3 id="服务端性能优化"><a href="#服务端性能优化" class="headerlink" title="服务端性能优化"></a>服务端性能优化</h3><p>网站性能优化第一定律：优先考虑缓存优化性能。</p><h4 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h4><p>注意要合理使用缓存。缓存穿透、雪崩、击穿！！！<br /><em>频繁修改的数据！</em><br /><em>没有热点的访问！</em><br /><em>数据不一致和脏读！</em><br /><em>缓存可用性！</em><br /><br><br />缓存预热！</p><h4 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h4><p>消息队列等。<br />消息队列（削峰作用）。</p><h4 id="使用集群"><a href="#使用集群" class="headerlink" title="使用集群"></a>使用集群</h4><p>配置负载均衡。</p><h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><p>多线程、协成。<br />资源使用统一管理（池，进程池、线程池、连接池、对象池、单例）</p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>哈希？</p><h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><p>。。。</p><h3 id="存储性能优化"><a href="#存储性能优化" class="headerlink" title="存储性能优化"></a>存储性能优化</h3><h4 id="机械硬盘、固态硬盘。"><a href="#机械硬盘、固态硬盘。" class="headerlink" title="机械硬盘、固态硬盘。"></a>机械硬盘、固态硬盘。</h4><h4 id="B-树、LSM-树。"><a href="#B-树、LSM-树。" class="headerlink" title="B+树、LSM 树。"></a>B+树、LSM 树。</h4><p>传统的关系数据库使用的是 B+ 树，层次最多三层。<br />现在很多 NoSQL 数据库使用 LSM 树。</p><h4 id="存储阵列"><a href="#存储阵列" class="headerlink" title="存储阵列"></a>存储阵列</h4><p>RAID0、RAID1、RAID10、RAID5、RAID6。<br />HDFS 中，系统在整个存储集群的多态服务器上进行数据并发读写备份，可以看做在服务器集群规模上上线了类似 RAID 的功能，因此不需要磁盘 RAID。<br />MapReduce 并发访问，迁移计算而不是不迁移数据。<br /><br><br />HDFS 中两个重要的服务器角色：NameNode（名字服务器节点）和 DataNode（数据存储节点）。<br />NameNode 在 HDFS 中只部署一个实例，提供元数据服务，相当于操作系统中的文件分配表 FAT，管理文件名 Block 的分配，维护整个文件系统的结构。<br />DataNode 则部署在 HDFS 集群中其他所有服务器上，提供真正的数据存储服务。<br /><br><br /><br><br /></p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大型网站架构核心要素</title>
      <link href="/2020/05/31/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E6%A0%B8%E5%BF%83%E8%A6%81%E7%B4%A0/"/>
      <url>/2020/05/31/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E6%A0%B8%E5%BF%83%E8%A6%81%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="大型网站核心架构要素"><a href="#大型网站核心架构要素" class="headerlink" title="大型网站核心架构要素"></a>大型网站核心架构要素</h1><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>浏览器端：浏览器缓存、页面压缩、合理页面布局、减少 Cookie 传出、CDN。<br>应用服务器端：本地缓存、分布式缓存、异步操作、服务器集群。<br>代码层面：多线程、改善内存管理等。<br>数据库端：索引、缓存、SQL 优化等性能优化手段、NoSQL 优化数据模型、存储结构、伸缩性。</p><h2 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h2><p>假设系统中任何一台或多台服务器宕机时，以及出现各种不可预期的问题时，系统整体依然保持可用。<br>提高网站可用性的主要手段是冗余。<br>1、对于应用服务器，多台服务器负载均衡，前提是应用服务器上不能保存请求的回话信息（小姐姐小哥哥游泳健身表单）。<br>2、对于存储服务器，实时热备份。<br>3、开发过程质量保证，预发布验证、自动化测试、自动化发布、灰度发布，减少将故障引入线上环境。</p><h2 id="伸缩性"><a href="#伸缩性" class="headerlink" title="伸缩性"></a>伸缩性</h2><p>所谓伸缩性是指通过不断向及群众加入服务器的手段来缓解不断上升的用户并发访问压力和不断增长的数据存储需求。</p><p>1、对于应用服务器集群，只要服务器上不保存数据，所有服务器都是对等的，通过合适的负载均衡设备就可以向进群中不断添加服务器。<br>2、对于缓存服务器集群，加入新的服务器可能会导致缓存路由失败，进而导致及群众大部分缓存数据无法访问。虽然缓存的数据可以通过数据库重新加载，但是如果应用已经严重依赖缓存，可能会导致整个网站崩溃，需要改进缓存路由算法保证缓存数据的可访问性。<br>3、数据库虽然支持数据复制，主从热备等机制，但是很难做到大规模集群的可伸缩性，因此关系数据库的集群伸缩性方案必须在数据库之外实现，通过<strong>路由分区</strong>等手段将部署有多个数据库的服务器组成一个集群。</p><p>至于 NoSQL 数据库，天生就是为海量数据而生，伸缩性通常都非常好。</p><h2 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h2><p>增加新的业务产品时，是否可以实现对现有产品透明吴映香，不需要任何改动或者很少的搞懂现有业务功能就可以上线新的产品。不同产品之间的少耦合。<br>网站可扩展架构的主要手段是<strong>事件驱动和分布式服务。</strong></p><p>事件驱动架构在网站通常利用消息队列来实现，分布式服务则是将业务和可复用服务分离开来，通过分布式服务框架调用。</p><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>现存和潜在的攻击和窃密手段，是否有可靠的应对策略。</p><hr><p>EOF</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大型网站架构模式</title>
      <link href="/2020/05/31/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/05/31/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="大型网站架构模式"><a href="#大型网站架构模式" class="headerlink" title="大型网站架构模式"></a>大型网站架构模式</h1><p>每一个模式描述了一个在我们周围不断重复大声的问题以及问题解决方案的核心。</p><h2 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h2><p>将系统横向切分。<br>分层结构在计算机中无处不在，网络的 ISO 7层分层，计算机硬件、操作系统、应用软件也是一种分层。<br>网站系统中：应用层、服务层、数据层。<br>分层架构的挑战：合理规划层次边界和接口。<br>进制跨层次的调用（应用层直接调用数据层）和逆向调用（数据层调用服务层，或者服务层调用应用层）。</p><h2 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h2><p>将系统纵向切分。<br>将每一层按模块进行分割，每个模块由不同的团队负责。</p><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><p>分布式应用和服务、分布式静态资源、分布式数据和存储、分布式计算（Hadoop 的 MapReduce 分布式计算框架，移动计算而不是移动数据）。</p><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>使用分布式已经将分层和分割后的模块独立部署，但是对于用户访问集中的模块（比如网站首页），还需要将独立部署的服务器集群化，即多态服务器部署相同应用构成一个集群，通过负载均衡设备共同对外提供服务。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>CDN、反向代理、本地缓存、分布式缓存。<br>使用缓存有两个条件：<br>1、数据访问热点不均衡，某些数据会被更频繁的访问；<br>2、数据再某个时间段内有效，不会很快过期，否则缓存的数据会因已经失效而产生脏读，影响正确性。</p><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>单一服武器内部可以通过多线程共享内存队列的方式实现异步，业务线程将输出写入队列，处理线程从队列读取进行处理；<br>分布式系统中，多个服务器集群通过分布式消息队列实现异步（内存队列的分布式部署）。<br>异步架构是典型的生产者消费者模型，两者不存在直接调用，只需要保持数据结构不变，彼此功能实现可以随意变化而不相互影响，这对网站拓展新功能非常便利。</p><p>使用异步队列还有如下特性：<br>1、提供系统可用性，消费者服务器故障，数据再消息队列中堆积，生产者继续处理就可以了。<br>2、加快网站响应速度，业务端将请求写入消息队里，不需要等待消费者处理就可以返回。<br>3、消除并发访问高峰，消息队列将突然增加的访问请求数据放入消息队列中，等待消费者服务器依次处理。</p><h2 id="冗余"><a href="#冗余" class="headerlink" title="冗余"></a>冗余</h2><p>定期备份，冷备份。<br>主从热备份。<br>容灾数据中心。<br>去中心化。</p><h2 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h2><p>发布过程自动化、自动化代码管理、自动化测试、自动化安全监测、自动化部署、自动化监控、自动化报警、自动化失效转移、自动化失效恢复、自动化降级（网站遇到高峰超出处理能力，为了保证整个网站安全可用，关闭一些不用的服务或者拒绝部分请求）、自动化分配资源。</p><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>加密、安全校验、风险控制。</p><hr><p>EOF</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大型网站架构演化</title>
      <link href="/2020/05/31/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8C%96/"/>
      <url>/2020/05/31/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="大型网站架构演化"><a href="#大型网站架构演化" class="headerlink" title="大型网站架构演化"></a>大型网站架构演化</h1><h2 id="网站架构设计的目标"><a href="#网站架构设计的目标" class="headerlink" title="网站架构设计的目标"></a>网站架构设计的目标</h2><p>高可用、高性能、易扩展、可伸缩、安全。</p><p>网站的价值在于它能为用户提供什么价值，在于网站能做什么，不在于网站怎么做的。<br>不是所有的问题都可以通过技术来解决。<br>有的时候调整业务也是很好的一种方式。<br><strong>技术是用来解决业务问题的，业务的问题也可以尝试通过业务的手段去解决。</strong></p><h2 id="网站架构演化发展历程"><a href="#网站架构演化发展历程" class="headerlink" title="网站架构演化发展历程"></a>网站架构演化发展历程</h2><h3 id="初始阶段"><a href="#初始阶段" class="headerlink" title="初始阶段"></a>初始阶段</h3><p><img src="https://img-blog.csdnimg.cn/20200531180643823.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhbm9pX2Fob2o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="应用服务和数据服务分离"><a href="#应用服务和数据服务分离" class="headerlink" title="应用服务和数据服务分离"></a>应用服务和数据服务分离</h3><p>一台服务器逐渐不能满足需求，越来越多的用户访问导致性能越来越差，越来越多的数据导致存储空间不足。<br>将存储和应用服务器分开。<br><img src="https://img-blog.csdnimg.cn/20200531180659941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhbm9pX2Fob2o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>80% 的业务访问集中在 20% 的数据上。<br>缓存又可以有两种方案：</p><ol><li>缓存在应用服务器的本地缓存；<ol><li>访问速度较快，但是收到内存限制。</li></ol></li><li>专门的分布式缓存服务器；<ol><li>理论上不受内存容量限制。</li></ol></li></ol><p><img src="https://img-blog.csdnimg.cn/20200531180709372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhbm9pX2Fob2o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="应用服务器集群"><a href="#应用服务器集群" class="headerlink" title="应用服务器集群"></a>应用服务器集群</h3><p>使用集群是网站解决高并发、海量数据问题的常用手段。</p><p><img src="https://img-blog.csdnimg.cn/20200531180718394.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhbm9pX2Fob2o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="数据库读写分离"><a href="#数据库读写分离" class="headerlink" title="数据库读写分离"></a>数据库读写分离</h3><p>网站使用缓存后，绝大部分数据读操作访问都可以不通过数据库就能完成，但是仍有一部分读操作（缓存访问不命中、缓存过期）和全部的写操作需要访问数据库，在网站的用户达到一定规模后，数据库因为负载压力过高而成为网站的瓶颈。<br>大部分主流数据库提供<strong>主从热备</strong>功能，配置主从关系，将数据同步，利用这一功能进行读写分离，改善数据库负载压力。<br><img src="https://img-blog.csdnimg.cn/2020053118073782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhbm9pX2Fob2o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="反向代理和-CDN-加速"><a href="#反向代理和-CDN-加速" class="headerlink" title="反向代理和 CDN 加速"></a>反向代理和 CDN 加速</h3><p><strong>CDN 和 反向代理的基本原理都是缓存。</strong><br>CDN 部署在网络提供商的机房，用户在请求网站服务时，可以从距离自己最近的网络提供商机房获取数据；<br>反向代理部署在网站的中心机房，当用户请求到达中心机房后，首先访问的服务器是反向代理服务器，如果反向代理服务器中缓存着用户请求的资源，就将其直接返回给用户。<br><img src="https://img-blog.csdnimg.cn/20200531180748725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhbm9pX2Fob2o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="分布式文件系统和分布式数据库"><a href="#分布式文件系统和分布式数据库" class="headerlink" title="分布式文件系统和分布式数据库"></a>分布式文件系统和分布式数据库</h3><p>文件服务器正常，文件太多放不下了。<br>分布式数据库是网站数据库拆分的最后手段，只有在单表数据规模非常大的时候才使用。<br>不到不得已时，网站常用的数据库拆分手段是<strong>业务分库</strong>，不同业务使用不同数据库部署在不同的机器上。</p><p><img src="https://img-blog.csdnimg.cn/2020053118080145.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhbm9pX2Fob2o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="NoSQL-和搜索引擎"><a href="#NoSQL-和搜索引擎" class="headerlink" title="NoSQL 和搜索引擎"></a>NoSQL 和搜索引擎</h3><p>网站业务愈加复杂，对数据存储和检索的需求也越来越复杂，网站需要使用一些菲关系数据库技术如 NoSQL 和非数据库查询技术如搜索引擎。<br><img src="https://img-blog.csdnimg.cn/20200531180809489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhbm9pX2Fob2o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="业务拆分"><a href="#业务拆分" class="headerlink" title="业务拆分"></a>业务拆分</h3><p>纵向拆分。<br><img src="https://img-blog.csdnimg.cn/20200531180821910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhbm9pX2Fob2o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="服务拆分"><a href="#服务拆分" class="headerlink" title="服务拆分"></a>服务拆分</h3><p>横向拆分。<br>提供一些统一的常用的相同的业务操作。<br>业务部门、基础服务器部门、数据部门等等。</p><p><img src="https://img-blog.csdnimg.cn/20200531180834481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhbm9pX2Fob2o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr><p>EOF</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存雪崩、缓存击穿、缓存穿透</title>
      <link href="/2020/05/18/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/"/>
      <url>/2020/05/18/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/</url>
      
        <content type="html"><![CDATA[<p>缓存雪崩、缓存击穿、缓存穿透的概念和解决方案。</p><p>布隆过滤器的简单原理和应用。</p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>就是缓存层里的数据同一个时间点失效，那么这些数据就会集中打向 MySQL。</p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存里有一条数据，一条数据失效后也是穿过了 redis 打到了 MySQL。</p><p>缓存击穿、缓存雪崩属于缓存穿透的一种特殊表现形式。</p><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p><strong>描述</strong></p><p>当找 redis 找不到数据时候，就会出现缓存穿透。</p><p>低频率的缓存穿透不可怕，正常现象。</p><p>当高频率的穿透就影响大了。</p><p>黑客攻击的场景，模拟很多客户端发送 id = -1 的请求。</p><p>id = -1 在 redis 中找不到，穿过 redis 找到数据库，数据处理不过来就崩了（拒绝服务攻击DDOS）。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li><p>通过 MySQL 中找不到的值缓存在 redis 中。（黑客太菜了）</p><p>当然第一次查询 id = -1 的时候可能没找到穿透了，但是这次我把 id = -1 放在了 redis 中。</p><p>id = -2 再查询我再放。。。。也是大量的访问数据库。（UUID 黑盒 每次生成一个不一样的 ID）</p><p>这个方案适得其反，redis 一定的数据淘汰策略（LRU、LFU…）如果每次都是 UUID，那么真正需要缓存的数据就被淘汰了，redis 里是一些垃圾数据。</p></li><li><p>过滤器（redis），这个过滤器把 MySQL 里面的所有 id 号，放在 redis 和 MySQL 的中间（不行），不一定是通过 id 查询或者 id 过多，这样就会导致过滤器的效率太低，内存紧张，导致整个链路都很慢。</p><p>解决过滤器中数据过多的场景。布隆过滤器，通过一定的错误率降低内存的占用。</p><p>比如 id = 100，传给 hash 函数，来一个 bin(二进制, size=10) 数组，保证哈希结果在 0-9 之间。。。。。。</p><p>拿到 id = 100，计算出的 hash 相同，就会告诉客户端你要的数据是有的。</p><p>错误发生在计算哈希上，如果布隆过滤器告诉你数据存在，那么数据不一定存在。如果布隆过滤器告诉你数据不存在，那么这个数据一定不存在。</p><p>宁可错杀 3k 不放过一个。发生哈希碰撞就有可能是一次错误，<em>数组的长度影响错误率</em>。</p><p>和<em>哈希函数的个数也有关系</em>。布隆过滤器的简单实现是 3 个 hash 函数计算的三个位置标示一个数据是否存在。哈希函数个数多了反而错误率升高。数组长度很长会增加内存占用。</p><p>【人生中最重要的一个字“度”】，通过算法计算合适的 hash 函数个数和数组长度。通常的布隆过滤器会要求提供允许的错误率 fpp 和存储的数据量 n。然后通过公式计算出数组大小 m 和 hash 函数的个数 k。</p><p>m = - ( n*ln(fpp) ) / ( ln(2) ^2 )</p><p>k = m/n * ln(2)</p><p>遇到删除数据的情况？如果 id = 100 和 id = 10 的 hash 结果相同，我删除了 id = 10 的数据，那么布隆过滤器的这个 hash 结果的位置不能设为 0，因为还有数据对应。</p><p>如果场景中有频繁的数据删除情况，建议搞一个二维的数组，第二维的数组用来计数。（长度 100亿占用 1GB 左右）</p><p><strong>面试题：文件 A 存了 100 亿个URL，B 文件也是 100 亿个 URL。只给一个 4GB 内存文件，快速找出 AB 的交集。</strong></p><p><strong>模糊算法</strong></p><p>通过布隆过滤器来计算 A 中的，B 中的 URL，然后找到对应的交集。只需要一次的磁盘 IO 即可。</p><p><strong>精准算法</strong></p><p>A、B 两个大文件拆分 1000 个放一个文件，分块计算 hash 值然后对 1000 取余。然后对A、B的小文件一一比较。拆分成小文件是为了可以加载入内存中。</p><p>相同 URL 的 hash 值相同，取摸后也相同。所以会出现在 1-1 对应的小文件中。</p></li></ul><hr><p>EOF</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UDP协议、UDP编程、有连接的UDP</title>
      <link href="/2020/05/04/UDP%E5%8D%8F%E8%AE%AE%E3%80%81UDP%E7%BC%96%E7%A8%8B%E3%80%81%E6%9C%89%E8%BF%9E%E6%8E%A5%E7%9A%84UDP/"/>
      <url>/2020/05/04/UDP%E5%8D%8F%E8%AE%AE%E3%80%81UDP%E7%BC%96%E7%A8%8B%E3%80%81%E6%9C%89%E8%BF%9E%E6%8E%A5%E7%9A%84UDP/</url>
      
        <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>UDP 输出 TCP/IP 协议分层中的传输层。<br>UDP 是一个不可靠的通信协议，没有重传和确认，没有有序控制，也没有拥塞控制。<br>UDP 不保证报文的有效传递，不保证报文的有序，也就是说使用 UDP 的时候，我们需要做好丢包、重传、报文组装等工作。<br>UDP 比较简单，适合的场景还是比较多的，我们常见的 DNS 服务，SNMP 服务都是基于 UDP 协议的，这些场景对时延、丢包都不是特别敏感。另外多人通信的场景，如聊天室、多人游戏等，也都会使用到 UDP 协议。<br><img src="https://img-blog.csdnimg.cn/20200411214854640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhbm9pX2Fob2o=,size_16,color_FFFFFF,t_70" alt="OSI和TCP/IP"></p><h2 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h2><p>UDP 报头长 8 字节，分别是<strong>源端口、目的端口、UDP 报文长度、校验和</strong>。<br>因为 UDP 报文长度只用 2 个字节记录，所以包含报头长度的报文最大长度为 65535 字节。</p><blockquote><p>用UDP协议发送时，用sendto函数最大能发送数据的长度为：65535- IP头(20) - UDP头(8)＝65507字节。用sendto函数发送数据时，如果发送数据长度大于该值，则函数会返回错误。<br>由于IP有最大MTU，因此，<br>UDP 包的大小应该是 1500 - IP头(20) - UDP头(8) = 1472(Bytes)</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200411215530608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhbm9pX2Fob2o=,size_16,color_FFFFFF,t_70" alt="UDP报文"></p><h2 id="UDP-编程"><a href="#UDP-编程" class="headerlink" title="UDP 编程"></a>UDP 编程</h2><p><strong>服务器：</strong><br>1、创建 socket。<br>2、绑定要监听的 ip 和 port。<br>3、循环：<br>3.1、调用 recvfrom 读取接收到的报文，如果没有报文则阻塞在这里。<br>3.2、收到报文处理完后调用 sendto 将相应发给客户端。</p><p><strong>客户端：</strong><br>1、创建 socket。<br>2、循环：<br>2.1、调用 sendto 发送请求。<br>2.2、调用 recvfrom 接收相应。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">// 返回值：收到数据的字节数</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">// sockfd：socket描述符</span></span><br><span class="line"><span class="comment">// buff：本地缓存</span></span><br><span class="line"><span class="comment">// nbytes：缓存最大接收字节数</span></span><br><span class="line"><span class="comment">// flags：I/O 相关的参数，一般使用 0 即可</span></span><br><span class="line"><span class="comment">// from：发送端的 ip 和 port 等信息</span></span><br><span class="line"><span class="comment">// addrlen：from 的大小</span></span><br><span class="line"><span class="type">ssize_t</span> </span><br><span class="line"><span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buff, <span class="type">size_t</span> nbytes, <span class="type">int</span> flags, </span></span><br><span class="line"><span class="params">　　　　　　　　　　<span class="keyword">struct</span> sockaddr *from, <span class="type">socklen_t</span> *addrlen)</span>; </span><br><span class="line">　　　　</span><br><span class="line"><span class="comment">// 返回值：发送了多少字节</span></span><br><span class="line"><span class="comment">// 参数：和上面的 recvfrom 类似　　　　　　</span></span><br><span class="line"><span class="type">ssize_t</span></span><br><span class="line"><span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buff, <span class="type">size_t</span> nbytes, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">                <span class="type">const</span> <span class="keyword">struct</span> sockaddr *to, <span class="type">socklen_t</span> addrlen)</span>; </span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200411215902272.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhbm9pX2Fob2o=,size_16,color_FFFFFF,t_70" alt="UDP编程时序"><br>代码参考我之前的文章：<a href="https://blog.csdn.net/Hanoi_ahoj/article/details/105358383">UDP 回显程序https://blog.csdn.net/Hanoi_ahoj/article/details/105358383</a></p><blockquote><p>UDP 报文的“无连接”的特点，可以在 UDP 服务器重启之后，继续进行报文的发送，这就是 UDP 报文“无上下文”的最好说明。</p></blockquote><h2 id="有连接的-UDP"><a href="#有连接的-UDP" class="headerlink" title="有连接的 UDP"></a>有连接的 UDP</h2><p>通过上文，在 UDP 中是不需要类似于 TCP 编程中的 connect 建立连接的。<br>其实 UDP 也可以是 “有连接” 的。</p><p>下面通过一个程序来测试一下：<br><strong>客户端：</strong> 需要注意的是在创建完 socket 后进行了 connect，绑定了服务器的 ip 和 port。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UDP connect 测试客户端</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> socket_fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (socket_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">  bzero(&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">  server_addr.sin_family = AF_INET;</span><br><span class="line">  server_addr.sin_port = htons(<span class="number">9090</span>);</span><br><span class="line">  server_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> ret = connect(socket_fd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input&gt;&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">    <span class="type">ssize_t</span> n = sendto(socket_fd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      perror(<span class="string">&quot;sendto&quot;</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%zd bytes sent to [%s:%d]\n&quot;</span>, n, inet_ntoa(server_addr.sin_addr), ntohs(server_addr.sin_port));</span><br><span class="line"></span><br><span class="line">    bzero(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    n = recvfrom(socket_fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      perror(<span class="string">&quot;recvfrom&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;resp: %s\n&quot;</span>, buf);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  close(socket_fd);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>服务器：</strong> 就是正常的服务器，收到请求原封不动返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> socket_fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (socket_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">  bzero(&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">  server_addr.sin_family = AF_INET;</span><br><span class="line">  server_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;0.0.0.0&quot;</span>);</span><br><span class="line">  server_addr.sin_port = htons(<span class="number">9090</span>);</span><br><span class="line">  <span class="type">int</span> ret = bind(socket_fd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一般服务器不进行 connect 操作</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">    bzero(&amp;client_addr, <span class="keyword">sizeof</span>(client_addr));</span><br><span class="line">    <span class="type">socklen_t</span> client_addr_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">    <span class="type">ssize_t</span> n = recvfrom(socket_fd, buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">        (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;client_addr_len);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      perror(<span class="string">&quot;recvfrom&quot;</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buf[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;req-&gt;[%s:%d] %s\n&quot;</span>, inet_ntoa(client_addr.sin_addr),</span><br><span class="line">        ntohs(client_addr.sin_port), buf);</span><br><span class="line"></span><br><span class="line">    n = sendto(socket_fd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, client_addr_len);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      perror(<span class="string">&quot;sendto&quot;</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  close(socket_fd);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc client.c -o client</span><br><span class="line">gcc server.c -o server</span><br></pre></td></tr></table></figure><p><strong>测试：</strong><br>1、不运行 server，只运行 client。<br>可以看到，在调用 sendto 的时候发送了，但是当走到 recvfrom 的时候出错 Connection refused。</p><p><img src="https://img-blog.csdnimg.cn/20200411231916813.png" alt="client"><br>2、运行 server 和 client。<br>正常的接收请求、处理请求过程。<br><img src="https://img-blog.csdnimg.cn/20200411232338781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhbm9pX2Fob2o=,size_16,color_FFFFFF,t_70" alt="server &amp;&amp; client"></p><h3 id="UDP-connect-的作用"><a href="#UDP-connect-的作用" class="headerlink" title="UDP connect 的作用"></a>UDP connect 的作用</h3><p>不用 connect 的话，不开启 server，运行 client，程序会阻塞在 recvfrom 上。直到服务器重启或者超时。<br>通常 UDP 的服务器是不需要进行 connect 的，因为 connect 以后这个服务器就只能对这个客户端进行服务器了。</p><p>==connect 的作用就是让程序尽早收到错误信息返回：==</p><p>通过对 UDP 套接字进行 connect 操作，将 UDP 套接字建立了“上下文”，该套接字和服务器端的地址和端口产生了联系，正是这种绑定关系给了操作系统内核必要的信息，能够将操作系统内核收到的信息和对应的套接字进行关联。</p><p>调用 sendto 或者 send 操作函数时，应用程序报文被发送，我们的应用程序返回，操作系统内核接管了该报文，之后操作系统开始尝试往对应的地址和端口发送，因为对应的地址和端口不可达，一个 ICMP 报文会返回给操作系统内核，该 ICMP 报文含有目的地址和端口等信息。</p><p>进行了 connect 操作，帮助操作系统内核从容建立了（UDP 套接字——目的地址 + 端口）之间的映射关系，当收到一个 ICMP 不可达报文时，操作系统内核可以从映射表中找出是哪个 UDP 套接字拥有该目的地址和端口，别忘了套接字在操作系统内部是全局唯一的，当我们在该套接字上再次调用 recvfrom 或 recv 方法时，就可以收到操作系统内核返回的“Connection Refused”的信息。</p><p>在对 UDP 进行 connect 之后，关于收发函数的使用，很多书籍是这样推荐的：<br>使用 send 或 write 函数来发送，如果使用 sendto 需要把相关的 to 地址信息置零；<br>使用 recv 或 read 函数来接收，如果使用 recvfrom 需要把对应的 from 地址信息置零。<br>其实不同的 UNIX 实现对此表现出来的行为不尽相同。</p><p>==效率因素：==</p><p>因为如果不使用 connect 方式，每次发送报文都会需要这样的过程：<br>连接套接字→发送报文→断开套接字→连接套接字→发送报文→断开套接字 →………</p><p>而如果使用 connect 方式，就会变成下面这样：<br>连接套接字→发送报文→发送报文→……→最后断开套接字</p><p>我们知道，连接套接字是需要一定开销的，比如需要查找路由表信息。所以，UDP 客户端程序通过 connect 可以获得一定的性能提升。</p><hr><p>参考：极客时间 - 网络编程实战(<a href="https://time.geekbang.org/column/article/129807">https://time.geekbang.org/column/article/129807</a>)</p><p>EOF</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回显程序</title>
      <link href="/2020/04/07/%E5%9B%9E%E6%98%BE%E7%A8%8B%E5%BA%8F/"/>
      <url>/2020/04/07/%E5%9B%9E%E6%98%BE%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="基础铺垫"><a href="#基础铺垫" class="headerlink" title="基础铺垫"></a>基础铺垫</h2><p>首先来简单说几个问题。</p><p><strong>1、程序双击后发生了什么？</strong><br>程序双击后，程序会被操作系统装载入内存，包括程序的代码、数据等信息。然后从程序的入口开始执行。</p><p><strong>2、本机的不同程序间可以相互对话(通信)吗？</strong><br>当然是可以的，召唤师们经常用的 WeGame 和 LOL 是两个程序，当你在 WeGame 登录后点击启动 LOL，通常情况下再不用在 LOL 输入账号密码了，说明你再 WeGame 登录的账号信息也给了 LOL 的程序。至于是如何给的？<br>举个实现的例子：当你登录 WeGame 后，你会获得一个 ticket，这个 ticket 代表你的小票，这个小票就有着你的身份信息，你可以凭着这个小票进入召唤师峡谷。这个还得看程序员的具体的实现。</p><p>这个就属于<em>进程间通信</em>。</p><p><strong>3、如何实现不同主机间的不同进程的对话(通信)？</strong><br>当然可以，你电脑上的 QQ 和室友电脑上的 QQ，双击后会被载入自己的内存，那么你发的话是如何被室友收到的呢？这个就是不同主机间不同进程的通信，利用网络通信！</p><p><strong>4、那问题 3 中的两个 QQ 进程是如何找到对方的呢？</strong><br>举个栗子：假设你有个女朋友，你的女朋友在北京上大学，你在西安上大学，你的女朋友给你准备了一份礼物，她要把这个礼物寄给你，她会填写快递信息如：<br>【中国陕西省西安市xxx区，西安xxx大学，xxx收，手机号xxx】<br>快递小哥可以根据这个地址和手机号唯一的定位到你，然后把快递送到你手里。</p><p>在计算机中也是有唯一标识的，这个东西就是 ==IP== 地址，IP 地址标识了网络上的一台主机。<br>IP 地址就相当于【中国陕西省西安市xxx区，西安xxx大学】。<br>但是你的电脑上正在运行着很多程序，QQ、LOL、WeGame 等等，对方怎么知道这个包裹发给哪个程序呢？这个就需要另一个东西叫==端口号==。这个端口号就唯一的标识了你电脑上的一个程序。<br>端口号就相当于【xxx收，手机号xxx】。</p><p>这样就可以唯一的标识一个网络上一个主机的一个进程了。</p><p><strong>5、什么是协议？</strong><br>协议就是一种约定，用 4 中的栗子来说，你的女朋友给你寄的是特产烤鸭，她打电话给你说让你拿到后热一下再吃，这就是一种协议。<br>当然你也可以拿到后不热直接吃。（别吃坏肚子了）<br>当然她使用中文填写的快递地址信息也是和快递小哥的一种协议(约定)。</p><p><strong>6、计算机有大端和小端之分，那数据在网络上传输的时候是按照什么方式传输呢？</strong><br>规定网络传输的数据都以大端序传输，即先发出的数据是低地址，后发出的数据是高地址。<br>发送主机通常将发送缓冲区中的数据按内存地址从低到高的顺序发出；<br>接收主机把从网络上接到的字节依次保存在接收缓冲区中,也是按内存地址从低到高的顺序保存；<br>TCP/IP协议规定，网络数据流应采用大端字节序，即低地址高字节；<br>不管这台主机是大端机还是小端机，都会按照这个 TCP/IP 规定的网络字节序来发送/接收数据；<br>如果当前发送主机是小端，就需要先将数据转成大端；否则就忽略，直接发送即可。</p><p>为使网络程序具有可移植性，使同样的C代码在大端和小端计算机上编译后都能正常运行，下文的代码实现均会做网络字节序和主机字节序的转换。<br>转换需要用到的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span>;  <span class="comment">// host to network long</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span>;  <span class="comment">// host to network short</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span>;  <span class="comment">// network to host long</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span>;  <span class="comment">// network to host short</span></span><br></pre></td></tr></table></figure><hr><p>好了铺垫就到这里，来说说 UDP 协议。</p><h2 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h2><p>UDP 协议就是一种约定，约定了“快递小哥”拿到包裹后根据什么找到你。</p><p>UDP 协议格式如下：<br><img src="https://img-blog.csdnimg.cn/20200407105156814.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhbm9pX2Fob2o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>其中需要注意的是：<br>1、2 个字节的 UDP 长度，是这整个 UDP 协议的长度，也就是说上面这张图的数据部分最多放 65535 - 64 字节的数据。<a href="https://blog.csdn.net/caoshangpa/article/details/51530685">资料：TCP、UDP数据包大小的限制</a><br>2、校验和，如果校验和出错（和实际收到的数据校验和对不上），这个包裹就被丢弃了。</p><h2 id="UDP-网络回显程序"><a href="#UDP-网络回显程序" class="headerlink" title="UDP 网络回显程序"></a>UDP 网络回显程序</h2><p>实现如下功能：<br>客户端  — hello —&gt;  服务器<br>客户端  &lt;— hello — 服务器</p><p><img src="https://img-blog.csdnimg.cn/2020040715031538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhbm9pX2Fob2o=,size_16,color_FFFFFF,t_70" alt="回显服务器测试"></p><h3 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h3><ol><li>创建一个 socket；</li><li>服务器需要绑定一个固定的 IP 和端口号方便客户端找到他；</li><li>服务器启动并监听这个端口号；</li><li>循环处理：收到请求、处理请求、返回响应。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc echo_server.c -o echo_server</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// echo_server.c</span></span><br><span class="line"><span class="comment">// UDP 回显服务器</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建 socket</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绑定 IP 和 port</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;0.0.0.0&quot;</span>);</span><br><span class="line">    addr.sin_port = htons(<span class="number">8080</span>);</span><br><span class="line">    <span class="type">int</span> ret = bind(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;server start!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环处理收到的请求、返回响应</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 读取请求</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span>  <span class="comment">// 客户端 ip 和 port</span></span><br><span class="line">        <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line"></span><br><span class="line">        <span class="type">ssize_t</span> n = recvfrom(fd, buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;len);</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;recvfrom&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;  <span class="comment">// 当一次读取失败，服务器不退出</span></span><br><span class="line">        &#125;</span><br><span class="line">        buf[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理请求</span></span><br><span class="line">        <span class="comment">// 因为是回显服务器，原封不动返回给客户端</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回响应</span></span><br><span class="line">        n = sendto(fd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, len);</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;sendto&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%s:%d] buf: %s\n&quot;</span>, inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port), buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h3><ol><li>创建 socket；</li><li>配置要连接服务器的 ip 和 port；</li><li>循环处理：获取输入、发送给服务器、获取响应结果。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc echo_client.c -o echo_client</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// echo_client.c</span></span><br><span class="line"><span class="comment">// UDP 回显客户端</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建 socket</span></span><br><span class="line">    <span class="type">int</span> fd = socket(AF_INET6, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置要连接服务器的 ip 和 port</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取输入</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;input&gt; &quot;</span>);</span><br><span class="line">        <span class="type">char</span> input[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;input);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将输入发送给服务器</span></span><br><span class="line">        sendto(fd, input, <span class="keyword">sizeof</span>(input), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;req: %s\n&quot;</span>, input);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接收响应</span></span><br><span class="line">        <span class="type">char</span> resp[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        recvfrom(fd, resp, <span class="keyword">sizeof</span>(resp), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;resp: %s\n&quot;</span>, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现说明"><a href="#实现说明" class="headerlink" title="实现说明"></a>实现说明</h3><p><strong>1、socket()</strong></p><p>socket 函数用来创建一个建立网络通信的端点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure><p>参数：<br>domain，在上面的代码中使用 AF_NET，即 IPv4，当然还有其他的选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Name                Purpose                          Man page</span><br><span class="line">AF_UNIX, AF_LOCAL   Local communication              unix(7)</span><br><span class="line">AF_INET             IPv4 Internet protocols          ip(7)</span><br><span class="line">AF_INET6            IPv6 Internet protocols          ipv6(7)</span><br><span class="line">AF_IPX              IPX - Novell protocols</span><br><span class="line">AF_NETLINK          Kernel user interface device     netlink(7)</span><br><span class="line">AF_X25              ITU-T X.25 / ISO-8208 protocol   x25(7)</span><br><span class="line">AF_AX25             Amateur radio AX.25 protocol</span><br><span class="line">AF_ATMPVC           Access to raw ATM PVCs</span><br><span class="line">AF_APPLETALK        Appletalk                        ddp(7)</span><br><span class="line">AF_PACKET           Low level packet interface       packet(7)</span><br></pre></td></tr></table></figure><p>type，套接字具有指定的类型，该类型指定通信语义。即代表协议，上述代码中使用 SOCK_DGRAM 代表 UDP。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SOCK_STREAM TCP协议使用这个</span><br><span class="line">SOCK_DGRAM UDP协议</span><br></pre></td></tr></table></figure><p>protocol，用来指定 socket 所使用的传输协议编号，通常为0。</p><p>返回值：<br>失败返回 -1，成功返回对应的文件描述符。</p><p><strong>2、bind()</strong><br>当使用 socket() 来创建一个 socket 时候，它存在于名称空间(地址族)中，但没有分配给它地址。<br>bind 用来给 socket 绑定 ip 和 端口。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure><p>返回值：<br>成功返回 0，失败返回 -1。<br>参数：<br>sockfd，创建的 socket 文件描述符。<br>addr，这个结构体存储协议族、ip、port等信息。<br>addr_len，addr 的大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line"><span class="type">sa_family_t</span> sa_family;</span><br><span class="line"><span class="type">char</span>        sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>socket API 可以都用 struct sockaddr * 类型表示, 在使用的时候需要强制转化成 sockaddr_in；<br>这样的好处是程序的通用性，可以接收IPv4、IPv6, 以及UNIX Domain Socket 各种类型的sockaddr结构体指针做为参数;<br><img src="https://img-blog.csdnimg.cn/20200407153746953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhbm9pX2Fob2o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></blockquote><p><strong>3、sendto()</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">                        <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure><p>发送 buf 中的数据 len 个给 dest_addr。</p><p><strong>4、recvfrom()</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">                        <span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure><p>接收到一个数据，src_addr 是输出型参数，代表谁发给我的。</p><h2 id="封装-UDP-socket"><a href="#封装-UDP-socket" class="headerlink" title="封装 UDP socket"></a>封装 UDP socket</h2><p>可以看到，上面服务端、客户端实现时候，有一些同样的操作要做，那为了后面使用方便，封装一个 UDP 的 socket 类来实现这些共同的操作。</p><p>来分析一下需求：<br>客户端程序需要：</p><ul><li>创建 socket</li><li>关闭 socket</li><li>接收数据</li><li>发送数据</li></ul><p>服务端程序需要：</p><ul><li>创建 socket</li><li>关闭 socket</li><li>接收数据</li><li>发送数据</li><li>绑定端口号</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>udp_socket.hpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __UDP_SOCKET__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __UDP_SOCKET__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UdpSocket</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">UdpSocket</span>() : <span class="built_in">m_fd</span>(<span class="number">-1</span>) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">UdpSocket</span>() &#123;</span><br><span class="line">        <span class="built_in">Close</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 UDP socket</span></span><br><span class="line">    <span class="comment">// 成功返回 true，失败返回 false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        m_fd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> m_fd == <span class="number">-1</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭 socket</span></span><br><span class="line">    <span class="comment">// 成功返回 true，失败返回 false</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">close</span>(m_fd) == <span class="number">-1</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绑定 ip 和 port</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Bind</span><span class="params">(<span class="type">const</span> std::string&amp; ip, <span class="type">const</span> std::<span class="type">uint16_t</span>&amp; port)</span> </span>&#123;</span><br><span class="line">        sockaddr_in addr;</span><br><span class="line">        addr.sin_family = AF_INET;</span><br><span class="line">        addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(ip.<span class="built_in">c_str</span>());</span><br><span class="line">        addr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bind</span>(m_fd, (sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr)) == <span class="number">-1</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接收数据</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">RecvFrom</span><span class="params">(std::string* msg, std::string* ip=<span class="literal">nullptr</span>, std::<span class="type">uint16_t</span>* port=<span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        sockaddr_in peer;</span><br><span class="line">        <span class="type">socklen_t</span> peer_len = <span class="built_in">sizeof</span>(peer);</span><br><span class="line">        <span class="type">ssize_t</span> n = <span class="built_in">recvfrom</span>(m_fd, buf, <span class="built_in">sizeof</span>(buf) - <span class="number">1</span>, <span class="number">0</span>, (sockaddr*)&amp;peer, &amp;peer_len);</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *msg = buf;</span><br><span class="line">        <span class="keyword">if</span> (ip != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            *ip = <span class="built_in">inet_ntoa</span>(peer.sin_addr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (port != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            *port = <span class="built_in">ntohs</span>(peer.sin_port);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SendTo</span><span class="params">(<span class="type">const</span> std::string&amp; msg, <span class="type">const</span> std::string&amp; ip, <span class="type">const</span> std::<span class="type">uint16_t</span>&amp; port)</span> </span>&#123;</span><br><span class="line">        sockaddr_in addr;</span><br><span class="line">        addr.sin_family = AF_INET;</span><br><span class="line">        addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(ip.<span class="built_in">c_str</span>());</span><br><span class="line">        addr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">        <span class="type">ssize_t</span> n = <span class="built_in">sendto</span>(m_fd, msg.<span class="built_in">c_str</span>(), msg.<span class="built_in">size</span>(), <span class="number">0</span>, (sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">-1</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_fd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// __UDP_SOCKET__</span></span></span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回显客户端</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;udp_socket.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UdpSocket socket;</span><br><span class="line">    <span class="type">bool</span> ret = socket.<span class="built_in">Create</span>();</span><br><span class="line">    <span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Socket::Create()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        std::string input;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;input&gt; &quot;</span>;</span><br><span class="line">        std::cin &gt;&gt; input;</span><br><span class="line"></span><br><span class="line">        ret = socket.<span class="built_in">SendTo</span>(input, <span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>);</span><br><span class="line">        <span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;Socket::SendTo()&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        std::string resp;</span><br><span class="line">        ret = socket.<span class="built_in">RecvFrom</span>(&amp;resp);</span><br><span class="line">        <span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;Socket::RecvFrom()&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    socket.<span class="built_in">Close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：OK<br><img src="https://img-blog.csdnimg.cn/20200407163623280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhbm9pX2Fob2o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr><p>EOF</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Linux </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 Linux 上编写和调试多线程程序</title>
      <link href="/2020/03/30/%E5%9C%A8Linux%E4%B8%8A%E7%BC%96%E5%86%99%E5%92%8C%E8%B0%83%E8%AF%95%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F/"/>
      <url>/2020/03/30/%E5%9C%A8Linux%E4%B8%8A%E7%BC%96%E5%86%99%E5%92%8C%E8%B0%83%E8%AF%95%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>本文的环境：<br>Linux centos-7.shared 3.10.0-693.5.2.el7.x86_64 #1 SMP Fri Oct 20 20:32:50 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux<br>gcc 版本 4.8.5 20150623 (Red Hat 4.8.5-39) (GCC)</p><p>本文使用 POSIX 线程库，需引入头文件 <code>pthread.h</code>，在编译的时候要注意添加 <code>-lpthread</code> 参数。</p><blockquote><p>POSIX 是一个标准，约定一个操作系统应该提供哪些接口，pthread 即为 posix thread。C++11、Python、Java 均内置了线程库。</p></blockquote><h1 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="type">pthread_t</span> *thread, </span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span><br><span class="line"><span class="params"><span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), </span></span><br><span class="line"><span class="params"><span class="type">void</span> *arg</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数：</strong><br>thread 是一个输出型参数，返回一个线程 id。<br>attr 可以设置线程属性，填 NULL 表示使用默认属性。<br>start_routine 是一个函数指针，是线程执行的入口函数。<br>arg 是 start_routine 的函数参数。<br>值得注意的是这个函数 arg 是不支持传递多个参数的(可变参数)，如果需要传递多个函数就需要使用 struct 或者一些别的方式。</p><p><strong>返回值：</strong><br>成功返回 0，失败返回错误码。</p><p><strong>栗子：</strong><br>创建一个线程，传递一个参数，并在这个新线程内打印这个参数。<br><img src="https://img-blog.csdnimg.cn/20200330092037985.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhbm9pX2Fob2o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThreadArg</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">ThreadEntry</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;In ThreadEntry, %lu, arg %d\n&quot;</span>, pthread_self(), ((<span class="keyword">struct</span> ThreadArg*) arg)-&gt;num);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadArg</span> <span class="title">ta</span>;</span></span><br><span class="line">    ta.num = <span class="number">20</span>;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, ThreadEntry, &amp;ta);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;In Main Thread, %lu\n&quot;</span>, pthread_self());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==注意：==<br>上面代码中使用了 <code>pthread_self()</code> 获取线程的 id，这是 POSIX 线程库提供的库函数，操作系统也提供了一个获取线程 id 的系统调用 <code>gettid()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">gettid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>但是当你在同一个线程调用两个函数的时候发现返回的并不是相同的值。</p><blockquote><p>The  thread ID returned by this call is not the same thing as a POSIX thread ID.<br>(i.e., the opaque value returned by pthread_self(3)).<br>对于单线程的进程，内核中tid==pid，对于多线程进程，他们有相同的pid，不同的tid。tid用于描述内核真实的pid和tid信息。<br>pthread_self返回的是posix定义的线程ID，man手册明确说明了和内核线程tid不同。它只是用来区分某个进程中不同的线程，当一个线程退出后，新创建的线程可以复用原来的id。</p></blockquote><p><a href="https://blog.csdn.net/rsyp2008/article/details/45150621">gettid() 和 pthread_self()的区别</a></p><h1 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h1><p>想让一个线程结束而不终止进程：<br>1、从线程处理函数 <code>return</code>。<br>2、线程自己调用 <code>pthread_exit</code> 切腹自尽。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br></pre></td></tr></table></figure><p>参数：输入 &amp; 输出型参数。<br>==注意==：pthread_exit 参数所指向的内存单元必须是全局的或者是用malloc 分配的,不能在线程函数的栈上分配,因为当其它线程得到这个返回指针时线程函数已经退出了。</p><p>3、兄弟线程调用 <code>pthread_cancel</code> 终止同一进程中的另一个线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure><p>参数：线程 id<br>返回值：成功返回 0，失败返回错误码。<br>==注意==：这个 <code>pthread_cancel</code> 是温和的终止一个线程而不是强制 kill 掉，抽象一个例子就是你在召唤师峡谷杀敌ing，你妈喊你吃饭，你可能得等一会才过去吃饭。</p><h1 id="线程等待"><a href="#线程等待" class="headerlink" title="线程等待"></a>线程等待</h1><p>为什么要线程等待？<br>例如，计算一个很大的矩阵相乘，可以使用多线程方式来计算，每个线程计算其中的一部分，最终等待所有的线程执行完，主线程汇总结果，这里就用 pthread_join 来保证逻辑。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br></pre></td></tr></table></figure><p>参数：thread 线程 id，retval 指向一个指针，这个指针指向线程的返回值，不关注线程的返回值可以填 NULL。<br>返回值：成功返回 0，失败返回错误码。<br>调用该函数的线程将挂起等待,直到 id 为 thread 的线程终止。thread 线程以不同的方法终止,通过 pthread_join 得到 的终止状态是不同的：<br>1、如果thread线程通过 return 返回, value_ ptr 所指向的单元里存放的是thread线程函数的返回值。<br>2、如果thread线程被别的线程调用 pthread_cancel 异常终掉, value_ ptr 所指向的单元里存放的是常数 PTHREAD_CANCELED。<br>3、如果thread线程是自己调用 pthread_exit 终止的,value_ptr 所指向的单元存放的是传给 pthread_exit 的参数。</p><h1 id="线程分离"><a href="#线程分离" class="headerlink" title="线程分离"></a>线程分离</h1><p>类似于忽略 SIGCHLD 信号，分离后就代表线程的死活不管了，也就不用 <code>pthread_join</code> 回收了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure><p>可以自己把自己分离出去，也可以被兄弟线程分离。<br><code>pthread_detach(pthread_self());</code></p><h1 id="使用-gdb-调试多线程程序"><a href="#使用-gdb-调试多线程程序" class="headerlink" title="使用 gdb 调试多线程程序"></a>使用 gdb 调试多线程程序</h1><p>0、使用 gdb 调试多线程程序</p><p>使用 gdb 调试一个程序需要在编译时候加上 ==-g== 选项，为什么？百度去。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb attach 28966</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">info thread # 查看所有线程信息</span><br><span class="line">bt # 查看当前线程调用栈</span><br><span class="line">thread 2 # 切换当前线程</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200330094707969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhbm9pX2Fob2o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>1、查看一个程序的所有线程信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -eLf | grep a.out</span><br></pre></td></tr></table></figure><p>参数：-L 表示 LWP，这里 ps 得到的线程 id 是和 gettid 一样的。<br><img src="https://img-blog.csdnimg.cn/20200330093924969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhbm9pX2Fob2o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>2、查看一个程序依赖哪些库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd a.out</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200330093719264.png" alt="在这里插入图片描述"><br>3、查看一个进程中有几个线程和线程调用栈</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pstack 27779</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200330094132428.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhbm9pX2Fob2o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr><p>EOF</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程栈如何分配</title>
      <link href="/2020/03/27/%E7%BA%BF%E7%A8%8B%E6%A0%88%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D/"/>
      <url>/2020/03/27/%E7%BA%BF%E7%A8%8B%E6%A0%88%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<p>测试环境：<br>Linux centos-7.shared 3.10.0-693.5.2.el7.x86_64 #1 SMP Fri Oct 20 20:32:50 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux</p><p>一个进程的虚拟地址空间一般可以大致划分为代码区(text)、只读数据区(rodata)、初始化数据区(data)、为初始化数据区(bss)、堆(heap)、共享内存区(.so,mmap的地方)、栈(stack)、内核区(kernel)。</p><p><img src="https://img-blog.csdnimg.cn/20200326115352234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhbm9pX2Fob2o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>对于 Linux 进程或者说主线程，其 stack 是在 fork 的时候生成的，实际上就是复制了父亲的 stack 空间地址，然后写时拷贝 (cow) 以及动态增长。<br>然而对于主线程生成的子线程而言，其 stack 将不再是这样的了，而是事先固定下来的。<br>线程栈不能动态增长，一旦用尽就没了，这是和生成进程的 fork 不同的地方。</p><p>==线程（非主线程）的栈的大小是固定的==，其会在空闲的堆（堆顶附近自顶向下分配）或者是空闲栈（栈底附近自底向上分配），因此线程栈局部函数中分配的变量是存放到各自分配的栈空间，因此可以说是线程私有的，又因为该线程栈的边界是设定好的，因此该线程栈的大小的固定的。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><code>ulimit -a</code> 查看操作系统的相关限制：<br>可以看到 stack size 的限制是 8192kb 也就是 8MB。<br>注意这里的 8MB 是指每个被创建的 thread 的 stack 都是这么大。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[parallels@centos-7 LinuxCode]$ ulimit -a</span><br><span class="line">......</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>测试代码：<br>创建了 3 个 thread，执行 ThreadEntry。<br>编译后跑起来！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>*</span><br><span class="line"><span class="title function_">ThreadEntry</span><span class="params">(<span class="type">void</span>* args)</span></span><br><span class="line">&#123;</span><br><span class="line">    (<span class="type">void</span>) args;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2, tid3;</span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, ThreadEntry, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, ThreadEntry, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid3, <span class="literal">NULL</span>, ThreadEntry, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid3, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==从 heap 的顶部向下分配。==<br><code>ps aux | grep a.out</code>  查看 pid<br><code>cat /proc/[pid]/maps</code>  这个显示进程映射了的内存区域和访问权限。<br>可以看到：在 heap 下面连续的几个属性为 <code>rw-p</code> 的地址大小刚好都为 8192kb。并且每个都在边界穿插了一个大小为 1000H(4096kb) 的边界空间。</p><p><img src="https://img-blog.csdnimg.cn/20200327224927239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhbm9pX2Fob2o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>==从 stack 底部向上分配==<br><code>ulimit -s unlimited</code> 设置 stack size 为 unlimited，注意虽然设置了stack size为无限，但是实际上其并不是无限的，而也是固定大小的线程栈，大小为1mb。<br>然后 <code>cat /proc/[pid]/maps</code> 查看虚拟地址空间的映射。<br>可以看到，这种情况下线程栈是分配在 stack 底附近，自底向上生长的。<br><img src="https://img-blog.csdnimg.cn/20200327225518312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhbm9pX2Fob2o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200327225838477.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhbm9pX2Fob2o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>==不管线程栈是在堆分配还是在栈分配，其都是固定大小的，有边界的。==</p><hr><p>参考：<br><a href="https://blog.csdn.net/qq_16097611/article/details/82592873">https://blog.csdn.net/qq_16097611/article/details/82592873</a><br><a href="https://blog.csdn.net/yangkuanqaz85988/article/details/52403726?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task">https://blog.csdn.net/yangkuanqaz85988/article/details/52403726</a><br><a href="https://blog.csdn.net/lijzheng/article/details/23618365">https://blog.csdn.net/lijzheng/article/details/23618365</a></p><p>EOF</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程基础知识</title>
      <link href="/2020/03/27/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2020/03/27/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>本文测试代码的运行环境：<br>Centos7 x86_64<br>Kernel 3.10.0-693.5.2.el7.x86_64<br>gcc 版本 4.8.5<br>CPU：2 核</p><h2 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h2><p>线程是运行在进程之中的一个处理任务的分支，一个进程都包括一个主线程。<br>进程：资源分配、管理的基本单位（管理内存、管理打开的文件等）。<br>线程：调度、执行的基本单位。<br>在 Linux 中线程也叫做轻量级进程 ==LWP==。<br>每次创建一个新的进程，会分配一个新的虚拟地址空间。<br>每次创建一个新的线程，线程共用原来的虚拟地址空间。</p><blockquote><p>从 Linux 内核的角度来说，其实它并没有线程的概念。Linux 把所有线程都当做进程来实现，它将线程和进程不加区分的统一到了 task_struct 中。</p></blockquote><h3 id="线程之间共用的资源"><a href="#线程之间共用的资源" class="headerlink" title="线程之间共用的资源"></a>线程之间共用的资源</h3><ol><li>虚拟地址空间。</li><li>文件描述符表。</li></ol><blockquote><p>线程创建的时候，加上了 CLONE_VM 标记，这样==线程的内存描述符将直接指向父进程的内存描述符。==</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (clone_flags &amp; CLONE_VM) &#123;</span><br><span class="line"><span class="comment">// current 是父进程而 tsk 在 fork() 执行期间是共享子进程</span></span><br><span class="line">    <span class="type">atomic_inc</span>(&amp;current-&gt;mm-&gt;mm_users);</span><br><span class="line">    tsk-&gt;mm = current-&gt;mm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程之间不共用的资源"><a href="#线程之间不共用的资源" class="headerlink" title="线程之间不共用的资源"></a>线程之间不共用的资源</h3><ol><li>栈。</li><li>上下文信息（寄存器信息）。</li><li>errno（每个线程有自己单独的错误码）。</li></ol><blockquote><p>对于 Linux 进程或者说主线程，其 stack 是在 fork 的时候生成的，实际上就是复制了父亲的 stack 空间地址，然后写时拷贝 (cow) 以及动态增长。<br>然而对于主线程生成的子线程而言，其 stack 将不再是这样的了，而是事先固定下来的。<br>线程栈不能动态增长，一旦用尽就没了，这是和生成进程的 fork 不同的地方。</p></blockquote><h3 id="线程的优点"><a href="#线程的优点" class="headerlink" title="线程的优点"></a>线程的优点</h3><p>相比于进程来说：</p><ol><li>创建和销毁开销更小。</li><li>切换调度的开销更小。</li><li>线程占用的资源更小。</li></ol><p>多线程程序能够充分利用多核处理器。<br>栗子：==因为我的虚拟机是 2 核的，所以 CPU 最多使用是 200%==<br><img src="https://img-blog.csdnimg.cn/2020032611111093.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhbm9pX2Fob2o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="线程的缺点"><a href="#线程的缺点" class="headerlink" title="线程的缺点"></a>线程的缺点</h3><ol><li>程序的健壮性降低，一个线程的异常终止会导致整个进程异常终止。</li><li>编程 &amp;&amp; 调试难度增加（引入了线程安全问题）。</li></ol><h3 id="线程的用途"><a href="#线程的用途" class="headerlink" title="线程的用途"></a>线程的用途</h3><ol><li>提升 CPU 密集型程序执行效率。</li><li>提高 IO 密集型程序的体验。<ul><li>通过网络进行 IO。</li><li>响应 UI 界面。</li></ul></li></ol><hr><p>EOF</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基础知识</title>
      <link href="/2020/02/28/Redis%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2020/02/28/Redis%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>Redis 5.0.7。</p><p>Redis 常用命令、5 种数据类型。</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p><strong>DEL</strong> key【删除一个 key，所有类型都可以删除】</p><p><strong>DUMP</strong> key【序列化给定 key，返回被序列化的值】</p><p><strong>EXISTS</strong> key【判断 key 是否存在】</p><p><strong>EXPIRE</strong> key second【设置 key 的过期时间】</p><p><strong>TTL</strong> key 【查看 key 的剩余时间，默认 -1 表示永久，-2 表示已经过期】</p><p><strong>PERSIST</strong> key 【移除 key 的过期时间】</p><p><strong>KEY</strong> pattern 【查询给定模式的 key】</p><p><strong>RANDOMKEY</strong> 【随机返回一个 key】</p><p><strong>RANAME</strong> key newkey 【修改 key 的名称】</p><p><strong>MOVE</strong> key db 【将 key 移动到其他数据库中】</p><p><strong>TYPE</strong> key 【返回 key 所储存的值的类型】</p><p>注意：</p><ol><li><p><strong>KEY</strong> pattern 的 pattern 为 <code>*</code>代表所有，<code>?</code>代表单个字符。</p></li><li><p>key 可以是中文，例如：<code>set 你好 hello</code>，但是 redis-cli 显示不出来中文，查询时候得用中文查询。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; set 你好 hello</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[1]&gt; keys *</span><br><span class="line">1) &quot;\xe4\xbd\xa0\xe5\xa5\xbd&quot;</span><br><span class="line">2) &quot;a&quot;</span><br><span class="line">127.0.0.1:6379[1]&gt; get 你好</span><br><span class="line">&quot;hello&quot;</span><br></pre></td></tr></table></figure></li><li><p>key 不要太长，尽量不要超过 1024 字节。不仅消耗内存，也会降低查找的效率。</p></li><li><p>key 不要太短，太短可读性会降低。</p></li><li><p>一个项目中，key 最好使用统一的命名模式，如 user:123:password</p></li><li><p>key 区分大小写。</p></li></ol><p><strong>EXPIRE</strong> key second 的使用场景：</p><ol><li>限时的优惠活动</li><li>网站数据缓存</li><li>手机验证码</li><li>限制网站访客频率</li></ol><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><p>string 类型是二进制安全的，redis 的 string 可以包含任何数据，如图像、序列化对象。一个键最多能存储512MB。二进制安全是指，在传输数据的时候，能保证二进制数据的信息安全，也就是不会被篡改、破译；如果被攻击，能够及时检测出来。</p><ul><li><p>增</p><p><strong>SET</strong> key val</p><p><strong>SETNX</strong> key val【当 key 不存在时设置 key 的值（SET if Not eXists）】</p></li><li><p>删</p><p>删除就用 del 就可以咯</p></li><li><p>改</p><p><strong>INCR</strong> key【key 对应的 val 自增 1，如果 key 不存在，val 初始化为 0 再自增1】</p><p><strong>INCRBY</strong> key num【num 是增量】</p><p><strong>DECR</strong> key 【自减，同上 INCR】</p><p><strong>DECRBY</strong> key num 【num 是负增量】</p><p><strong>APPEND</strong> key val【字符串拼接，如果不存在则创建并赋值 val】</p><p><strong>GETSET</strong> key value【设定 key 的值，并返回 key 的旧值。当 key 不存在，返回 nil】</p></li><li><p>查</p><p><strong>GET</strong> key【获取 key 的 val】</p><p><strong>GETRANGE</strong> key start end【获取 key 中字符串的子字符串，从 start 开始，end 结束】</p><p><strong>MGET</strong> key1 [key2 …] 【获取多个 key】</p><p><strong>GETSET</strong> key value【设定 key 的值，并返回 key 的旧值。当 key 不存在，返回 nil】</p><p><strong>STRLEN</strong> key 【返回 key 对应 val 的字符串长度】</p></li></ul><p>string 类型的使用场景：</p><ol><li>String 通常用于保存单个字符串或 JSON 字符串数据。</li><li>因为 String 是二进制安全的，所以可以把保密要求高的图片文件内容作为字符串来存储。</li><li>计数器，常规 Key-Value 缓存应用，如微博数、粉丝数。INCR 本身就具有原子性特性，所以不会有线程安全问题。</li></ol><h4 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h4><p>Redis hash 是一个 string 类型的 field 和 value 的映射表，<strong>hash特别适用于存储对象</strong>。每个 hash 可以存储<code>2^32-1</code>个键值对。可以看成 key 和 value 的 map 容器。相比于 JSON，hash 占用很少的内存空间。</p><ul><li><p>增</p><p><strong>HSET</strong> key field value【为指定的 key 设定 field 和 value】</p><p><strong>HMSET</strong> key field value [field1 value1 …] 【为 key 增加多个 field value 映射】</p></li><li><p>删</p><p><strong>HDEL</strong> key field [field1 …]【删除一个或多个指定字段】</p></li><li><p>改</p><p>修改使用 HSET、HMSET 即可</p></li><li><p>查</p><p><strong>HGET</strong> key field【获取指定字段的 value】</p><p><strong>HMGET</strong> key field [field1 …] 【获取多个字段的 value】</p><p><strong>HGETALL</strong> key【返回 key 对应的所有的值】</p><p><strong>HKEYS</strong> key 【返回 key 对应的所有 field】</p><p><strong>HLEN</strong> key 【获取 field 的个数】</p></li></ul><p>注意：</p><ol><li><p>s 是一个 string 类型的数据 key，HSET 是不可以覆盖其数据的。</p></li><li><p>但是 h 是一个 hash 类型的数据 key，SET 是可以用字符串覆盖其中的数据的。</p></li><li><p>相比于存储对象的 string 类型的 json 串，json 串修改单个属性需要将整个值取出来。而 hash 不需要。</p></li><li><p>相比于多个 key-value 存储对象，hash 节省了很多内存空间。</p></li><li><p>如果 hash 的属性值被删除完，那么 hash 的 key 也会被 redis 删除。</p></li></ol><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>类似于 Java 中的 Linklist 类型。</p><ul><li><p>增</p><p><strong>LPUSH</strong> key val1 [val2 …]【头插法将 val 插入】</p><p><strong>RPUSH</strong> key val1 [val2 …]【尾插发将 val 插入】</p><p><strong>LPUSHX</strong> key val1 [val2 …]【从左侧插入值，如果 list 不存在，则不操作】</p><p><strong>RPUSHX</strong> key val1 [val2 …]【从右侧插入值，如果 list 不存在，则不操作】</p></li><li><p>删</p><p><strong>LPOP</strong> key【从左侧 pop 一个元素】</p><p><strong>RPOP</strong> key【从右侧 pop】</p><p><strong>BLPOP</strong> key [key1 …] timeout【移除并获取列表第一个元素，如果列表没有元素会阻塞列表到等待超时或发现可弹出元素为止，timeout 单位秒】</p><p><strong>BRPOP</strong> key [key1 …] timeout【类似上面】</p><p><strong>LTRIM</strong> key start stop【对列表进行修改，让列表只保留指定区间的元素，不在指定区间的元素就会被删除】</p></li><li><p>改</p><p><strong>LSET</strong> key index value【指定索引的值修改】</p><p><strong>LINSERT</strong> key BEFORE|AFTER pivot value【在列表元素前或则后插入元素】</p></li><li><p>查</p><p><strong>LLEN</strong> key【获取 key 对应的 list 长度】</p><p><strong>LINDEX</strong> key index【获取指定 index 的元素】</p><p><strong>LRANGE</strong> key start stop【获取列表指定范围的元素，stop 为 -1 表示最后一个，-2 表示倒数第二个…】</p></li><li><p>其他</p><p><strong>RPOPLPUSH</strong> list1 list2【移除 list1 最后一个元素，并将该元素添加到 list2 左边并返回此元素】</p><p>用此命令可以实现订单下单流程、用户系统登录注册短信等。</p></li></ul><p>应用场景：</p><ol><li><p>对数据大的集合数据删减</p><p>列表显示、关注列表、粉丝列表、留言评价…分页、热点新闻等。</p></li><li><p>任务队列</p><p>list 通常用来实现一个消息队列，而且可以确保先后顺序，不必像 MySQL 那样通过 order by 来排序。</p></li></ol><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>唯一、无序。</p><ul><li><p>增</p><p><strong>SADD</strong> key value1 [value2 …] 【向集合添加成员】</p></li><li><p>删</p><p><strong>SREM</strong> key member1 [member2 …]【移除集合中一个或多个成员】</p><p><strong>SPOP</strong> key【移除并返回集合中的一个随机元素】</p></li><li><p>改</p><p><strong>SMOVE</strong> source destination member【将member元素从source集合移动到destination集合】</p></li><li><p>查</p><p><strong>SCARD</strong> key【返回集合成员数】</p><p><strong>SMEMBERS</strong> key【返回集合中所有成员】</p><p><strong>SISMEMBER</strong> key member【判断 memeber 元素是否是集合 key 成员的成员】</p><p><strong>SRANDMEMBER</strong> key [count]【返回集合中一个或多个随机数】</p></li><li><p>其他</p><p><strong>SDIFF</strong> key1 key2【差集；集合1 - 集合2（集合1有的集合2没有的）】</p><p><strong>SDIFFSTORE</strong> destination key1 key2【返回集合差集并存储在 destination 中】</p><p><strong>SINTER</strong> key1 key2【交集】</p><p><strong>SINTERSTORE</strong> destination key1 key2【交集放在 dest 中】</p><p><strong>SUNION</strong> key1 key2【并集】</p><p><strong>SUNIONSTORE</strong> destination key1 key2【同理】</p></li></ul><p>对两个集合间的数据[计算]进行交集、并集、差集运算。</p><p>使用姿势：</p><ol><li><p>以非常方便的实现如共同关注、共同喜好、二度好友等功能。</p><p>对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存储到一个新的集合中。</p></li><li><p>利用唯一性，可以统计访问网站的所有独立 IP。</p></li></ol><h4 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h4><p>有序且不重复。每个元素都会关联一个 double 类型的分数，Redis 通过分数进行从小到大的排序。分数可以重复。</p><ul><li><p>增</p><p><strong>ZADD</strong> key score1 member1 [score2 member2 …]</p></li><li><p>删</p><p><strong>ZREM</strong> key member1 [member2 …]【移除指定元素】</p><p><strong>ZREMRANGE</strong> key start stop【移除有序集合中给定的排名区间的所有成员(第一名是0)(低到高排序）】</p><p><strong>ZREMRANGEBYSCORE</strong> key min max【移除有序集合中给定的分数区间的所有成员】</p></li><li><p>改</p></li><li><p>查</p><p><strong>ZCARD</strong> key【获取 key 中元素的数量】</p><p><strong>ZCOUNT</strong> key min max【计算在有序集合中指定区间（min-max）分数的成员数】</p><p><strong>ZRANK</strong> key member【返回元素的索引】</p><p><strong>ZRANGE</strong> key start stop【返回索引 start-stop 的元素，stop=-1 表示最后一个元素，从小到大】</p><p><strong>ZREVRANGE</strong> key start stop【从大到小】</p></li></ul><p>使用姿势：</p><ol><li>常用于排行榜（成绩、积分榜）。</li><li>还可以用 zset 来做带权重的队列，让重要的任务先执行。</li></ol><h3 id="其他功能特性"><a href="#其他功能特性" class="headerlink" title="其他功能特性"></a>其他功能特性</h3><h4 id="发布、订阅"><a href="#发布、订阅" class="headerlink" title="发布、订阅"></a>发布、订阅</h4><p>Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p><p>Redis 客户端可以订阅任意数量的频道。</p><p>比如：你和你的好兄弟都订阅了关注了共青团中央的频道，当共青团中央发送一条动态的时候你和你的好兄弟都会受到这条动态消息。</p><p>命令：</p><p><strong>SUBSCRIBE</strong> channel1 [channel2 …]【订阅一个或多个频道】</p><p><strong>PSUBSCRIBE</strong> pattern1 [pattern2 …]【订阅符合 pattern 的频道】</p><p><strong>PUBLISH</strong> channel message【向指定频道发送message】</p><p><strong>UNSUBSCRIBE</strong> [channel [channel …]]【退订指定频道】</p><p><strong>PUNSUBSCRIBE</strong> [pattern [pattern …]]【退订符合 pattern 的频道】</p><p>使用姿势：</p><ol><li>构建实时的消息系统，比如普通聊天、群聊等功能。</li><li>博客网站订阅，当作者发布就可以推送给粉丝。</li><li>微信公众号模式。</li></ol><h4 id="多数据库"><a href="#多数据库" class="headerlink" title="多数据库"></a>多数据库</h4><p><strong>SELECT</strong> db 切换到 db（0 ~ 15）</p><p><strong>MOVE</strong> key db 将 key 移动到某个 db</p><p><strong>FLUSHDB</strong> 清空当前数据库</p><p><strong>FLUSHALL</strong> 清空所有数据库</p><h4 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h4><p>事务可以一次执行多个命令，按顺序地串行化执行，执行过程中不允许其他命令插入执行序列中。</p><ol><li>Redis 会将一个事务中的所有命令序列化，然后按顺序执行。</li><li>执行中不会被其他命令插入，不允许加塞行为。</li></ol><p><strong>MULTI</strong> 标记一个事物的开始。</p><p><strong>DISCARD</strong> 取消事物，放弃执行事物块内的所有命令。</p><p><strong>EXEC</strong> 执行事物。</p><p><strong>WATCH</strong> key [key …] 监视一个/多个 key，如果事物执行之前 key 被其他命令所改动，那么事物将被打断。</p><p><strong>UNWATCH</strong> 取消 WATCH 命令对所有 key 的监视。</p><p>栗子1：正常用法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get account:a</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get account:b</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; DECRby account:a 50</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCRBY account:b 50</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec </span><br><span class="line">1) &quot;80&quot;</span><br><span class="line">2) &quot;10&quot;</span><br><span class="line">3) (integer) 30</span><br><span class="line">4) (integer) 60</span><br></pre></td></tr></table></figure><p>栗子2：类似于运行时错误</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MULTI </span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set hello hello</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; incr hello</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get hello</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec </span><br><span class="line">1) OK</span><br><span class="line">2) (error) ERR value is not an integer or out of range</span><br><span class="line">3) &quot;hello&quot;</span><br></pre></td></tr></table></figure><p>栗子3：类似于编译错误</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MULTI </span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set aaa 123</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; fsadadasd</span><br><span class="line">(error) ERR unknown command `fsadadasd`, with args beginning with: </span><br><span class="line">127.0.0.1:6379&gt; get aaa</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br></pre></td></tr></table></figure><p>栗子4：WATCH 被打断的用法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; WATCH account:b</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get account:b</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; incrby account:b 10</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">(nil)  # 在另一个终端改变了 account:b 的值，所以执行事物的结果是 nil</span><br></pre></td></tr></table></figure><h4 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h4><ol><li><p>RDB</p><p>RDB 是 Redis 默认持久化机制。RDB 相当于快照，保存的是一种状态。</p><p>保存速度、还原速度极快、适用于灾难备份。</p><p>小内存的机器不符合使用。RDB机制符合要求(配置文件中的规则)就会快照。</p></li><li><p>AOF</p><p>如果 Redis 意外 down 掉，RDB 方式会丢失最后一次快照后的所有修改。如果要求应用不能丢失任何修改，可以采用 AOF 持久化方式。</p><p>AOF：Append-Only File：Redis会将没一个收到写命令都追加到文件中（默认是appendonly.aof）。当Redis重启时会通过重新执行文件中的写命令重建整个数据库的内容。</p><p>产生问题：有些命令是多余的，比如执行了 100 次<code>incr num</code>，99 次都是多余的。</p></li></ol><hr><p>参考：</p><p><a href="https://blog.csdn.net/qq_33423418/article/details/101351944">https://blog.csdn.net/qq_33423418/article/details/101351944</a></p><hr><p>未完，待续。</p><p>EOF</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker实现基础技术</title>
      <link href="/2020/02/23/Docker%E5%AE%9E%E7%8E%B0%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/"/>
      <url>/2020/02/23/Docker%E5%AE%9E%E7%8E%B0%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Docker 是一个使用 Linux Namespace 和 Cgroups 的虚拟化工具。</p></blockquote><p>Linux Namespace 和 Cgroups 是什么？有什么用？在 Docker 中是怎么被使用的？</p><span id="more"></span><h3 id="Linux-Namespace"><a href="#Linux-Namespace" class="headerlink" title="Linux Namespace"></a>Linux Namespace</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>Linux Namespace 是 Kernel 的一个功能，它可以隔离一系列的系统资源（ProcessID、UserID、Network）。</p><p>PID 映射关系图：</p><p><img src="https://i.loli.net/2020/02/23/IroigdBzyC5NmTl.png" alt="image.png"></p><p>当前 Linux 一共实现了 6 种不同类型的 Namespace。</p><table><thead><tr><th>Namespace类型</th><th>系统调用参数</th><th>内核版本</th><th>功能说明</th></tr></thead><tbody><tr><td>Mount Namespace</td><td>CLONE_NEWNS</td><td>2.4.19</td><td>磁盘挂载点和文件系统的隔离能力</td></tr><tr><td>UTS Namespace</td><td>CLONE_NEWUTS</td><td>2.6.19</td><td>主机名隔离能力</td></tr><tr><td>IPC Namespace</td><td>CLONE_NEWIPC</td><td>2.6.19</td><td>进程间通信的隔离能力</td></tr><tr><td>PID Namespace</td><td>CLONE_NEWPID</td><td>2.6.24</td><td>进程隔离能力</td></tr><tr><td>Network Namespace</td><td>CLONE_NEWNET</td><td>2.6.29</td><td>网络隔离能力</td></tr><tr><td>User Namespace</td><td>CLONE_NEWUSER</td><td>3.8</td><td>用户隔离能力</td></tr></tbody></table><p>Namespace 的 API 主要使用如下 3 个系统调用：</p><ol><li>clone() 创建新进程。根据系统调用参数来判断哪些类型的 Namespace 被创建，而且它们的子进程也会被包含到这些 Namespace 中。</li><li>unshare() 将进程移除某个 Namespace。</li><li>setns() 将进程加入到 Namespace 中。</li></ol><h4 id="UTS-Namespace"><a href="#UTS-Namespace" class="headerlink" title="UTS Namespace"></a>UTS Namespace</h4><p>UTS Namespace 主要用来隔离 nodename 和 domainname 两个系统标识。</p><p>在 UTS Namespace 里面，每个 Namespace 允许有自己的 hostname。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_SIZE (1024 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> container_stack[STACK_SIZE];</span><br><span class="line"><span class="type">char</span>* <span class="type">const</span> container_args[] = &#123;</span><br><span class="line">   <span class="string">&quot;/bin/bash&quot;</span>,</span><br><span class="line">   <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 容器进程运行的程序主函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">container_main</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;在容器进程中！\n&quot;</span>);</span><br><span class="line">   execv(container_args[<span class="number">0</span>], container_args); <span class="comment">// 执行/bin/bash   return 1;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> args, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;程序开始\n&quot;</span>);</span><br><span class="line">   <span class="comment">// clone 容器进程</span></span><br><span class="line">   <span class="type">int</span> container_pid = clone(container_main, container_stack + STACK_SIZE, SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line">   <span class="comment">// 等待容器进程结束</span></span><br><span class="line">   waitpid(container_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序骨架调用 clone() 函数实现了子进程的创建工作，并定义子进程的执行函数，clone() 第二个参数指定了子进程运行的栈空间大小，第三个参数即为创建不同 namespace 隔离的关键。</p><p>对于 UTS namespace，传入 CLONE_NEWUTS，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> container_pid = clone(container_main, container_stack + STACK_SIZE, SIGCHLD | CLONE_NEWUTS, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>为了能够看出容器内和容器外主机名的变化，我们子进程执行函数中加入：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sethostname(<span class="string">&quot;container&quot;</span>, <span class="number">9</span>);</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/25/JSRmOz3sPvEWLAg.png" alt="image.png"></p><p>相关 Linux 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hostname <span class="comment"># 查看</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hostname -b xxx <span class="comment"># 可以改变当前的 hostname</span></span></span><br></pre></td></tr></table></figure><h4 id="IPC-Namespace"><a href="#IPC-Namespace" class="headerlink" title="IPC Namespace"></a>IPC Namespace</h4><p>IPC Namespace 用来隔离 System V IPC 和 POSIX message queues。（隔离进程间通信）</p><p>代码只需要修改一下 clone 的参数即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> container_pid = clone(container_main, container_stack + STACK_SIZE, SIGCHLD | CLONE_NEWUTS | CLONE_NEWIPC, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="https://i.loli.net/2020/02/25/AexERNX8tGirg1u.png" alt="image.png"></p><p>相关 Linux 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ipcs -q <span class="comment"># 查看现有的 ipc message queues</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ipcmk -Q <span class="comment"># 创建一个 msg queue</span></span></span><br></pre></td></tr></table></figure><h4 id="PID-Namespace"><a href="#PID-Namespace" class="headerlink" title="PID Namespace"></a>PID Namespace</h4><p>PID Namespace 是用来隔离进程 ID 的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> container_pid = clone(container_main, container_stack + STACK_SIZE, SIGCHLD | CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWPID, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>效果：PID 号，发生了变化；但是 ps 之类的没有发生变化。</p><blockquote><p>原因是 ps/top 之类的命令底层调用的是文件系统的 /proc 文件内容，由于 /proc 文件系统（procfs）还没有挂载到一个与原 /proc 不同的位置，自然在容器中显示的就是宿主机的进程。</p><p>在容器中重新挂载 /proc 即可实现隔离：<code>mount -t proc proc /proc</code>。</p><p>这种方式会破坏 root namespace 中的文件系统，当退出容器时，如果 ps 会出现错误，只有再重新挂载一次 /proc 才能恢复。</p><p>一劳永逸地解决这个问题最好的方法就是用 mount namespace。</p></blockquote><p><img src="https://i.loli.net/2020/02/25/LAqCwyXtWI9lmY1.png" alt="image.png"></p><p><img src="https://i.loli.net/2020/02/25/Tra6EBl1dpKuRqj.png" alt="image.png"></p><p>相关 Linux 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> $$ <span class="comment"># 输出当前 shell pid</span></span></span><br></pre></td></tr></table></figure><h4 id="Mount-Namespace"><a href="#Mount-Namespace" class="headerlink" title="Mount Namespace"></a>Mount Namespace</h4><p>通过隔离文件系统挂载点对隔离文件系统提供支持，它是历史上第一个Linux namespace，所以它的标识位比较特殊，就是CLONE_NEWNS。</p><blockquote><p>CLONE_NEWNS：New Namespace 的缩写，当时的人们貌似没有意识到，以后还会有很多类型的 Namespace 加入 Linux 家庭。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> container_pid = clone(container_main, container_stack + STACK_SIZE, SIGCHLD | CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWNS, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>注意内核版本问题导致的退出容器后需要重新挂载，参考：</p><p><a href="https://github.com/xianlubird/mydocker/issues/41">https://github.com/xianlubird/mydocker/issues/41</a></p><p>效果如下：实现了 ps / top 等的隔离。</p><p><img src="https://i.loli.net/2020/02/25/BhpgKSeRrb3oMCP.png" alt="image.png"></p><p>相关 Linux 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps</span></span><br></pre></td></tr></table></figure><h4 id="User-Namespace"><a href="#User-Namespace" class="headerlink" title="User Namespace"></a>User Namespace</h4><p>主要隔离了安全相关的标识符和属性，包括用户 ID、用户组 ID、root 目录、key 以及特殊权限。</p><p>简单说，就是一个普通用户的进程通过 clone() 之后在新的 user namespace 中可以拥有不同的用户和用户组，比如可能是超级用户。</p><p>同样，可以加入 CLONE_NEWUSER 参数来创建一个 User namespace。然后再子进程执行函数中加入 getuid() 和 getpid() 得到 namespace 内部的 User ID。</p><p>相关 Linux 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">id</span> <span class="comment"># 查看用户相关信息</span></span></span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br></pre></td></tr></table></figure><h4 id="Network-Namespace"><a href="#Network-Namespace" class="headerlink" title="Network Namespace"></a>Network Namespace</h4><p>Network namespace 实现了网络资源的隔离，包括网络设备、IPv4 和 IPv6 协议栈，IP 路由表，防火墙，/proc/net 目录，/sys/class/net 目录，套接字等。</p><p>Network Namespace 可以让每个容器拥有自己独立的（虚拟的）网络设备，而且容器内的应用可以绑定到自己的端口，每个 Namespace 内的端口都不会互相冲突。在宿主机上搭建网桥之后，就能很方便的实现容器之间的通信，而且不同容器上的应用可以使用相同的端口。</p><blockquote><p>Network namespace 不同于其他 namespace 可以独立工作，要使得容器进程和宿主机或其他容器进程之间通信，需要某种“桥梁机制”来连接彼此（并没有真正的隔离），这是通过创建 <strong>veth pair</strong> （虚拟网络设备对，有两端，类似于管道，数据从一端传入能从另一端收到，反之亦然）来实现的。当建立 Network namespace 后，内核会首先建立一个 docker0 网桥，功能类似于 Bridge，用于建立各容器之间和宿主机之间的通信，具体就是分别将 veth pair 的两端分别绑定到 docker0 和新建的 namespace 中。</p><p><img src="https://i.loli.net/2020/02/25/jp2cOhDstQAIuxw.png" alt="image.png"></p></blockquote><p><img src="https://i.loli.net/2020/02/25/ntDIVzN3BoOHMPq.png" alt="image.png"></p><h3 id="Linux-Cgroups"><a href="#Linux-Cgroups" class="headerlink" title="Linux Cgroups"></a>Linux Cgroups</h3><p>Linux Cgroups（Control Groups）提供了对一组进程及将来子进程的资源限制、控制和统计的能力。</p><p>这些组员包括：CPU、内存、存储、网络等。</p><p>通过 Cgroups，可以方便地限制某个进程资源占用，并且可以实时监控进程的监控和统计信息。</p><p>Cgroups 的 3 个组件：</p><ol><li><p>cgroup：是对进程分组管理的一种机制，一个 cgroup 包含一组进程，并可以在这个 cgroup 上增加 Linux subsystem 的各种参数配置，将一组进程和一组 subsystem 的系统参数关联起来。</p></li><li><p>subsystem：是一组资源控制的模块，一般包含如下几项：</p><ul><li><p>blkio 设置对块设备（比如硬盘）输入输出的访问控制。</p></li><li><p>cpu 设置 cgroup 中进程的 CPU 被调度的策略。</p></li><li><p>cpuacct 可以统计 cgroup 中进程的 CPU 占用。</p></li><li><p>cpuset 在多核机器上设置 cgroup 中进程可以使用的 CPU 和内存（此处内存仅用于 NUMA 架构）</p></li><li><p>devices 控制 cgroup 中进程对设备的访问。</p></li><li><p>freezer 用于挂起（suspend）和恢复（resume）cgroup 中的进程。</p></li><li><p>memory 用于控制 cgroup 中进程的内存占用。</p></li><li><p>net_cls 用于将 cgroup 中进程产生的网络包分类，以便 Linux 的 tc（traffic controller）可以根据分类区分出来自某个 cgroup 的包并做限流或监控。</p></li><li><p>net_prio 设置 cgroup 中进程产生的网络流量的优先级。</p></li><li><p>ns 这个 subsystem 比较特殊，它的作用是使 cgroup 中的进程在新的 Namespace 中 fork 新进程（NEWNS）时，创建出一个新的 cgroup，这个 cgroup 包含新的 Namespace 中的进程。</p></li></ul><p>每个 subsystem 会关联到定义了相应限制的 cgroup 上，并对这个 cgroup 中的进程做相应的限制和控制。这些 subsystem 是逐步合并到内核中的，如何看到当前的内核支持哪些 subsystem 呢？可以安装 cgroup 的命令行工具<code>apt-get install cgroup-bin</code>，然后通过<code>lssubsys -a</code>看到 Kernel 支持的 subsystem。</p></li><li><p>hierarchy 的功能是把一组 cgroup 串成一个树状的结构，一个这样的树便是一个 hierarchy，通过这种树状结构，Cgroups 可以做到继承。</p></li></ol><p>三个组件相互的关系：</p><ul><li>系统在创建了新的 hierarchy 之后，系统中所有的进程都会加入这个 hierarchy 的 cgroup 根节点，这个 cgroup 根节点是 hierarchy 默认创建的。</li><li>一个 subsystem 只能附加到一个 hierarchy 上面。</li><li>一个 hierarchy 可以附加多个 subsystem。</li><li>一个进程可以作为多个 cgroup 的成员，但是这些 cgroup 必须在不同的 hierarchy 中。</li><li>一个进程 fork 处子进程时，子进程是和父进程在同一个 cgroup 中的，也可以根据需要将其移动到其他 cgroup 中。</li></ul><p>Kernel 为了使对 Cgroups 的配置更直观，是通过一个虚拟的树状文件系统配置 Cgroups，通过层级的目录虚拟出 cgroup 树。</p><p>栗子：</p><ol><li><p>创建并挂在一个 hierarchy（cgroup 树），如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> cgroup-test <span class="comment"># 创建一个 hierarchy 挂载点</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo mount -t cgroup -o none,name=cgroup-test cgroup-test ./cgroup-test <span class="comment"># 挂在一个 hierarchy</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> ./cgroup-test <span class="comment"># 挂在后可以看到系统在这个目录下生成了一些默认文件</span></span></span><br></pre></td></tr></table></figure><p>这些文件就是这个 hierarchy 中 cgroup 根节点的配置项，文件含义分别如下：</p><ul><li>cgroup.clone_children：cpuset 的 subsystem 会读取这个配置文件，如果这个值是 1（默认是 0），子 cgroup 才会继承父 cgroup 的 cpuset 的配置。</li><li>cgroup.procs：树种当前节点 cgroup 中的进程组 ID，现在的位置是在根节点，这个文件中会有现在系统中所有进程组的 ID。</li><li>notify_on_release 和 release_agent 会一起使用。notify_on_release 标识当这个 cgroup 最后一个进程退出的时候是否执行了 release_agent；release_agent 则是一个路径，通常用作进程退出之后自动清理掉不再使用的 cgroup。</li><li>tasks：标识该 cgroup 下面的进程 ID，如果把一个进程 ID 写到 tasks 中，便会将相应的进程加入到这个 cgroup 中。</li></ul></li><li><p>然后在 cgroup-test 上 cgroup 根节点中扩展出的两个子 cgroup：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 cgroup-test 文件夹下</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> cgroup-1 <span class="comment"># 创建子 cgroup cgroup-1</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> cgroup-2 <span class="comment"># 创建子 cgroup cgroup-2</span></span></span><br></pre></td></tr></table></figure><p>在一个 cgroup 目录下创建文件夹时，Kernel 会把文件夹标记为这个 cgroup 的子 cgroup，他们会继承父 cgroup 的属性。</p></li><li><p>在 cgroup 中添加和移动进程。</p><p>一个进程在一个 Cgroups 的 hierarchy 中，只能在一个 cgroup 节点上存在，系统的所有进程都会默认在根节点上存在，可以将进程移动到其他 cgroup 节点，只需要将进程 ID 写到移动到的 cgroup 节点的 tasks 文件中即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 cgroup-1 文件夹下</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sh -c <span class="string">&quot;echo $$ &gt;&gt; tasks&quot;</span>  <span class="comment"># 将现在所在的终端移动到 cgroup-1中</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /proc/<span class="variable">$&#123;$$&#125;</span>/cgroup <span class="comment"># 可以看到所属 cgroup</span></span></span><br></pre></td></tr></table></figure></li><li><p>通过 subsystem 限制 cgroup 中进程的资源。</p><p>在上面创建 hierarchy 的时候，这个 hierarchy 并没有关联到任何 subsystem，所以没办法通过那个 hierarchy 中的 cgroup 节点限制进程的资源占用，其实系统默认已经为每个 subsystem 创建了一个默认的 hierarchy，比如 memory 的 hierarchy。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mount | grep memory  <span class="comment"># 可以看到目录的挂在情况</span></span></span><br></pre></td></tr></table></figure><p>下面通过在这个 hierarchy 中创建 cgroup，限制如下进程占用的内存。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">首先在不做限制的情况下，启动一个占用内存的 stress 进程</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">stress --vm-bytes 200m --vm-keep -m 1</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个 cgroup</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> test-limit-memory &amp;&amp; <span class="built_in">cd</span> test-limit-memory</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置最大 cgroup 的最大内存占用为 100MB</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sh -c <span class="string">&quot;echo &quot;</span>100m<span class="string">&quot; &gt; memory.limit_in_bytes&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将当前进程移动到这个 cgroup 中</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sh -c <span class="string">&quot;echo $$ &gt; tasks&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">再次运行占用内存 200MB 的 stress 进程</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">stress --vm-bytes 200m --vm-keep -m 1</span></span><br></pre></td></tr></table></figure></li></ol><hr><p>参考：</p><p>《自己动手写 Docker》</p><p><a href="https://blog.csdn.net/liumiaocn/article/details/52549659">https://blog.csdn.net/liumiaocn/article/details/52549659</a></p><p><a href="https://mp.weixin.qq.com/s/10HgkUE14wVI_RNmFdqkzA">https://mp.weixin.qq.com/s/10HgkUE14wVI_RNmFdqkzA</a></p><p><a href="https://github.com/xianlubird/mydocker/issues/41">https://github.com/xianlubird/mydocker/issues/41</a></p><hr><p>未完，EOF</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从B站偷小火箭</title>
      <link href="/2020/01/11/%E4%BB%8EB%E7%AB%99%E5%81%B7%E5%B0%8F%E7%81%AB%E7%AE%AD/"/>
      <url>/2020/01/11/%E4%BB%8EB%E7%AB%99%E5%81%B7%E5%B0%8F%E7%81%AB%E7%AE%AD/</url>
      
        <content type="html"><![CDATA[<p>非专业前端，自己写不出类似的动画，也懒得看，就直接取现成的吧~ 效果如下：</p><p><img src="https://i.loli.net/2020/01/11/fkl3VZNnJ1yYLd7.gif" alt="QQ20200111-220049-HD.gif"></p><span id="more"></span><ol><li><p>F12 进入坦克模式，选择对应元素。可以看到就是一个 div 加了样式，下来我们来找找样式。</p><p><img src="https://i.loli.net/2020/01/11/CpcHGd2IwzMtyS5.png" alt="image.png"></p></li><li><p>先找到图片，下载下来。可以看到就是一个静态的图片，没有火箭后面的🔥。</p><p><img src="https://i.loli.net/2020/01/11/4alIFzf8K5NrSms.png" alt="image.png"></p><p><img src="http://static.hdslb.com/bl2se/images/rocket_top.png"></p></li><li><p>我们来找找🔥是怎么弄得，鼠标移动上去后发现当鼠标移动到 div 时候 class 里多了一个 fly。</p><p>找到了动态效果：</p><p><img src="http://static.hdslb.com/bl2se/images/rocket_frame.png"></p></li><li><p>这下就明白了动画效果怎么生成啦~但是 CSS 这个东西太难了。还是找下b站现成的吧。</p><p>点进去后发下了 css，下载下来格式化一下。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.rocket-con</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">//static.hdslb.com/bl2se/images/rocket_top.png</span>);</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">175px</span>;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">99</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">490px</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.fly</span> &#123;</span><br><span class="line">    <span class="attribute">animation</span>: fly .<span class="number">4s</span> <span class="built_in">steps</span>(<span class="number">1</span>) infinite;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">//static.hdslb.com/bl2se/images/rocket_frame.png</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> fly &#123;</span><br><span class="line">    <span class="number">0%</span> &#123;</span><br><span class="line">        <span class="attribute">background-position</span>-x: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">25%</span> &#123;</span><br><span class="line">        <span class="attribute">background-position</span>-x: -<span class="number">150px</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">50%</span> &#123;</span><br><span class="line">        <span class="attribute">background-position</span>-x: -<span class="number">300px</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">75%</span> &#123;</span><br><span class="line">        <span class="attribute">background-position</span>-x: -<span class="number">450px</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">to</span> &#123;</span><br><span class="line">        <span class="attribute">background-position</span>-x: -<span class="number">600px</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>下来就是加入到自己的项目中~</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&quot;rocket&quot;</span> <span class="attr">class</span>=<span class="string">&quot;rocket-con&quot;</span> @<span class="attr">mouseout</span>=<span class="string">&quot;rocketStop&quot;</span> @<span class="attr">mouseover</span>=<span class="string">&quot;rocketFly&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 鼠标移动到火箭上时</span></span><br><span class="line"><span class="title function_">rocketFly</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">rocket</span>.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;fly&#x27;</span>);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 鼠标从火箭上移开时</span></span><br><span class="line"><span class="title function_">rocketStop</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">rocket</span>.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;fly&#x27;</span>);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>然后 OK 啦~</p></li></ol><hr><p>EOF</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FFmpeg常用命令</title>
      <link href="/2019/12/07/FFmpeg%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/12/07/FFmpeg%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<ol><li><p>基本信息查询命令</p></li><li><p>录制命令</p></li><li><p>分解/复用命令（对不同文件格式的转化）</p></li><li><p>处理原始数据命令</p></li><li><p>裁剪与合并命令</p></li><li><p>图片/视频互转命令</p></li><li><p>直播相关命令（推流）</p></li><li><p>各种滤镜命令</p></li></ol><span id="more"></span><h3 id="FFmpeg-处理音视频基本流程"><a href="#FFmpeg-处理音视频基本流程" class="headerlink" title="FFmpeg 处理音视频基本流程"></a>FFmpeg 处理音视频基本流程</h3><p><em><strong>很重要！！！</strong></em></p><p><img src="https://i.loli.net/2019/12/07/eNbAIaZ39WvEQmn.png" alt="e6f5762fef1e7d9c9e6d80da80c254bf.png"></p><h3 id="1、基本信息查询命令"><a href="#1、基本信息查询命令" class="headerlink" title="1、基本信息查询命令"></a>1、基本信息查询命令</h3><p><img src="https://i.loli.net/2019/12/07/7cXnSEweNvpxPuJ.png" alt="image.png"></p><h3 id="2、录制命令"><a href="#2、录制命令" class="headerlink" title="2、录制命令"></a>2、录制命令</h3><h4 id="录制屏幕"><a href="#录制屏幕" class="headerlink" title="录制屏幕"></a>录制屏幕</h4><p><strong>录制屏幕：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f avfoundation -i 1 -r 30 out.yuv</span><br></pre></td></tr></table></figure><p>-f: 是指使用 Mac 下的 avfoundation 库采集数据</p><p>avfoundation 是 Mac 下专门用于采集处理的</p><p>-i: 指的是输入是什么，1 代表的是屏幕设备的索引值，类似于文件描述符，摄像头是 0</p><p>-r: 指定帧率</p><p><strong>播放录制</strong></p><p>注意如果是 yuv 视频，必须是告诉 ffplay 宽高和帧率才可以播放。</p><p>参数是开始录制时 ffmpeg 的提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffplay -s 3360x2100 -pix_fmt uyvy422 out.yuv</span><br></pre></td></tr></table></figure><p>-s 是分辨率</p><p><strong>查询 avfoundation 所支持的设备列表：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f avfoundation -list_devices true -i &quot;&quot;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/12/07/uZLslrIvy3jhSNQ.png" alt="image.png"></p><h4 id="录制声音"><a href="#录制声音" class="headerlink" title="录制声音"></a>录制声音</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f avfoundation -i :0 out.wav</span><br></pre></td></tr></table></figure><p>:0 代表音频设备</p><p>播放录音：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffplay out.wav</span><br></pre></td></tr></table></figure><h3 id="3、分解-复用命令"><a href="#3、分解-复用命令" class="headerlink" title="3、分解/复用命令"></a>3、分解/复用命令</h3><p><img src="https://i.loli.net/2019/12/07/oiEvLnl4Qb8ZwjK.png" alt="image.png"></p><h4 id="多媒体格式转换"><a href="#多媒体格式转换" class="headerlink" title="多媒体格式转换"></a>多媒体格式转换</h4><p>处理方式为 copy，不改变编解码，原来是双声道拷贝过去还是双声道，aac 还是 aac：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.mp4 -vcodec copy -acodec copy out.flv</span><br></pre></td></tr></table></figure><p>-i：输入文件</p><p>-vcodec copy：视频编码处理方式</p><p>-acodec copy：音频编码处理方式</p><p>直接抽取视频：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.mov -an -vcodec copy out.h264</span><br></pre></td></tr></table></figure><p>-an：表示 -audio none</p><p>直接抽取音频：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.mov -vn -acodec copy out.aac</span><br></pre></td></tr></table></figure><h3 id="4、处理原始数据命令"><a href="#4、处理原始数据命令" class="headerlink" title="4、处理原始数据命令"></a>4、处理原始数据命令</h3><p>原始数据就是 ffmpeg 解码后的数据</p><p>对于视频就是 yuv 数据</p><p>对于音频就是 pcm 数据</p><h4 id="提取-yuv-数据"><a href="#提取-yuv-数据" class="headerlink" title="提取 yuv 数据"></a>提取 yuv 数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -an -c:v rawvideo -pix_fmt yuv420p out.yuv</span><br></pre></td></tr></table></figure><p>-an 表示不带音频数据</p><p>-c:v 表示对视频进行编码，使用 rawvideo 编码</p><p>-pix_fmt 原始数据必须制定像素格式，yuv 4：2：0，是常用的像素格式</p><h4 id="提取-PCM-数据"><a href="#提取-PCM-数据" class="headerlink" title="提取 PCM 数据"></a>提取 PCM 数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -vn -ar 44100 -ac 2 -f s16le out.pcm</span><br></pre></td></tr></table></figure><p>-vn 表示不要视频数据</p><p>-ar a表示audio r表示rate 音频采样率为 44100，44.1k</p><p>常用的采样率还有：48k 32k 16k</p><p>-ac2 audio channel 2 表示双声道</p><p>立体声就是3，还有环绕立体声</p><p>-f 表示抽取音频数据存储格式是 s15le s表示有符号，16表示每一个数值用16位表示 le 表示小头（小端？）</p><p>注意播放音频的时候还是一样，原始数据需要指定相关的采样率、声道数等才能播放</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffplay -ar 44100 -ac 2 -f s16le out.pcm</span><br></pre></td></tr></table></figure><h3 id="5、滤镜命令"><a href="#5、滤镜命令" class="headerlink" title="5、滤镜命令"></a>5、滤镜命令</h3><p>加减水印、画中画、裁剪等。</p><p><img src="https://i.loli.net/2019/12/07/3iGXAVgEkJm85fr.png" alt="image.png"></p><p>解码后的数据帧 -&gt; 滤镜 -&gt; 重新编码</p><h4 id="滤镜命令"><a href="#滤镜命令" class="headerlink" title="滤镜命令"></a>滤镜命令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i out.mp4 -vf crop=in_w-200:in_h-200 -c:v libx264 -c:a copy out.mp4</span><br></pre></td></tr></table></figure><p>-vf 视频滤镜 crop</p><p>后面是 crop 滤镜的参数</p><p>in_w 视频宽度-200</p><p>in_h 视频高度-200</p><p>-c:v 视频编码器 libx264</p><p>-c:a copy 不对音频做处理</p><h4 id="视频添加图片-文字水印"><a href="#视频添加图片-文字水印" class="headerlink" title="视频添加图片/文字水印"></a>视频添加图片/文字水印</h4><p><a href="https://www.jianshu.com/p/c0e151775075">https://www.jianshu.com/p/c0e151775075</a></p><p>添加图片水印：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i shanqiu.mp4 -vf &quot;movie=DB24ED44963ED81BA24EAD243F006DCE.JPG[watermark];[in][watermark] overlay=main_w-overlay_w-10:main_h-overlay_h-10[out]&quot; shuiyin.mp4</span><br></pre></td></tr></table></figure><p>在视频右下角的添加图片水印：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -i logo.png -filter_complex &#x27;overlay=main_w-overlay_w-10:main_h-overlay_h-10&#x27; output.mp4</span><br></pre></td></tr></table></figure><p>在视频左下角添加图片水印：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -i logo.png -filter_complex &#x27;overlay=x=10:y=main_h-overlay_h-10&#x27; output.mp4</span><br></pre></td></tr></table></figure><h3 id="6、裁剪与合并命令"><a href="#6、裁剪与合并命令" class="headerlink" title="6、裁剪与合并命令"></a>6、裁剪与合并命令</h3><p>裁剪</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i in.mp4 -ss 00:00:00 -t 10 out.mp4</span><br></pre></td></tr></table></figure><p>从 00:00:00 起始裁剪 10 秒，输出到 out.mp4</p><p>合并</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f concat -i inputs.txt out.flv</span><br></pre></td></tr></table></figure><p>-f concat 拼接</p><p>-i 后的参数是需要拼接的文件列表 inputs.txt 记录的是所有要拼接的视频列表</p><p>inputs.txt 里的内容为：</p><p><code>file &#39;filename.mp4&#39;</code> 格式</p><p>如：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file &#x27;1.mp4&#x27;</span><br><span class="line">file &#x27;2.mp4&#x27;</span><br></pre></td></tr></table></figure><h3 id="7、图片-视频互转命令"><a href="#7、图片-视频互转命令" class="headerlink" title="7、图片/视频互转命令"></a>7、图片/视频互转命令</h3><p>视频转图片：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i in.flv -r 1 -f image2 image-%3d.jpeg</span><br></pre></td></tr></table></figure><p>-r 每秒钟转换帧率</p><p>-f 表示将输入文件转成什么格式的 image2 表示一种图片格式</p><p>-%3d 表示由3个数字组成</p><p>图片转视频：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i image-%3d.jpeg out.mp4</span><br></pre></td></tr></table></figure><h3 id="8、直播相关命令"><a href="#8、直播相关命令" class="headerlink" title="8、直播相关命令"></a>8、直播相关命令</h3><p>直播推/拉流</p><p><strong>直播推流：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -i shanqiu.mp4 -c copy -f flv rtmp://server/live/streamName</span><br></pre></td></tr></table></figure><p>-re 减慢帧率速度，对于直播流来说让帧率与真正的帧率保持同步</p><p>-i 多媒体文件</p><p>-c 音视频编解码（音频 -a 视频 -v） copy</p><p>-f 指定推出去的文件格式 flv</p><p>后面是服务器地址</p><p>其他的端再从 rtmp 服务器上拉流就可以看到影像了。</p><p><strong>直播拉流：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i http://ivi.bupt.edu.cn/hls/cctv1hd.m3u8 -c copy a.m3u8</span><br></pre></td></tr></table></figure><p>直接可以用 ffplay 看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffplay http://ivi.bupt.edu.cn/hls/cctv6hd.m3u8</span><br></pre></td></tr></table></figure><p><strong>推流方法：</strong></p><ol><li><p>自己搭建 NGINX 服务器，然后推流上去</p></li><li><p>bilibili 上推流</p></li></ol><p><a href="https://blog.csdn.net/dizhanguang5696/article/details/101183247">OSX下面用ffmpeg抓取桌面以及摄像头推流进行直播</a></p><hr><p>EOF</p>]]></content>
      
      
      <categories>
          
          <category> FFmpeg </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FFmpeg </tag>
            
            <tag> 音视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebRTC之实现1v1音视频通话</title>
      <link href="/2019/12/05/WebRTC%E4%B9%8B%E5%AE%9E%E7%8E%B01v1%E9%9F%B3%E8%A7%86%E9%A2%91%E9%80%9A%E8%AF%9D/"/>
      <url>/2019/12/05/WebRTC%E4%B9%8B%E5%AE%9E%E7%8E%B01v1%E9%9F%B3%E8%A7%86%E9%A2%91%E9%80%9A%E8%AF%9D/</url>
      
        <content type="html"><![CDATA[<p>打通一下 1v1 音视频通话的流程。</p><span id="more"></span><h3 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h3><p><strong>端到端连接基本流程：</strong></p><p><img src="https://i.loli.net/2019/12/03/TtMIasBHrgNvCz9.png"></p><p><strong>客户端信令消息设计：</strong></p><ul><li>join 加入房间</li><li>leave 离开房间</li><li>message 端到端消息<ul><li>offer 消息</li><li>answer 消息</li><li>candidate 消息</li></ul></li></ul><p><strong>服务端信令消息设计：</strong></p><ul><li>joined 已成功加入房间</li><li>otherjoin 其他用户加入此房间</li><li>full 要加入的房间已满</li><li>leave 已成功离开房间</li><li>bye 对方离开房间</li></ul><p><strong>消息处理流程：</strong></p><p><img src="https://i.loli.net/2019/12/05/nrZkav6oHbGgWS8.png" alt="image.png"></p><p><strong>客户端状态机：</strong></p><p><img src="https://i.loli.net/2019/12/05/mHawtVu2xoRZsUP.png" alt="image.png"></p><p><strong>客户端加入相关流程：</strong></p><p><img src="https://i.loli.net/2019/12/05/daQnA6g2J4xNsKM.png" alt="image.png"></p><p><strong>客户端离开流程图：</strong></p><p><img src="https://i.loli.net/2019/12/05/IAy2Eojdfil1mPh.png" alt="image.png"></p><h3 id="代码逻辑"><a href="#代码逻辑" class="headerlink" title="代码逻辑"></a>代码逻辑</h3><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><ol><li><p>网页加载完毕，用户初始状态为<code>init</code>。</p><img src="https://i.loli.net/2019/12/05/FIEcn6xfHpTbv5r.png" style="zoom:25%;" /></li><li><p>点击连接按钮，进入 start() 函数，获取权限并开启本地音视频，然后进入 conn() 函数和信令服务器建立连接，并向信令服务器发送一个 join 信号，当收到服务器返回的 joined 后，客户端的状态变为 joined 。然后执行 createPeerConnection() 函数，创建 pc 并绑定媒体流，等待第二个人加入。注意：addTrack 将采集的音视频轨道添加并发送给远端。</p><img src="https://i.loli.net/2019/12/05/mKHGJR721al5qBf.png" alt="image.png" style="zoom:25%;" /></li><li><p>当有第二个人点击连接按钮，执行完上述步骤后，第一个人的客户端会收到信令服务器发来的一个 otherjoin 信号，这时会触发 call() 函数。在 call() 中执行 createOffer() ，在创建 offer 成功后 setLocalDescription，并将创建好的 desc 信息发给信令 message 给信令服务器。</p><blockquote><p>setLocalDescription 调用后底层会悄悄地向 sturn/turn 服务器发送一个 bind request，这个时候就开始收集所有能和对方连接的候选者了。</p></blockquote><p>当服务器收到 message 后，会将其原封不动的转发给房间内除发送者外的其他成员：</p><p><code>socket.to(room).emit(&#39;message&#39;, room, data); // 给房间出自己外所有人回消息</code></p></li><li><p>然后第二个人会收到信令服务器发来的 message 信息，信息中的 <code>data.type===&#39;offer&#39;</code>。</p><p>下来第二个人的客户端会执行 setRemoteDescription，然后 createAnswer，并 setLocalDescription，最后讲创建的 answer 以 message 信息。同样，信令服务器收到这个 answer 后还是原封不动的转发给了第一个连接的人。</p></li><li><p>第一个人在收到 answer 后 setRemoteDescription，这样两个人的 SDP 就交换好了。</p><p><img src="https://i.loli.net/2019/12/05/gnqZImlSVCbB4HY.png"></p></li><li><p>已经根据SDP信息创建好本地的相关 Channel 后会开启Candidate数据的收集，接收由 TURN 服务器收集好的 candidate 信息。</p></li><li><p>当 candidate 到达第一个连接的人那后会触发 onicecandidate，第一个人的客户端会将这个 candidate 发送给信令服务器，信令服务器发给第二个进来的人，第二个进来的人会 addIceCandidate，然后会触发自己的 onicecandidate，再给信令服务器，信令服务器再给第一个进来的人。</p></li><li><p>这样两个人就建立了音视频传输的P2P通道，接收对方传送过来的 MediaStream 对象并渲染出来。</p></li><li><p>onTrack 监听音视频数据的到达，到达后执行 getRemoteStream。</p><p><img src="https://i.loli.net/2019/12/05/4GvtAI3Ld12wRlc.png"></p></li><li><p>当其他人再加入时，信令服务器发现此房间已满，会发送一个 full 信号，提示当前房间已满，并关闭 pc 和本地音视频流的 Track。</p></li></ol><h4 id="离开"><a href="#离开" class="headerlink" title="离开"></a>离开</h4><p>离开的逻辑就简单一些了。</p><p>先向服务器发送 leave 信令，收到 leaved 后变更状态然后关闭pc，关闭媒体流。</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>网络连接要在音视频流数据获取之后，否则有可能绑定音视频流失败。</p><p>当一端退出房间后，另一端的 PeerConnection 要关闭重建，否则与新用户互通的时候媒体协商失败。</p><p>异步事件处理。</p><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><h5 id="Client-html"><a href="#Client-html" class="headerlink" title="Client.html"></a>Client.html</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Room<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;main.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;preview&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Local:<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">video</span> <span class="attr">id</span>=<span class="string">&quot;localvideo&quot;</span> <span class="attr">autoplay</span> <span class="attr">playsinline</span> <span class="attr">muted</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"></span><br><span class="line">          <span class="tag">&lt;<span class="name">label</span>&gt;</span>Offer SDP:</span><br><span class="line">            <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">&quot;textarea_offer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;connserver&quot;</span>&gt;</span>连接<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;leave&quot;</span> <span class="attr">disabled</span>&gt;</span>离开<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Remote:<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">video</span> <span class="attr">id</span>=<span class="string">&quot;remotevideo&quot;</span> <span class="attr">autoplay</span> <span class="attr">playsinline</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"></span><br><span class="line">          <span class="tag">&lt;<span class="name">label</span>&gt;</span>Answer SDP:</span><br><span class="line">            <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">&quot;textarea_answer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/socket.io/2.3.0/socket.io.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/webrtc-adapter/zv4.1.1/adapter.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;room.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="Client-js"><a href="#Client-js" class="headerlink" title="Client.js"></a>Client.js</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> btnConn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button#connserver&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> btnLeave = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button#leave&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> localVideo = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;video#localvideo&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> remoteVideo = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;video#remotevideo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> localStream = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> remoteStream = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> roomid = <span class="string">&#x27;111111&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> socket = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> state = <span class="string">&#x27;init&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pc = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> textarea_offer = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;textarea#textarea_offer&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> textarea_answer = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;textarea#textarea_answer&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pcConfig = &#123;</span><br><span class="line">  <span class="string">&#x27;iceServers&#x27;</span>: [&#123;</span><br><span class="line">    <span class="string">&#x27;urls&#x27;</span>: <span class="string">&#x27;turn:ahoj.luoshaoqi.cn:3478&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;credential&#x27;</span>: <span class="string">&#x27;xxxxxx&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;xxxxxx&#x27;</span></span><br><span class="line">  &#125;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">btnConn.<span class="property">onclick</span> = connSignalServer;</span><br><span class="line">btnLeave.<span class="property">onclick</span> = leave;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">connSignalServer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 开启本地音视频设备</span></span><br><span class="line">  <span class="title function_">start</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">start</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!navigator.<span class="property">mediaDevices</span> || !navigator.<span class="property">mediaDevices</span>.<span class="property">getUserMedia</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;不支持&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> constraints = &#123;</span><br><span class="line">      <span class="attr">video</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">audio</span>: <span class="literal">true</span></span><br><span class="line">    &#125;;</span><br><span class="line">    navigator.<span class="property">mediaDevices</span>.<span class="title function_">getUserMedia</span>(constraints)</span><br><span class="line">        .<span class="title function_">then</span>(getMediaStream)</span><br><span class="line">        .<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">error</span>(e);</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getMediaStream</span>(<span class="params">stream</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (localStream) &#123;</span><br><span class="line">    stream.<span class="title function_">getAudioTracks</span>().<span class="title function_">forEach</span>(<span class="function">(<span class="params">track</span>) =&gt;</span> &#123;</span><br><span class="line">      localStream.<span class="title function_">addTrack</span>(track);</span><br><span class="line">      stream.<span class="title function_">removeTrack</span>(track);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    localStream = stream;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  localVideo.<span class="property">srcObject</span> = localStream;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">conn</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 信令部分 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">conn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  socket = io.<span class="title function_">connect</span>();  <span class="comment">// 与信令服务器连接</span></span><br><span class="line"></span><br><span class="line">  socket.<span class="title function_">on</span>(<span class="string">&#x27;joined&#x27;</span>, <span class="function">(<span class="params">roomid, id</span>) =&gt;</span> &#123;</span><br><span class="line">    state = <span class="string">&#x27;joined&#x27;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;receive msg: joined&#x27;</span>, roomid, id, <span class="string">&#x27;state = &#x27;</span>, state);</span><br><span class="line">    <span class="title function_">createPeerConnection</span>();</span><br><span class="line"></span><br><span class="line">    btnConn.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">    btnLeave.<span class="property">disabled</span> = <span class="literal">false</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  socket.<span class="title function_">on</span>(<span class="string">&#x27;otherjoin&#x27;</span>, <span class="function">(<span class="params">roomid, id</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (state === <span class="string">&#x27;joined_unbind&#x27;</span>) &#123;</span><br><span class="line">      <span class="title function_">createPeerConnection</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state = <span class="string">&#x27;joined_conn&#x27;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;receive msg: otherjoin&#x27;</span>, roomid, id, <span class="string">&#x27;state = &#x27;</span>, state);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">call</span>();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  socket.<span class="title function_">on</span>(<span class="string">&#x27;full&#x27;</span>, <span class="function">(<span class="params">roomid, id</span>) =&gt;</span> &#123;</span><br><span class="line">    state = <span class="string">&#x27;leaved&#x27;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;receive msg: full&#x27;</span>, roomid, id, <span class="string">&#x27;state = &#x27;</span>, state);</span><br><span class="line"></span><br><span class="line">    socket.<span class="title function_">disconnect</span>();</span><br><span class="line">    <span class="title function_">closeLocalMedia</span>();</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;房间已满&#x27;</span>);</span><br><span class="line">    btnConn.<span class="property">disabled</span> = <span class="literal">false</span>;</span><br><span class="line">    btnLeave.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  socket.<span class="title function_">on</span>(<span class="string">&#x27;leaved&#x27;</span>, <span class="function">(<span class="params">roomid, id</span>) =&gt;</span> &#123;</span><br><span class="line">    state = <span class="string">&#x27;leaved&#x27;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;receive msg: leaved&#x27;</span>, roomid, id, <span class="string">&#x27;state = &#x27;</span>, state);</span><br><span class="line"></span><br><span class="line">    socket.<span class="title function_">disconnect</span>();</span><br><span class="line">    btnConn.<span class="property">disabled</span> = <span class="literal">false</span>;</span><br><span class="line">    btnLeave.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  socket.<span class="title function_">on</span>(<span class="string">&#x27;bye&#x27;</span>, <span class="function">(<span class="params">roomid, id</span>) =&gt;</span> &#123;</span><br><span class="line">    state = <span class="string">&#x27;joined_unbind&#x27;</span>;</span><br><span class="line">    <span class="title function_">closePeerConnection</span>();</span><br><span class="line">    textarea_offer.<span class="property">value</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    textarea_answer.<span class="property">value</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;receive msg: bye&#x27;</span>, roomid, id, <span class="string">&#x27;state = &#x27;</span>, state);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  socket.<span class="title function_">on</span>(<span class="string">&#x27;disconnect&#x27;</span>, <span class="function">(<span class="params">socket</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;disconnect message&#x27;</span>, roomid);</span><br><span class="line">    <span class="keyword">if</span> (!(state === <span class="string">&#x27;leaved&#x27;</span>)) &#123;</span><br><span class="line">      <span class="title function_">hangup</span>();</span><br><span class="line">      <span class="title function_">closeLocalMedia</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    state = <span class="string">&#x27;leaved&#x27;</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  socket.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">roomid, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;receive msg: message&#x27;</span>, roomid, data);</span><br><span class="line">    <span class="comment">/* 媒体协商 */</span></span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">      <span class="keyword">if</span> (data.<span class="property">type</span> === <span class="string">&#x27;offer&#x27;</span>) &#123;</span><br><span class="line">        textarea_offer.<span class="property">value</span> = data.<span class="property">sdp</span>;</span><br><span class="line"></span><br><span class="line">        pc.<span class="title function_">setRemoteDescription</span>(<span class="keyword">new</span> <span class="title class_">RTCSessionDescription</span>(data));</span><br><span class="line"></span><br><span class="line">        pc.<span class="title function_">createAnswer</span>()</span><br><span class="line">            .<span class="title function_">then</span>(getAnswer)</span><br><span class="line">            .<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="variable language_">console</span>.<span class="title function_">error</span>(e);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.<span class="property">type</span> === <span class="string">&#x27;answer&#x27;</span>) &#123;</span><br><span class="line">        textarea_answer.<span class="property">value</span> = data.<span class="property">sdp</span>;</span><br><span class="line">        pc.<span class="title function_">setRemoteDescription</span>(<span class="keyword">new</span> <span class="title class_">RTCSessionDescription</span>(data));</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.<span class="property">type</span> === <span class="string">&#x27;candidate&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> candidate = <span class="keyword">new</span> <span class="title class_">RTCIceCandidate</span>(&#123;</span><br><span class="line">          <span class="attr">sdpMLineIndex</span>: data.<span class="property">label</span>,</span><br><span class="line">          <span class="attr">candidate</span>: data.<span class="property">candidate</span></span><br><span class="line">        &#125;);</span><br><span class="line">        pc.<span class="title function_">addIceCandidate</span>(candidate);</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;data type error&#x27;</span>);</span><br><span class="line">        <span class="comment">// console.log(data);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  socket.<span class="title function_">emit</span>(<span class="string">&#x27;join&#x27;</span>, <span class="string">&#x27;111111&#x27;</span>);  <span class="comment">// 加入房间 111111</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hangup</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (pc) &#123;</span><br><span class="line">    pc.<span class="title function_">close</span>();</span><br><span class="line">    pc = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 退出时关闭 track 流 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">closeLocalMedia</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (localStream &amp;&amp; localStream.<span class="title function_">getTracks</span>()) &#123;</span><br><span class="line">    localStream.<span class="title function_">getTracks</span>().<span class="title function_">forEach</span>(<span class="function">(<span class="params">track</span>) =&gt;</span> &#123;</span><br><span class="line">      track.<span class="title function_">stop</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  localStream = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">leave</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (socket) &#123;</span><br><span class="line">    socket.<span class="title function_">emit</span>(<span class="string">&#x27;leave&#x27;</span>, <span class="string">&#x27;111111&#x27;</span>);  <span class="comment">// 离开房间 111111</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 释放资源 */</span></span><br><span class="line">  <span class="title function_">closePeerConnection</span>();</span><br><span class="line">  <span class="title function_">closeLocalMedia</span>();</span><br><span class="line"></span><br><span class="line">  textarea_offer.<span class="property">value</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  textarea_answer.<span class="property">value</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  btnConn.<span class="property">disabled</span> = <span class="literal">false</span>;</span><br><span class="line">  btnLeave.<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createPeerConnection</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;create RTCPeerConnection!&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!pc) &#123;</span><br><span class="line">    pc = <span class="keyword">new</span> <span class="title class_">RTCPeerConnection</span>(pcConfig);</span><br><span class="line"></span><br><span class="line">    pc.<span class="property">onicecandidate</span> = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (e.<span class="property">candidate</span>) &#123;</span><br><span class="line">        <span class="title function_">sendMessage</span>(roomid, &#123;</span><br><span class="line">          <span class="attr">type</span>: <span class="string">&#x27;candidate&#x27;</span>,</span><br><span class="line">          <span class="attr">label</span>: event.<span class="property">candidate</span>.<span class="property">sdpMLineIndex</span>,</span><br><span class="line">          <span class="attr">id</span>: event.<span class="property">candidate</span>.<span class="property">sdpMid</span>,</span><br><span class="line">          <span class="attr">candidate</span>: event.<span class="property">candidate</span>.<span class="property">candidate</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this is the end candidate&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    pc.<span class="property">ontrack</span> = getRemoteStream;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;the pc have be created&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((localStream !== <span class="literal">null</span> || localStream !== <span class="literal">undefined</span>) &amp;&amp; (pc !== <span class="literal">null</span> || pc !== <span class="literal">undefined</span>)) &#123;</span><br><span class="line">    localStream.<span class="title function_">getTracks</span>().<span class="title function_">forEach</span>(<span class="function">(<span class="params">track</span>) =&gt;</span> &#123;</span><br><span class="line">      pc.<span class="title function_">addTrack</span>(track, localStream);  <span class="comment">// 进行添加, 并发送给远端。</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;pc or localStream is null or undefined&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">/* createPeerConnection */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">closePeerConnection</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;close RTCPeerConnection!&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (pc) &#123;</span><br><span class="line">    pc.<span class="title function_">close</span>();</span><br><span class="line">    pc = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getRemoteStream</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  remoteStream = e.<span class="property">streams</span>[<span class="number">0</span>];</span><br><span class="line">  remoteVideo.<span class="property">srcObject</span> = e.<span class="property">streams</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">call</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (state === <span class="string">&#x27;joined_conn&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> options = &#123;</span><br><span class="line">      <span class="attr">offerToReceiveVideo</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">offerToReceiveAudio</span>: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    pc.<span class="title function_">createOffer</span>(options)</span><br><span class="line">        .<span class="title function_">then</span>(getOffer)</span><br><span class="line">        .<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">error</span>(e);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getOffer</span>(<span class="params">desc</span>) &#123;</span><br><span class="line">  pc.<span class="title function_">setLocalDescription</span>(desc);</span><br><span class="line">  textarea_offer.<span class="property">value</span> = desc.<span class="property">sdp</span>;</span><br><span class="line">  <span class="title function_">sendMessage</span>(roomid, desc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getAnswer</span>(<span class="params">desc</span>) &#123;</span><br><span class="line">  pc.<span class="title function_">setLocalDescription</span>(desc);</span><br><span class="line">  textarea_answer.<span class="property">value</span> = desc.<span class="property">sdp</span>;</span><br><span class="line">  <span class="title function_">sendMessage</span>(roomid, desc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sendMessage</span>(<span class="params">roomid, data</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;send p2p message&#x27;</span>, roomid, data);</span><br><span class="line">  <span class="keyword">if</span> (socket) &#123;</span><br><span class="line">    socket.<span class="title function_">emit</span>(<span class="string">&#x27;message&#x27;</span>, roomid, data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Signal-Server"><a href="#Signal-Server" class="headerlink" title="Signal Server"></a>Signal Server</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> https = <span class="built_in">require</span>(<span class="string">&#x27;https&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> serveIndex = <span class="built_in">require</span>(<span class="string">&#x27;serve-index&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> socketIo = <span class="built_in">require</span>(<span class="string">&#x27;socket.io&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = <span class="title function_">express</span>();</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">serveIndex</span>(<span class="string">&#x27;./public&#x27;</span>));</span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(<span class="string">&#x27;./public&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// http server</span></span><br><span class="line"><span class="keyword">var</span> http_server = http.<span class="title function_">createServer</span>(app);</span><br><span class="line">http_server.<span class="title function_">listen</span>(<span class="number">8087</span>, <span class="string">&#x27;0.0.0.0&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// https server</span></span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  <span class="attr">key</span>: fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;./cret/xxx.key&#x27;</span>),</span><br><span class="line">  <span class="attr">cert</span>: fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;./cret/xxx.pem&#x27;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> https_server = https.<span class="title function_">createServer</span>(options, app);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> io = socketIo.<span class="title function_">listen</span>(https_server);</span><br><span class="line">io.<span class="property">sockets</span>.<span class="title function_">on</span>(<span class="string">&#x27;connection&#x27;</span>, <span class="function">(<span class="params">socket</span>) =&gt;</span> &#123;</span><br><span class="line">  socket.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">room, data</span>) =&gt;</span> &#123;</span><br><span class="line">    io.<span class="title function_">in</span>(room).<span class="title function_">emit</span>(<span class="string">&#x27;message&#x27;</span>, room, data);  <span class="comment">// socket.to(room).emit(&#x27;message&#x27;, room, data);</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;[message] room:&#x27;</span>, room, <span class="string">&#x27;data:&#x27;</span>, data);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  socket.<span class="title function_">on</span>(<span class="string">&#x27;join&#x27;</span>, <span class="function">(<span class="params">room</span>) =&gt;</span> &#123;</span><br><span class="line">    socket.<span class="title function_">join</span>(room);</span><br><span class="line">    <span class="keyword">var</span> myRoom = io.<span class="property">sockets</span>.<span class="property">adapter</span>.<span class="property">rooms</span>[room];</span><br><span class="line">    <span class="keyword">var</span> users = <span class="title class_">Object</span>.<span class="title function_">keys</span>(myRoom.<span class="property">sockets</span>).<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (users &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">      socket.<span class="title function_">emit</span>(<span class="string">&#x27;joined&#x27;</span>, room, socket.<span class="property">id</span>);  <span class="comment">// 发消息给房间里除自己之外的所有人</span></span><br><span class="line"></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;[joined] room:&#x27;</span>, room, <span class="string">&#x27;user_id:&#x27;</span>, socket.<span class="property">id</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (users &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        socket.<span class="title function_">to</span>(room).<span class="title function_">emit</span>(<span class="string">&#x27;otherjoin&#x27;</span>, room, socket.<span class="property">id</span>);</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;[otherjoin] room:&#x27;</span>, room, <span class="string">&#x27;user_id:&#x27;</span>, socket.<span class="property">id</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      socket.<span class="title function_">leave</span>(room);</span><br><span class="line">      socket.<span class="title function_">emit</span>(<span class="string">&#x27;full&#x27;</span>, room, socket.<span class="property">id</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;[otherjoin] room:&#x27;</span>, room, <span class="string">&#x27;user_id:&#x27;</span>, socket.<span class="property">id</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  socket.<span class="title function_">on</span>(<span class="string">&#x27;leave&#x27;</span>, <span class="function">(<span class="params">room</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(room);</span><br><span class="line">    <span class="keyword">var</span> myRoom = io.<span class="property">sockets</span>.<span class="property">adapter</span>.<span class="property">rooms</span>[room];</span><br><span class="line">    socket.<span class="title function_">to</span>(room).<span class="title function_">emit</span>(<span class="string">&#x27;bye&#x27;</span>, room, socket.<span class="property">id</span>);</span><br><span class="line">    socket.<span class="title function_">emit</span>(<span class="string">&#x27;leaved&#x27;</span>, room, socket.<span class="property">id</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;[otherjoin] room:&#x27;</span>, room, <span class="string">&#x27;user_id:&#x27;</span>, socket.<span class="property">id</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">https_server.<span class="title function_">listen</span>(<span class="number">443</span>, <span class="string">&#x27;0.0.0.0&#x27;</span>);</span><br></pre></td></tr></table></figure><hr><p>其他参考资料：</p><p><a href="https://cloud.tencent.com/developer/article/1480648">https://cloud.tencent.com/developer/article/1480648</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/RTCPeerConnection/ontrack">https://developer.mozilla.org/zh-CN/docs/Web/API/RTCPeerConnection/ontrack</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/RTCPeerConnection/onicecandidate">https://developer.mozilla.org/zh-CN/docs/Web/API/RTCPeerConnection/onicecandidate</a></p><p><a href="https://hpbn.co/webrtc/#establishing-a-peer-to-peer-connection">https://hpbn.co/webrtc/#establishing-a-peer-to-peer-connection</a></p><p><a href="https://www.cnblogs.com/fangkm/p/4364553.html">https://www.cnblogs.com/fangkm/p/4364553.html</a></p><hr><p>EOF</p>]]></content>
      
      
      <categories>
          
          <category> WebRTC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音视频 </tag>
            
            <tag> WebRTC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebRTC端对端传输基本流程</title>
      <link href="/2019/12/03/WebRTC%E7%AB%AF%E5%AF%B9%E7%AB%AF%E4%BC%A0%E8%BE%93%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B/"/>
      <url>/2019/12/03/WebRTC%E7%AB%AF%E5%AF%B9%E7%AB%AF%E4%BC%A0%E8%BE%93%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>WebRTC 端对端连接的基本流程解析。</p><span id="more"></span><p>A：客户端 A，发起端<br>B：客户端 B，被呼叫端<br>Signal：信令服务器<br>sturn/turn：STUN/TURN 服务器</p><p>传输步骤：媒体协商、链路连接、媒体数据传输。</p><p><img src="https://i.loli.net/2019/12/03/TtMIasBHrgNvCz9.png"></p><ol><li><p>首先 A、B 需要和信令服务器建立连接。</p></li><li><p>发送端 A 创建一个 RTCPeerConnection。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pc1 = <span class="keyword">new</span> <span class="title class_">RTCPeerConnection</span>();</span><br></pre></td></tr></table></figure></li><li><p>发送端 A 拿到本地的流 Add Stream 到连接中去。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">localStream.<span class="title function_">getTracks</span>().<span class="title function_">forEach</span>(<span class="function">(<span class="params">track</span>) =&gt;</span> &#123;</span><br><span class="line">  pc1.<span class="title function_">addTrack</span>(track, localStream);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>发送端 A 创建一个 Offer，并设置到 setLocalDescription 中，setLocalDescription 调用后会向 sturn/turn 服务器发送一个 bind request，这个时候就开始收集所有能和对方连接的候选者了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> offerOptions = &#123;</span><br><span class="line">  <span class="attr">offerToReceiveVideo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">offerToReceiveAudio</span>: <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line">pc1.<span class="title function_">createOffer</span>(offerOptions)</span><br><span class="line">      .<span class="title function_">then</span>(getOffer)</span><br><span class="line">      .<span class="title function_">catch</span>(handelCreateOfferError);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getOffer</span>(<span class="params">desc</span>) &#123;</span><br><span class="line">  pc1.<span class="title function_">setLocalDescription</span>(desc);</span><br><span class="line">  <span class="comment">// 发送 SDP Offer 给信令服务器：send desc.sdp;</span></span><br><span class="line">  <span class="comment">// 信令服务器会把这个 SDP Offer 发给能连接的接收端 B</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接收端 B 收到信令服务器发来的 A 的 SDP Offer 后，创建一个 PeerConnection，并 setRemoteDescription 将收到的 sdp 设置进去。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pc2 = <span class="keyword">new</span> <span class="title class_">RTCPeerConnection</span>();</span><br><span class="line">pc2.<span class="title function_">setRemoteDescription</span>(desc);</span><br></pre></td></tr></table></figure></li><li><p>然后接收端 B 需要给一个应答，创建一个 Answer 并设置到 B 的 LocalDescription，这个时候会向 sturn/turn 服务发送一个 bind request，然后接收端 B 再将自己的 SDP Answer 发送给 Signal 服务器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pc2.<span class="title function_">setLocalDescription</span>(desc);</span><br><span class="line">pc2.<span class="title function_">createAnswer</span>()</span><br><span class="line">  .<span class="title function_">then</span>(getAnswer)</span><br><span class="line">  .<span class="title function_">catch</span>(handleAnsError);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getAnswer</span>(<span class="params">desc</span>) &#123;</span><br><span class="line">  pc2.<span class="title function_">setLocalDescription</span>(desc);</span><br><span class="line">  <span class="comment">// 发送 pc2 的 sdp answer 给 signal 服务器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Signal 服务器收到接收端 B 的 SDP Answer 后会将这个 answer 发给端 A，端 A 收到 B 的 answer 后续设置 RemoteDescription。至此，A 和 B 的媒体协商算是完成了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// recieve SDP Answer from Signal Server</span></span><br><span class="line">pc1.<span class="title function_">setRemoteDescription</span>(desc);</span><br></pre></td></tr></table></figure></li><li><p>发送端 A 会收到一个 sturn/turn 服务器发来的 Candidate，这个 Candidate 就是服务器收集的能和对方建立连接的候选者了。然后 A 将这个 Candidate 发送给 Signal 服务器，通过信令服务器转给 B 端，B 收到之后续将这个 Candidate 添加进去。</p><p>同样的道理，当 B 端收到 sturn/turn 服务器发来的 Candidate，会将这个 Candidate 通过 Signal 转发给 A，A 将收到的 B 的候选者列表 Add 进去。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pc1.<span class="property">onicecandidate</span> = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  pc2.<span class="title function_">addIceCandidate</span>(e.<span class="property">candidate</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">pc2.<span class="property">onicecandidate</span> = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  pc1.<span class="title function_">addIceCandidate</span>(e.<span class="property">candidate</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时就 A、B 双方都已经收到了 Candidate，底层开始 pair，做排序和连接检测。</p><p>当找到最优的一个线路后，A、B 开始通信。</p><p>A 将数据流发送给 B，B 收到后将数据 AddStream，才能把音视频数据向上抛出进行渲染。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pc2.<span class="property">ontrack</span> = getRemoteStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getRemoteStream</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  remoteVideo.<span class="property">srcObject</span> = e.<span class="property">streams</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><p>EOF</p>]]></content>
      
      
      <categories>
          
          <category> WebRTC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebRTC </tag>
            
            <tag> 音视频处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebRTC获取音视频设备</title>
      <link href="/2019/11/29/WebRTC%E8%8E%B7%E5%8F%96%E9%9F%B3%E8%A7%86%E9%A2%91%E8%AE%BE%E5%A4%87/"/>
      <url>/2019/11/29/WebRTC%E8%8E%B7%E5%8F%96%E9%9F%B3%E8%A7%86%E9%A2%91%E8%AE%BE%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<p>使用 navigator.mediaDevices.enumerateDevices() 即可获取音视频设备相关信息。</p><p>创建如下文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── client.js</span><br><span class="line">└── index.html</span><br></pre></td></tr></table></figure><span id="more"></span><p>重点在 client.js 中。</p><h3 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>获取音视频设备<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;client.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="client-js"><a href="#client-js" class="headerlink" title="client.js"></a>client.js</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印设备类型、标签、id、组id等</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getDevice</span>(<span class="params">deviceInfos</span>) &#123;</span><br><span class="line">  deviceInfos.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">deviceInfo</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;kind: &quot;</span> + deviceInfo.<span class="property">kind</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;label: &quot;</span> + deviceInfo.<span class="property">label</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;deviceId: &quot;</span> + deviceInfo.<span class="property">deviceId</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;groupId: &quot;</span> + deviceInfo.<span class="property">groupId</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误处理</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handelErr</span>(<span class="params">err</span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!navigator.<span class="property">mediaDevices</span> || !navigator.<span class="property">mediaDevices</span>.<span class="property">enumerateDevices</span>) &#123;</span><br><span class="line">  <span class="comment">// 不支持</span></span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&#x27;不支持&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 支持</span></span><br><span class="line">  navigator.<span class="property">mediaDevices</span>.<span class="title function_">enumerateDevices</span>()</span><br><span class="line">      .<span class="title function_">then</span>(getDevice)</span><br><span class="line">      .<span class="title function_">catch</span>(handelErr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><p>当前的设备是 MacOS Sierra + Chrome 浏览器，经过测试，以上代码获取设备 label 时总会为空。</p><p>原因：</p><p>浏览器 <strong>未</strong> 提示用户当前页面正在获取音视频设备相关权限，需要获取音视频设备的访问权限后才可获取到 label 相关信息。</p><p>解决方法：</p><p>在使用 navigator.mediaDevices.getUserMedia() 方法时候浏览器会提示用户获取相关权限是否同意。</p><p><img src="https://i.loli.net/2019/11/30/Zv2bWmJ5KG1hSXI.png"></p><hr><p>EOF</p>]]></content>
      
      
      <categories>
          
          <category> WebRTC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebRTC </tag>
            
            <tag> 音视频处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJS搭建基础服务器</title>
      <link href="/2019/11/29/NodeJS%E6%90%AD%E5%BB%BA%E5%9F%BA%E7%A1%80%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2019/11/29/NodeJS%E6%90%AD%E5%BB%BA%E5%9F%BA%E7%A1%80%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>学习 WebRTC 需要一个基础的服务器，使用 Node.js 搭建一个基础的服务器。</p><p>服务器可用的有很多：Nginx、Apache、Node.js、Tomcat 等。</p><p>环境：Centos7 64</p><span id="more"></span><h3 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h3><p>一般通过包管理器安装是比较方便的，如果包管理器源上没有相关软件可选择源码编译安装。</p><p>Centos 通过 yum 安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo yum install nodejs</span></span><br></pre></td></tr></table></figure><p>源码安装参见官网和百度。</p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>HTTPS = HTTP + TLS/SSL。</p><p>WebRTC 使用需要 HTTPS（按照网上的说法，没有只能在 localhost 跑）。</p><p>购买一个域名并备案（我借的学长的二级域名，解析到我的服务器上了）。</p><p>在域名提供商那里申请 SSL 证书，下载到服务器上。</p><h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><p>需要用到的包 http、https、fs、express、serve-index。</p><p>后两个是需要 npm install 的，注意安装时如果想安装在全局需要加 -g 选项。</p><p>express 模块是 Node.js 中写 Web 服务器需要的一个模块。</p><p>serve-inde 模块是将整个目录发布出来用的，需要指定发布目录，代码中指定目录为 <code>./public</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> https = <span class="built_in">require</span>(<span class="string">&#x27;https&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> serveIndex = <span class="built_in">require</span>(<span class="string">&#x27;serve-index&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> app = <span class="title function_">express</span>();</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">serveIndex</span>(<span class="string">&#x27;./public&#x27;</span>));</span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(<span class="string">&#x27;./public&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// http server</span></span><br><span class="line"><span class="keyword">let</span> http_server = http.<span class="title function_">createServer</span>(app);</span><br><span class="line">http_server.<span class="title function_">listen</span>(<span class="number">8087</span>, <span class="string">&#x27;0.0.0.0&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// https server</span></span><br><span class="line"><span class="keyword">let</span> options = &#123;  <span class="comment">// 这里配置 SSL 证书地址</span></span><br><span class="line"><span class="attr">key</span>: fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;./cret/3162249_ahoj.luoshaoqi.cn.key&#x27;</span>),</span><br><span class="line"><span class="attr">cert</span>: fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;./cret/3162249_ahoj.luoshaoqi.cn.pem&#x27;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> https_server = https.<span class="title function_">createServer</span>(options, app);</span><br><span class="line">https_server.<span class="title function_">listen</span>(<span class="number">443</span>, <span class="string">&#x27;0.0.0.0&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node app.js</span><br><span class="line">nohup node app.js  # 可以去了解一下 nohup 和 &amp; 的区别</span><br><span class="line">foever start app.js  # 需要 npm install forever -g</span><br></pre></td></tr></table></figure><hr><p>EOF</p>]]></content>
      
      
      <categories>
          
          <category> WebRTC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> WebRTC </tag>
            
            <tag> 音视频处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程概念</title>
      <link href="/2019/11/26/%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5/"/>
      <url>/2019/11/26/%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h3 id="描述进程"><a href="#描述进程" class="headerlink" title="描述进程"></a>描述进程</h3><p>进程信息被放在一个叫做进程控制块(PCB，process control block)的数据结构中，可以理解为进程属性的集合。 </p><p>Linux 下的 PCB 是 task_struct，GitHub 上 Linux 源码的 <a href="https://github.com/torvalds/linux/blob/master/include/linux/sched.h">/include/linux/sched.h</a> 中。</p><p>关于 task_struct 详细一些的中文资料可以参看：<a href="https://blog.csdn.net/jurrah/article/details/3965437">task_struct 数据结构</a></p><span id="more"></span><h4 id="task-struct-的内容"><a href="#task-struct-的内容" class="headerlink" title="task_struct 的内容"></a>task_struct 的内容</h4><p>标识符：唯一的标识一个进程，PID；</p><p>状态：任务状态、进程退出码、退出信号等；</p><p>优先级：现对于其他进程的优先级；</p><p>程序计数器：程序中即将被执行的下一条指令的地址；</p><p>内存指针：包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针；</p><p>上下文数据：进程执行时处理器的寄存器中的数据；</p><blockquote><p>保存上下文：CPU 寄存器的内容保存到内存中；<br>恢复上下文：从内存中读入寄存器的值。</p></blockquote><p>I/O 信息：包括显示的 I/O 请求，分配给进程的 I/O 设备和被进程使用的文件列表；</p><p>记账信息：可能包括处理器时间总和，使用的时钟数总和，时间限制，记账号等；</p><p>其他信息。</p><h3 id="组织进程"><a href="#组织进程" class="headerlink" title="组织进程"></a>组织进程</h3><p>在Linux系统中，所有运行在系统里的进程都是 task_struct 链表(双向链表)的形式存在内核里。</p><p><img src="https://i.loli.net/2019/11/26/oHwaW2IyDlfB8tx.png"></p><h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><p>在 Linux 下可以在 /proc 中查看到文件形式的进程。</p><p>也可以通过 ps、top 命令查看进程。</p><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p><a href="https://github.com/torvalds/linux/blob/master/fs/proc/array.c">/fs/proc/array.c</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The task state array is a strange &quot;bitmap&quot; of * reasons to sleep. Thus &quot;running&quot; is zero,</span></span><br><span class="line"><span class="comment"> * and you can test for combinations of others with simple bit tests.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> task_state_array[] = &#123;</span><br><span class="line"><span class="string">&quot;R (running)&quot;</span>, <span class="comment">/* 0 */</span></span><br><span class="line"><span class="string">&quot;S (sleeping)&quot;</span>, <span class="comment">/* 1 */</span></span><br><span class="line"><span class="string">&quot;D (disk sleep)&quot;</span>, <span class="comment">/* 2 */</span></span><br><span class="line">  <span class="string">&quot;T (stopped)&quot;</span>, <span class="comment">/* 4 */</span></span><br><span class="line"><span class="string">&quot;t (tracing stop)&quot;</span>, <span class="comment">/* 8 */</span> </span><br><span class="line">  <span class="string">&quot;X (dead)&quot;</span>, <span class="comment">/* 16 */</span></span><br><span class="line"><span class="string">&quot;Z (zombie)&quot;</span>, <span class="comment">/* 32 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>R</strong>unning 运行状态，表明进程要么在运行中要么在运行队列里，并不意味着一定在运行中；</p><p><strong>S</strong>leeping 睡眠状态 TASK_INTERRUPTIBLE，意味着进程在等待事件完成；</p><p><strong>D</strong>isk sleep 磁盘休眠状态 TASK_UNINTERRUPTIBLE，有时候也叫不可中断睡眠状态或深度睡眠状态，在这个状态的进程通常会等待 IO 结束，一般在密集的进行 IO 操作的时候会出现，程序在临死前吐 core dump 就会出现 D 状态；</p><p><strong>T</strong> stopped 停止状态，可以通过发送 SIGSTOP 信号来停止进程，这个被暂停的进程可以通过发送 SIGCONT 信号让其继续运行（ctrl + z挂起，fg 再回来）；</p><p><strong>t</strong>racing stop 跟踪状态，在 GDB 调试的时候出现；</p><p><strong>Z</strong>ombie 僵尸状态，僵尸进程的特征；</p><p><strong>X</strong> dead 死亡状态，进程结束，只在源码中可以看到。</p><p>上面这些状态在 Linux 内核源码中可以看到定义，在操作系统调度进程的过程中进程有三种基本状态：运行、阻塞、就绪。（还有一些资料有说三态模型、五态模型、七态模型）</p><h4 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h4><p>子进程结束后，父进程没有回收子进程的资源。</p><p><img src="http://www.linuxidc.com/upload/2011_08/110813060135422.gif"></p><p>僵尸进程的危害：</p><p>进程的退出状态必须被维持下去，因为他要告诉关心它的进程(父进程)，你交给我的任务，我办的怎么样了。这样就会导致一些数据需要一直被维护着，造成内存资源的浪费，内存泄漏。</p><p>避免产生僵尸进程：</p><ol><li>进程等待（wait、waitpid）</li><li><a href="https://www.cnblogs.com/tangr206/articles/3158685.html">fork 两次避免僵尸进程</a></li></ol><h4 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h4><p>父进程结束，但是子进程还未结束，子进程就成为了一个孤儿进程，由 init 进程收养并回收。</p><p><img src="http://www.linuxidc.com/upload/2011_08/110813060135421.gif"></p><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>不同类型的操作系统中进程调度的算法是不同的。</p><p><a href="https://blog.csdn.net/qq_35642036/article/details/82809812">操作系统中的进程调度策略</a></p><p>批处理系统常用调度算法：<br>①、先来先服务：FCFS<br>②、最短作业优先<br>③、最短剩余时间优先<br>④、响应比最高者优先</p><p>分时系统调度算法：<br>①、轮转调度<br>②、优先级调度<br>③、多级队列调度<br>④、彩票调度</p><p>实时系统调度算法：<br>①、单比率调度<br>②、限期调度<br>③、最少裕度法</p><h3 id="进程的优先级"><a href="#进程的优先级" class="headerlink" title="进程的优先级"></a>进程的优先级</h3><p>进程的优先级在操作系统中通常用于进程的调度。</p><p>top 命令可以查看当前系统上运行的进程信息，其中 PR 那一列就是对应进程的优先级。</p><p>在 Linux 中 PR 越小优先级越高，NI(nice) 表示修正值，最终系统认定的优先级是 PR + NI。</p><p>通过指令可以调整 nice 值，但是宏观一般看不出太大效果。</p><blockquote><p>top 进入后按 r 输入进程 PID 输入 nice 值。</p><p>更多资料：<a href="https://www.cnblogs.com/lcword/p/8267342.html">https://www.cnblogs.com/lcword/p/8267342.html</a></p></blockquote><h3 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a><a href="%5Bhttps://ahoj.cc/2019/06/%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/%5D(https://ahoj.cc/2019/06/%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/)">进程地址空间</a></h3><p><strong>栈有多大？</strong></p><p>测试方法：开数组进程测试</p><p>栈空间 8MB，由于被其他东西占用了一部分，所以不到 8MB。栈的大小是可以通过 ulimit 设置的。</p><p><strong>堆有多大？</strong></p><p>非常大~~~</p><p>32 位系统：4GB，上限取决于内存条（钱），如果是 16 GB 电脑，堆可能有 10 多GB。</p><p><strong>什么时候用栈？什么时候用堆？</strong></p><p>如果是小对象，并且需要频繁创建和销毁，推荐在栈上分配。<br>栈上分配内存更高效（esp寄存器的修改，esp-4）；<br>堆上分配内存就很复杂了，查阅malloc底层实现；<br>如果是大对象，必须在堆上分配。</p><p><strong>如果是很大的对象又要频繁使用那怎么办？</strong></p><p>内存池！！<br>（类似的有进程池、线程池、数据库连接池……）</p><hr><p>EOF</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统调用和库函数</title>
      <link href="/2019/11/26/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E5%BA%93%E5%87%BD%E6%95%B0/"/>
      <url>/2019/11/26/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E5%BA%93%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>在开发角度，操作系统对外会表现为一个整体，但是会暴露自己的部分接口，供上层开发使用，这部分由操作系统提供的接口，叫做系统调用。 比如在操作系统中退出一个进程用到的<code>_exit()</code>就属于系统调用。</p><p>系统调用在使用上，功能比较基础，对用户的要求相对也比较高，所以，有心的开发者可以对部分系统调用进行适度封装，从而形成库，有了库，就很有利于更上层用户或者开发者进行二次开发。 </p><span id="more"></span><p><img src="https://i.loli.net/2019/11/26/Ve6vxDR5E3sOILn.png"></p><p><img src="https://i.loli.net/2019/11/26/I3Cg6hDxvrfV5bd.png"></p><p>在 Linux 中，可以使用 man 手册来查看系统命令(如 ls、ping、vi)和一些标准 C 函数，还可以查看一些系统调用。使用<code>man man</code>可以查看 man 手册的使用方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">MANUAL SECTIONS</span><br><span class="line">       The standard sections of the manual include:</span><br><span class="line"></span><br><span class="line">       1      User Commands</span><br><span class="line"></span><br><span class="line">       2      System Calls</span><br><span class="line"></span><br><span class="line">       3      C Library Functions</span><br><span class="line"></span><br><span class="line">       4      Devices and Special Files</span><br><span class="line"></span><br><span class="line">       5      File Formats and Conventions</span><br><span class="line"></span><br><span class="line">       6      Games et. Al.</span><br><span class="line"></span><br><span class="line">       7      Miscellanea</span><br><span class="line"></span><br><span class="line">       8      System Administration tools and Deamons</span><br><span class="line"></span><br><span class="line">       Distributions  customize  the  manual section to their specifics, which</span><br><span class="line">       often include additional sections.</span><br></pre></td></tr></table></figure><blockquote><p>更多资料：<a href="https://www.cnblogs.com/liwei0526vip/p/8998751.html">https://www.cnblogs.com/liwei0526vip/p/8998751.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MapReduce和Hive工作流程</title>
      <link href="/2019/11/16/MapReduce%E5%92%8CHive%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/"/>
      <url>/2019/11/16/MapReduce%E5%92%8CHive%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>MapReduce 和 Hive 工作流程。 </p><span id="more"></span><p><strong>Hive 执行流程</strong></p><ol><li><p>(执行查询操作)Execute Query<br>命令行或Web UI之类的Hive接口将查询发送给Driver(任何数据库驱动程序，如JDBC、ODBC等)以执行。</p></li><li><p>(获取计划任务)Get Plan<br>Driver借助查询编译器解析查询，检查语法和查询计划或查询需求</p></li><li><p>(获取元数据信息)Get Metadata<br>编译器将元数据请求发送到Metastore(任何数据库)。</p></li><li><p>(发送元数据)Send Metadata<br>Metastore将元数据作为对编译器的响应发送出去。</p></li><li><p>(发送计划任务)Send Plan<br>编译器检查需求并将计划重新发送给Driver。到目前为止，查询的解析和编译已经完成</p></li><li><p>(执行计划任务)Execute Plan<br>Driver将执行计划发送到执行引擎。</p></li><li><p>(执行Job任务)Execute Job<br>在内部，执行任务的过程是MapReduce Job。执行引擎将Job发送到ResourceManager,<br>ResourceManager位于Name节点中，并将job分配给datanode中的NodeManager。在这里，查询执行MapReduce任务.<br>(元数据操作)Metadata Ops<br>在执行的同时，执行引擎可以使用Metastore执行元数据操作。</p></li><li><p>(拉取结果集)Fetch Result<br>执行引擎将从datanode上获取结果集；</p></li><li><p>(发送结果集至driver)Send Results<br>执行引擎将这些结果值发送给Driver</p></li><li><p>(driver将result发送至interface)Send Results<br>Driver将结果发送到Hive接口</p></li></ol><p><strong>Hadoop 执行流程</strong></p><p>输入 –&gt; map –&gt; shuffle –&gt; reduce –&gt;输出</p><p>输入文件会被切分成多个块，每一块都有一个map task</p><p>map 阶段的输出结果会先写到内存缓冲区，然后由缓冲区写到磁盘上。默认的缓冲区大小是100M，溢出的百分比是0.8，也就是说当缓冲区中达到80M的时候就会往磁盘上写。如果map计算完成后的中间结果没有达到80M，最终也是要写到磁盘上的，因为它最终还是要形成文件。那么，在往磁盘上写的时候会进行分区和排序。一个map的输出可能有多个这个的文件，这些文件最终会合并成一个，这就是这个map的输出文件。</p><p><img src="https://i.loli.net/2019/11/16/X13uHw5KSBQkdJm.png"></p><ol><li><p>输入文件分片，每一片都由一个MapTask来处理</p></li><li><p>Map输出的中间结果会先放在内存缓冲区中，这个缓冲区的大小默认是100M，当缓冲区中的内容达到80%时（80M）会将缓冲区的内容写到磁盘上。也就是说，一个map会输出一个或者多个这样的文件，如果一个map输出的全部内容没有超过限制，那么最终也会发生这个写磁盘的操作，只不过是写几次的问题。</p></li><li><p>从缓冲区写到磁盘的时候，会进行分区并排序，分区指的是某个key应该进入到哪个分区，同一分区中的key会进行排序，如果定义了Combiner的话，也会进行combine操作</p></li><li><p>如果一个map产生的中间结果存放到多个文件，那么这些文件最终会合并成一个文件，这个合并过程不会改变分区数量，只会减少文件数量。例如，假设分了3个区，4个文件，那么最终会合并成1个文件，3个区</p></li><li><p>以上只是一个map的输出，接下来进入reduce阶段</p></li><li><p>每个reducer对应一个ReduceTask，在真正开始reduce之前，先要从分区中抓取数据</p></li><li><p>相同的分区的数据会进入同一个reduce。这一步中会从所有map输出中抓取某一分区的数据，在抓取的过程中伴随着排序、合并。</p></li><li><p>reduce输出</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Hive </tag>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有限自动机</title>
      <link href="/2019/11/02/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
      <url>/2019/11/02/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>说起这个都是泪啊。</p><span id="more"></span><p>在学校搞了有一年的机器人，阅读了一些 BHuman 的源码，只是会用罢了。对于思想没有深入学习和没有总结与思考。上次魔门塔面试，面试官一直追问关于有限自动机的事情（为什么要用有限状态自动机？他比 if else or switch case 好在哪里？），我却支支吾吾回答不上来。我陷入了对自己学习方式的思考中。</p><p>学习一个东西，要多问一个 <strong>WHY？</strong></p><blockquote><p>有限自动机(finite automata)亦称<a href="https://baike.baidu.com/item/%E6%97%B6%E5%BA%8F%E6%9C%BA/21506859">时序机</a>，有限离散数字系统的抽象<a href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B/1376909">数学模型</a>。一个有限自动机M由五元组(X,Y,S,δ,λ)给定，其中X,Y和S都是非空有限集，分别称为M的输入集、输出集和状态集；δ是<a href="https://baike.baidu.com/item/%E7%AC%9B%E5%8D%A1%E5%84%BF%E7%A7%AF/2587161">笛卡儿积</a>集合S×X到S的映射，称为M的下一<a href="https://baike.baidu.com/item/%E7%8A%B6%E6%80%81%E5%87%BD%E6%95%B0/2081219">状态函数</a>；λ是S×X到Y的单值映射，称为M的输出函数。当δ是单值映射时，称M为确定型有限自动机；当δ是多值映射时，称M为非确定型有限自动机。有限自动机有三种功能：作为序列转换器，将输入序列变换为输出序列；作为序列识别器，识别输入的序列是否具有某种性质；作为序列产生器，产生具有所要求性质的序列。</p></blockquote><p>上面的引用来自<a href="%5Bhttps://baike.baidu.com/item/%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A8%E6%9C%BA/8700995?fr=aladdin%5D(https://baike.baidu.com/item/%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A8%E6%9C%BA/8700995?fr=aladdin)">百度百科</a>，巴拉巴拉说了一顿，没接触过的同学可能很懵逼。</p><p>简单的说一下就是：有限自动机（有穷状态的机器），由一个有限的内部状态集和一组控制规则组成，这些规则是用来控制在当前状态下读入输入符号后应转向什么状态。对应在 BHuman 中的 CABSL 状态就是：options、states、transition、actions。<a href="%5Bhttps://ahoj.cc/2019/04/nao%E6%9C%BA%E5%99%A8%E4%BA%BA-cabsl/#CABSL%5D(https://ahoj.cc/2019/04/nao%E6%9C%BA%E5%99%A8%E4%BA%BA-cabsl/#CABSL)">这些可以参考我之前的博客</a></p><p>那么回到那个问题上：有限状态机比 if else or switch case 好在哪里？</p><ol><li>状态可控</li><li>上下文有关</li><li>抽象、封装</li></ol><p>继续学习。</p>]]></content>
      
      
      <categories>
          
          <category> Nao </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nao </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive学习笔记</title>
      <link href="/2019/10/25/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/10/25/Hive%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>hive 1.2.1</p><span id="more"></span><h2 id="你好，Hive"><a href="#你好，Hive" class="headerlink" title="你好，Hive"></a>你好，Hive</h2><p>Hive 是基于 Hadoop 的一个数据仓库工具，可以讲结构化的数据文件映射为一张表，并提供<em><strong>类 SQL</strong></em> 查询功能。</p><p>本质是：将 HQL 转化成 MapReduce 程序。</p><ul><li>Hive 处理的数据存储在 HDFS。</li><li>Hive 分析数据底层的默认实现是 MapReduce。</li><li>执行程序运行在 Yarn 上。</li></ul><h2 id="Hive-优缺点"><a href="#Hive-优缺点" class="headerlink" title="Hive 优缺点"></a>Hive 优缺点</h2><p>优点：</p><ol><li>操作接口采用 SQL 语法，提供快速开发的能力（简单、容易上手）。</li><li>避免了去写 MapReduce，减少开发人员的学习成本。</li><li>Hive 的执行延迟比较高，因此 Hive 常用于数据分析，对实时性要求不高的场合。</li><li>Hive 的优势在于处理大数据，对于处理小数据没有优势，因为 Hive 的执行延迟比较高。</li><li>Hive 支持用户自定义函数，用户可以根据自己的需求来实现自己的函数。</li></ol><p>缺点：</p><ol><li>Hive 的 HQL 表达能力有限<ol><li>迭代式算法无法表达</li><li>数据挖掘方面不擅长</li></ol></li><li>Hive 的效率比较低<ol><li>Hive 自动生成的 MapReduce 作业，通常情况下不够智能化。</li><li>Hive 调优比较困难，粒度较粗。</li></ol></li></ol><h2 id="Hive-的架构"><a href="#Hive-的架构" class="headerlink" title="Hive 的架构"></a>Hive 的架构</h2><p><img src="https://i.loli.net/2019/10/02/NvAmOEYjD2kwTGb.png"></p><p>圈出来的从左到右从上到下分别是：元数据、程序员的操作方式、Hadoop。</p><p>没有圈出来的那部分就是 Hive 的组成。</p><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hive 设置使用特定的任务队列</span></span><br><span class="line"><span class="meta prompt_">hive&gt; </span><span class="language-bash"><span class="built_in">set</span> mapred.job.queue.name=root.xxx;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">insert 一条一条插入到表中的效率是很慢的，一条数据几十秒左右，所以有下面的从文件加载数据到表中。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hive 从文件加载数据到 HDFS</span></span><br><span class="line"><span class="meta prompt_">hive&gt; </span><span class="language-bash">load data <span class="built_in">local</span> inpath <span class="string">&#x27;/opt/module/data/stu.txt&#x27;</span> into table student;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意 stu.txt 中的数据分隔符要保持一致，这个在建表的时候设置</span></span><br><span class="line"><span class="meta prompt_">hive&gt; </span><span class="language-bash">create table student(<span class="built_in">id</span> int, name string) row format delimited fields terminated by <span class="string">&#x27;\t&#x27;</span>;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其实 load 命令就是把 stu.txt 上传到了 hadoop 的数据库文件夹下，使用如下命令也可以起到相同效果</span></span><br><span class="line"><span class="meta prompt_">bash$ </span><span class="language-bash">hadoop fs -put stu1.txt /user/hive/warehouse/student</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">bash$ </span><span class="language-bash"><span class="built_in">export</span> HADOOP_CLIENT_OPTS=<span class="string">&quot;-Xmx4g&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一般 HADOOP 集群都会配套 HIVE，hive直接用 sql 来查询数据比mapreduce简单很多。启动hive是直接用 hadoop jar 来启动的。相对于一个客户端程序。控制hive内存的就是 HADOOP_CLIENT_OPTS 环境变量中的 -Xmx。</span></span><br></pre></td></tr></table></figure><p>hive 常用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-e 不进入 hive 的交互窗口执行 sql 语句</span></span><br><span class="line"><span class="meta prompt_">bash$ </span><span class="language-bash">hive -e <span class="string">&quot;select * from student;&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-f SQL from files</span></span><br><span class="line"><span class="meta prompt_">bash$ </span><span class="language-bash">hive -f ./hive.hql</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hive cli 中查看 hdfs 文件系统</span></span><br><span class="line"><span class="meta prompt_">hive&gt; </span><span class="language-bash">dfs -<span class="built_in">ls</span> /;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看本地文件系统</span></span><br><span class="line"><span class="meta prompt_">hive&gt; </span><span class="language-bash">! <span class="built_in">ls</span> /opt/module/datas;</span></span><br></pre></td></tr></table></figure><h2 id="HiveDDL"><a href="#HiveDDL" class="headerlink" title="HiveDDL"></a>HiveDDL</h2><h3 id="数据类型、类型转换"><a href="#数据类型、类型转换" class="headerlink" title="数据类型、类型转换"></a>数据类型、类型转换</h3><p>Hive 支持 Map String Array 等集合类型。</p><p>Hive 支持类型转换，当然有显示转换、隐式转换、强制 CAST 转换。</p><h3 id="库-增删改查"><a href="#库-增删改查" class="headerlink" title="库-增删改查"></a>库-增删改查</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">show databases;</span><br><span class="line"></span><br><span class="line">### 增 ###</span><br><span class="line">create database test;  # 创建的这个数据库在 warehouse 下的 test.db，是默认数仓的位置</span><br><span class="line"># create database if not exists test;  # if not exists</span><br><span class="line"># create database test location &#x27;/test.db&#x27;;  # location 指定存储位置，这里是放在根目录下</span><br><span class="line"></span><br><span class="line">use test;</span><br><span class="line">create table bb(id int);  # /warehouse/test.db/bb/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 查 ###</span><br><span class="line">show databases;</span><br><span class="line"></span><br><span class="line">show databases like &#x27;db_nam*&#x27;;  # 模糊查询</span><br><span class="line"></span><br><span class="line">查看数据库详情：显示 数据库名、描述、存储地址、拥有者名称之类的</span><br><span class="line">desc database db_name;</span><br><span class="line">查看扩展信息，和上面看到的其实一样</span><br><span class="line">desc database extended db_name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 改 ###</span><br><span class="line">数据库的其他元数据信息都是不可更改的，包括数据库名和数据库所在的目录位置。</span><br><span class="line">但是可以给数据可附加信息，修改后使用 desc database 即可查看效果。</span><br><span class="line">alter database db_name set dbproperties(&#x27;createtime&#x27;=&#x27;20170830&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 删 ###</span><br><span class="line">删除空数据库</span><br><span class="line">drop database db_name;</span><br><span class="line"></span><br><span class="line">如果删除的数据库不存在，最好采用 if exists 判断数据库是否存在</span><br><span class="line">drop database db_name;</span><br><span class="line">drop database if exists db_name;</span><br><span class="line"></span><br><span class="line">如果数据库不为空，可以采用 cascade 命令，强制删除</span><br><span class="line">drop database db_name cascade;</span><br></pre></td></tr></table></figure><h3 id="表-增删改查"><a href="#表-增删改查" class="headerlink" title="表-增删改查"></a>表-增删改查</h3><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">create [external] table [if not exists] table_name</span><br><span class="line">[(col_name data_type [comment col_comment], ...)]</span><br><span class="line">[comment table_comment]</span><br><span class="line">[partitioned by (col_name data_type [comment col_comment], ...)]  # 分区，分的就是文件夹</span><br><span class="line">[clustered by (col_name, col_name, ...)]  # 分桶，分的是文件</span><br><span class="line">[sorted by (col_name [ASC|DESC], ...)] INTO num_buckets BUCKETS]  # 按什么排序，分几个文件（桶）</span><br><span class="line">[ROW FORMAT row_format]  # 按什么分隔</span><br><span class="line">[STORED AS file_format]  # 存储文件格式（JSON、ORC、TXT...）</span><br><span class="line">[LOCATION hdfs_path]  # 存储位置</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">show create table table_name;</span><br></pre></td></tr></table></figure><h4 id="管理表（内部表）"><a href="#管理表（内部表）" class="headerlink" title="管理表（内部表）"></a>管理表（内部表）</h4><p>默认创建的表都是管理表（内部表）。这种表，Hive 会（或多或少）控制者数据的生命周期。</p><p>Hive 默认情况下会讲这些表的数据存储在由配置项 <em>hive.metastore.warehouse.dir</em> 所定义的目录的子目录下。</p><p>当删除一个内部表时，Hive 也会删除这个表中的数据。</p><p>内部表不适合和其他工具共享数据。</p><h4 id="外部表"><a href="#外部表" class="headerlink" title="外部表"></a>外部表</h4><p>……</p><h4 id="内部表月外部表的互相转换"><a href="#内部表月外部表的互相转换" class="headerlink" title="内部表月外部表的互相转换"></a>内部表月外部表的互相转换</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">3desc formatted stu2;</span><br><span class="line">Table Type: EXTERNAL_TABLE  #  外部表</span><br><span class="line">Table Type: MANAGED_TABLE  # 内部表</span><br><span class="line"></span><br><span class="line"># 内部表 -&gt; 外部表</span><br><span class="line">alter table stu2 set tblproperties(&#x27;EXTERNAL&#x27;=&#x27;TRUE&#x27;);  # 这里需要大写！</span><br><span class="line"></span><br><span class="line"># 外部表 -&gt; 内部表</span><br><span class="line">alter table stu2 set tblproperties(&#x27;EXTERNAL&#x27;=&#x27;FALSE&#x27;);  # 大写！</span><br></pre></td></tr></table></figure><h4 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h4><p>分区表实际上就是对应一个 HDFS 文件系统上的独立的文件夹，该文件夹下是该分区所有的数据文件。</p><p>Hive 中的分区就是分目录，把一个大的数据集根据业务需要分割成小的数据集。</p><p>在查询时通过 WHERE 子句中的表达式选择查询所需要的指定的分区，这样的查询效率会提高很多。（谓词下推，过滤，缩减查询数据量）</p><h5 id="分区表基本操作"><a href="#分区表基本操作" class="headerlink" title="分区表基本操作"></a>分区表基本操作</h5><ol><li><p>引入分区表（需要根据日期对日志进行管理）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/user/hive/warehouse/log_partition/20190901/20190901.log</span><br><span class="line">/user/hive/warehouse/log_partition/20190902/20190902.log</span><br><span class="line">/user/hive/warehouse/log_partition/20190903/20190903.log</span><br></pre></td></tr></table></figure></li><li><p>创建分区表语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; create table dept_partition(</span><br><span class="line">  deptno int,</span><br><span class="line">  dname string,</span><br><span class="line">  loc string</span><br><span class="line">)</span><br><span class="line">partitioned by (month string)  # 按月来分区，这个也表的是一个字段（列）</span><br><span class="line">row format delimited fields terminated by &#x27;\t&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>加载数据到表中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; load data local inpath &#x27;/opt/module/datas/dept.txt&#x27; into table dept_partition partition(month=&#x27;201709&#x27;)</span><br><span class="line"></span><br><span class="line">hive&gt; load data local inpath &#x27;/opt/module/datas/dept.txt&#x27; into table dept_partition partition(month=&#x27;201708&#x27;)</span><br><span class="line"></span><br><span class="line">hive&gt; load data local inpath &#x27;/opt/module/datas/dept.txt&#x27; into table dept_partition partition(month=&#x27;201707&#x27;)</span><br></pre></td></tr></table></figure></li><li><p>查询分区表中数据</p><p>直接 where month=’201709’ 就可以了</p></li><li><p>增加分区</p><p>创建单个分区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table dept_partition add partition(month=&#x27;201706&#x27;);</span><br></pre></td></tr></table></figure><p>同时创建多个分区，空格隔开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter table dept_partition</span><br><span class="line">add partition(month=&#x27;201706&#x27;)</span><br><span class="line">add partition(month=&#x27;201707&#x27;);</span><br></pre></td></tr></table></figure></li><li><p>删除分区</p><p>删除单个分区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table dept_partition</span><br><span class="line">drop partition(month=&#x27;201706&#x27;);</span><br></pre></td></tr></table></figure><p>删除多个分区，逗号隔开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter table dept_partition</span><br><span class="line">drop partition(month=&#x27;201706&#x27;)</span><br><span class="line">, drop partition(month=&#x27;201707&#x27;);</span><br></pre></td></tr></table></figure></li><li><p>查看分区表有多少分区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show partitions dept_partition;</span><br></pre></td></tr></table></figure></li><li><p>查看分区表结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">desc formatted dept_partition;</span><br><span class="line"></span><br><span class="line"># Partition Information</span><br><span class="line"># col_name data_type comment</span><br><span class="line">  month    string</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure></li></ol><h5 id="分区表注意事项"><a href="#分区表注意事项" class="headerlink" title="分区表注意事项"></a>分区表注意事项</h5><ol><li><p>创建二级分区表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table tab_name (</span><br><span class="line">  id int,</span><br><span class="line">  name string,</span><br><span class="line">  loc string</span><br><span class="line">)</span><br><span class="line">partitioned by (month string, day string)</span><br><span class="line">row format delimited fields terminated by &#x27;\t&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>正常的加载数据</p><p>加载数据到二级分区表中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">load data local inpath &#x27;./dept.txt&#x27;</span><br><span class="line">into table tab_name</span><br><span class="line">partition(month=&#x27;201709&#x27;, day=&#x27;13&#x27;);</span><br></pre></td></tr></table></figure><p>查询分区数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tab_name where month=&#x27;201709&#x27; and day=&#x27;13&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>把数据上传到分区目录上，让分区表和数据产生关联的三种方式</p><ul><li><p>上传数据后修复</p><p>上传数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; dfs -mkdir -p /user/hive/warehouse/dept_partition2/month=201709/day=12;</span><br><span class="line"></span><br><span class="line">hive&gt; dfs -put /opt/module/datas/dept.txt /user/hive/warehouse/dept_partition2/month=201709/day=12;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 上面两句等同于下面这两句</span><br><span class="line">bash$ hadoop fs -mkdir -p /user/hive/warehouse/dept_partition2/month=201709/day=12;</span><br><span class="line"></span><br><span class="line">bash$ hadoop fs -put dept.txt /user/hive/warehouse/dept_partition2/month=201709/day=12;</span><br></pre></td></tr></table></figure><p>查询数据（查询不到刚上传的数据，因为没有操作数据库中的元数据，没有元数据，所以差不到）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; select * from dept_partition2 where month=&#x27;201709&#x27; and day=&#x27;12&#x27;;</span><br></pre></td></tr></table></figure><p>执行修复命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; msck repair table dept_partition2;</span><br></pre></td></tr></table></figure><p>再次查询数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; select * from dept_partition2 where month=&#x27;201709&#x27; and day=&#x27;12&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>上传数据后添加分区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; alter table dept_partition2 add partition(month=&#x27;2019-12&#x27;);</span><br></pre></td></tr></table></figure></li><li><p>创建文件夹后 load 数据到分区</p><p>创建目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; dfs mkdir -p /user/hive/warehouse/dept_partition2/month=201709/day=12;</span><br></pre></td></tr></table></figure><p>上传数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; load data local</span><br><span class="line">inpath &#x27;/opt/module/datas/dept.txt&#x27;</span><br><span class="line">into table dept_partition2 partition(month=&#x27;201909&#x27;, day=&#x27;30&#x27;);</span><br></pre></td></tr></table></figure><p>查询数据即可……</p></li></ul></li></ol><h4 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h4><ol><li><p>重命名表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; alter table table_name rename to new_table_name;</span><br></pre></td></tr></table></figure><p>重命名表后物理存储的文件夹的名字也改变了。（改的是元数据）</p></li><li><p>增加/删除/修改 表分区</p><p>在上面 <a href="#%E5%88%86%E5%8C%BA%E8%A1%A8">分区表</a> 就有操作。</p></li><li><p>增加/修改/替换 列信息</p><p>更新列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; alter table table_name </span><br><span class="line">change [column] col_old_name col_new_name column_type</span><br><span class="line">[comment col_comment]</span><br><span class="line">[first|after column_name]</span><br></pre></td></tr></table></figure><p>增加列和替换列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; alter table table_name</span><br><span class="line">add|replace columns (col_name data_type [comment col_comment],</span><br><span class="line">...</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><em>注意：replace 是整列全部替换的，如果用了 replace 后面只写了一个列，那后面这张表就只有一个列，如果指向替换表中的一个列，用 change 就够了。</em></p></li></ol><h4 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; drop table table_name;</span><br></pre></td></tr></table></figure><h2 id="HiveDML"><a href="#HiveDML" class="headerlink" title="HiveDML"></a>HiveDML</h2><h3 id="数据导入"><a href="#数据导入" class="headerlink" title="数据导入"></a>数据导入</h3><p>数据从 HDFS 导入到 Hive 表中、从本地文件系统导入 Hive 表中。</p><h4 id="向表中装载数据（load）"><a href="#向表中装载数据（load）" class="headerlink" title="向表中装载数据（load）"></a>向表中装载数据（load）</h4><p>语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; load data [local] inpath &#x27;...&#x27; [overwrite] into table student [partition(xxx=xxx, ...)];</span><br></pre></td></tr></table></figure><p><strong>local：</strong>表示从本地加载数据到 Hive 表，否则从 HDFS 加载数据到 Hive 表。</p><blockquote><p><strong>insert into 和 insert overwrite 的区别</strong></p><p>overwrite 上述的数据，先现将原始表的数据 remove，再插入新数据。</p><p>insert into 只是简单的插入，不考虑原始表的数据，直接追加到表中。</p></blockquote><h4 id="通过查询语句向表中插入数据（insert）"><a href="#通过查询语句向表中插入数据（insert）" class="headerlink" title="通过查询语句向表中插入数据（insert）"></a>通过查询语句向表中插入数据（insert）</h4><ol><li><p>创建一张分区表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; </span><br><span class="line">create table student(</span><br><span class="line">  id int, name string</span><br><span class="line">)</span><br><span class="line">partitioned by (month string)</span><br><span class="line">row format delimited fields terminated by &#x27;\t&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>基本插入数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive&gt;</span><br><span class="line">insert into table student partition(month=&#x27;201709&#x27;) values(1, &#x27;ahojcn&#x27;);</span><br></pre></td></tr></table></figure></li><li><p>基本模式插入（根据单张表查询结果）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive&gt;</span><br><span class="line">insert overwrite table student partition(month=&#x27;201708&#x27;)</span><br><span class="line">select id, name from student where month=&#x27;201709&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>多插入模式（根据多张表查询结果）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hive&gt;</span><br><span class="line">from student</span><br><span class="line">insert overwrite table student partition(month=&#x27;201707&#x27;) select id, name</span><br><span class="line">where month=&#x27;201709&#x27;</span><br><span class="line">insert overwrite table student partition(month=&#x27;201706&#x27;) select id, name</span><br><span class="line">where month=&#x27;201709&#x27;</span><br></pre></td></tr></table></figure></li></ol><p>####查询语句中创建表并加载数据（as Select）</p><p>根据查询结果创建表（查询的结果会添加到新创建的表中），这个也可以用来导入数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive&gt;</span><br><span class="line">create table if not exists student</span><br><span class="line">as select id, name from student;</span><br></pre></td></tr></table></figure><h4 id="创建表时通过-location-指定加载数据路径"><a href="#创建表时通过-location-指定加载数据路径" class="headerlink" title="创建表时通过 location 指定加载数据路径"></a>创建表时通过 location 指定加载数据路径</h4><ol><li><p>创建表，并指定在 HDFS 上的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hive&gt;</span><br><span class="line">create table if not exists student (</span><br><span class="line">  id int, name string</span><br><span class="line">)</span><br><span class="line">row format delimited fields terminated by &#x27;\t&#x27;</span><br><span class="line">location &#x27;/user/hive/warehouse/student&#x27;</span><br></pre></td></tr></table></figure></li><li><p>上传数据到 HDFS 上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive&gt;</span><br><span class="line">dfs -put /opt/module/datas/student.txt /user/hive/warehouse/student;</span><br></pre></td></tr></table></figure></li><li><p>查询数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive&gt;</span><br><span class="line">select * from student;</span><br></pre></td></tr></table></figure></li></ol><h4 id="import-数据到指定-Hive-表中"><a href="#import-数据到指定-Hive-表中" class="headerlink" title="import 数据到指定 Hive 表中"></a>import 数据到指定 Hive 表中</h4><p>注意先用 export 导出后，再将数据导入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive&gt;</span><br><span class="line">import table student partition(month=&#x27;201709&#x27;)</span><br><span class="line">from &#x27;/user/hive/warehouse/export/stu&#x27;;</span><br></pre></td></tr></table></figure><h3 id="数据导出"><a href="#数据导出" class="headerlink" title="数据导出"></a>数据导出</h3><h4 id="insert-导出"><a href="#insert-导出" class="headerlink" title="insert 导出"></a>insert 导出</h4><ol><li><p>将查询的结果导出到本地</p><p>这样导出的数据是没有分隔符的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive&gt;</span><br><span class="line">insert overwrite local directory &#x27;/opt/module/datas/export/student&#x27;</span><br><span class="line">  select * from student;</span><br></pre></td></tr></table></figure></li><li><p>将查询的结果格式化导出到本地</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hive&gt;</span><br><span class="line">insert overwrite directory &#x27;/opt/module/datas/export/student1&#x27;</span><br><span class="line">row format delimited fields terminated by &#x27;\t&#x27;</span><br><span class="line">select * from student;</span><br></pre></td></tr></table></figure></li><li><p>将查询的结果导出到 HDFS 上（没有 local）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hive&gt;</span><br><span class="line">insert overwrite directory &#x27;/user/atguidu/student2&#x27;</span><br><span class="line">row format delimited fields terminated by &#x27;\t&#x27;</span><br><span class="line">select * from student;</span><br></pre></td></tr></table></figure></li></ol><h4 id="Hadoop-命令导出到本地"><a href="#Hadoop-命令导出到本地" class="headerlink" title="Hadoop 命令导出到本地"></a>Hadoop 命令导出到本地</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive&gt;</span><br><span class="line">dfs -get /user/hive/warehouse/student/month=201709/000000_0 /opt/module/datas/export/student3.txt;</span><br></pre></td></tr></table></figure><h4 id="Hive-Shell-命令导出"><a href="#Hive-Shell-命令导出" class="headerlink" title="Hive Shell 命令导出"></a>Hive Shell 命令导出</h4><p>基本语法：hive -f/-e 执行语句或者脚本 &gt; file，重定向！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">bash$ </span><span class="language-bash">hive -e <span class="string">&#x27;select * from db_name.tab_name&#x27;</span> &gt; /opt/module/datas/export/student4.txt;</span></span><br></pre></td></tr></table></figure><h4 id="export-导出到-HDFS-上"><a href="#export-导出到-HDFS-上" class="headerlink" title="export 导出到 HDFS 上"></a>export 导出到 HDFS 上</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; </span><br><span class="line">export table db_name.tab_name to &#x27;/user/hive/warehouse/export/student&#x27;;</span><br></pre></td></tr></table></figure><h4 id="sqoop-导出"><a href="#sqoop-导出" class="headerlink" title="sqoop 导出"></a>sqoop 导出</h4><p>SQL to Hadoop，后面学习……</p><h3 id="清除表中数据（Truncate）"><a href="#清除表中数据（Truncate）" class="headerlink" title="清除表中数据（Truncate）"></a>清除表中数据（Truncate）</h3><p>注意：Truncate 只能删除管理表，不能删除外部表中数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive&gt;</span><br><span class="line">truncate table student;</span><br></pre></td></tr></table></figure><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><ol><li><p>count，求总行数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive&gt;</span><br><span class="line">select count(*) cnt from tab_name;</span><br></pre></td></tr></table></figure></li><li><p>max，求最大值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive&gt;</span><br><span class="line">select max(salary) max_salary from tab_name;</span><br></pre></td></tr></table></figure></li><li><p>min</p></li><li><p>sum，求和</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sum(sqlary) sum_salary from tab_name;</span><br></pre></td></tr></table></figure></li><li><p>avg，求平均值</p></li></ol><h3 id="where-语句"><a href="#where-语句" class="headerlink" title="where 语句"></a>where 语句</h3><p>where 子句紧随 from 子句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from emp where sal&gt;1000;</span><br></pre></td></tr></table></figure><p>名词：调优手段，谓词下推。</p><h4 id="比较运算符-between-in-is-null"><a href="#比较运算符-between-in-is-null" class="headerlink" title="比较运算符 between/in/is null"></a>比较运算符 between/in/is null</h4><p><code>&lt;&gt;</code>，<code>!=</code>这两个是一个意思。</p><p><code>&lt;=&gt;</code>，如果 A 和 B 都为 NULL，则返回 True，其他的和等号(<code>=</code>)操作结果一直，如果任一为 NULL 则返回 NULL。</p><p>其他的比较符都一样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select &#x27;b&#x27; between &#x27;a&#x27; and &#x27;c&#x27;;  # true，注意左右都是闭区间</span><br><span class="line">select &#x27;a&#x27; in (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;);  # true</span><br><span class="line">select &#x27;a&#x27; is NULL;</span><br></pre></td></tr></table></figure><p><strong>like 和 rlike</strong></p><p>使用 like 运算选择类似的值。</p><p>选择条件可以包含字符或数字：<br><code>%</code> 代表零个或多个字符（任意个字符）<br><code>_</code> 代表一个字符。</p><p>rlike 子句是 Hive 中的一个扩展，其可以通过 Java 的正则表达式配合进行筛选。</p><h4 id="逻辑运算符-and-or-not"><a href="#逻辑运算符-and-or-not" class="headerlink" title="逻辑运算符 and/or/not"></a>逻辑运算符 and/or/not</h4><p>……</p><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><h4 id="group-by-子句"><a href="#group-by-子句" class="headerlink" title="group by 子句"></a>group by 子句</h4><p>group by 语句通常会和聚合函数一起使用，按照一个或者多个队列结果进行分组，然后对每个组执行聚合操作。</p><p>栗子🌰：</p><ol><li><p>计算 emp 中每个部门的平均工资：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive&gt;</span><br><span class="line">select t.deptno, avg(t.sal) avg_sal from emp t</span><br><span class="line">group by t.deptno;</span><br></pre></td></tr></table></figure></li><li><p>计算 emp 每个部门中每个岗位的最高薪水：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive&gt;</span><br><span class="line">select t.deptno, t.job, max(t.sal) as max_sal from emp as t</span><br><span class="line">group by t.deptno, t.job;</span><br></pre></td></tr></table></figure></li></ol><h4 id="having-子句"><a href="#having-子句" class="headerlink" title="having 子句"></a>having 子句</h4><p><strong>having 和 where 不同点</strong></p><ol><li>where 针对表中的列发挥作用，查询数据；having 针对查询结果中的列发挥作用，筛选数据。</li><li>where 后面不能写分组函数，而 having 后面可以使用分组函数。</li><li>having 只用于 group by 分组统计语句。</li></ol><p>栗子，求每个部门的平均薪水大于 2000 的部门：</p><ol><li><p>求没个部门的平均工资</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive&gt;</span><br><span class="line">select deptno, avg(sal) from emp group by deptno;</span><br></pre></td></tr></table></figure></li><li><p>求每个部门的平均薪水大于 2000 的部门</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive&gt;</span><br><span class="line">select deptno, avg(sal) as avg_sal from emp group by deptno</span><br><span class="line">having avg_sal&gt;2000;</span><br></pre></td></tr></table></figure></li></ol><h3 id="join-子句"><a href="#join-子句" class="headerlink" title="join 子句"></a>join 子句</h3><p>Hive 支持通常的 SQL JOIN 语句，但是只支持等值连接，不支持非等值连接。</p><p>join 默认是 inner join。</p><h4 id="等值-join"><a href="#等值-join" class="headerlink" title="等值 join"></a>等值 join</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hive&gt;</span><br><span class="line">select e.deptno, e.name from emp as e</span><br><span class="line">join dept as d</span><br><span class="line">on e.deptno = deptno;</span><br><span class="line"></span><br><span class="line"># 但是不支持下面的</span><br><span class="line">hive&gt;</span><br><span class="line">select e.deptno, e.name from emp as e</span><br><span class="line">join dept as d</span><br><span class="line">on e.deptno != deptno;  # 或者 &gt; &lt; 之类的操作</span><br></pre></td></tr></table></figure><h4 id="表的别名"><a href="#表的别名" class="headerlink" title="表的别名"></a>表的别名</h4><p>好处：</p><ol><li>使用别名可以简化查询。</li><li>使用表名前缀可以提高执行效率。</li></ol><h4 id="内连接-join"><a href="#内连接-join" class="headerlink" title="内连接 join"></a>内连接 join</h4><p>只有进行连接的两个表中都存在与连接条件相匹配的数据才会被保留下来。</p><h4 id="左连接-left-join"><a href="#左连接-left-join" class="headerlink" title="左连接 left join"></a>左连接 left join</h4><p>join 操作符左边表中符合 where 子句的所有记录将会被返回。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hive&gt;</span><br><span class="line">select e.empno, e.name, d.deptno from emp as e</span><br><span class="line">left join dept as d</span><br><span class="line">on e.deptno = d.deptno;</span><br></pre></td></tr></table></figure><h4 id="右连接-right-join"><a href="#右连接-right-join" class="headerlink" title="右连接 right join"></a>右连接 right join</h4><p>join 操作符右边表中符合 where 子句的所有记录将会被返回。</p><h4 id="满外连接-full-join"><a href="#满外连接-full-join" class="headerlink" title="满外连接 full join"></a>满外连接 full join</h4><p>将会返回所有表中符合 where 语句条件的所有记录。如果任一表的指定字段没有符合条件的值的话，那么就使用 NULL 替代。</p><p>MySQL 中没有满外连接，MySQL 中可以使用 or 来自己实现满外连接。</p><h4 id="多表连接"><a href="#多表连接" class="headerlink" title="多表连接"></a>多表连接</h4><p>连接 n 个表，至少需要 n-1 个链接条件。</p><p>例如：<code>A join B on xxx=xxx join C on xxx=xxx;</code></p><h4 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h4><p>笛卡尔集会在以下条件中产生</p><ol><li>省略连接条件</li><li>连接条件无效</li><li>所有表中的所有行互相连接</li></ol><p>例如：<code>select empno, dname from emp, dept;</code></p><h4 id="连接谓词中不支持-or"><a href="#连接谓词中不支持-or" class="headerlink" title="连接谓词中不支持 or"></a>连接谓词中不支持 or</h4><p>支持 and。</p><p>栗子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hive&gt;  # 错误栗子</span><br><span class="line">select e.empno, e.ename, d.deptno</span><br><span class="line">from emp as e join dept as d on e.deptno=d.deptno or e.ename=d.dname;</span><br></pre></td></tr></table></figure><p>如果有这样的需求的话，用子查询的方式来处理。</p><hr>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hive </tag>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop学习笔记</title>
      <link href="/2019/09/30/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/09/30/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="你好，Hadoop"><a href="#你好，Hadoop" class="headerlink" title="你好，Hadoop"></a>你好，Hadoop</h2><p><strong>为什么不能用配有大量硬盘的数据库来进行大规模数据分析？为什么需要用 Hadoop？</strong></p><ul><li>如果数据访问模式中包含大量的硬盘寻址，那么读取大量数据集就会必然会花更长的时间（相较于流数据读取模式，流读取主要取决于传输速率）。</li><li>如果数据库系统只更新一小部分记录，那么传统的 B 树更有优势。但数据库系统中如果有大量数据更新时，B 树的效率就明显落后于 MapReduce，因为需要使用“排序/合并”（sort/merge）来重建数据库。</li></ul><p><strong>Hadoop 相关开源项目</strong></p><ul><li>数据格式：Avro、Parquet</li><li>数据读取：Flume、Sqoop</li><li>数据处理：Pig、Hive、Crunch、Spark</li><li>存储：HBase</li><li>协作：ZooKeeper</li></ul>]]></content>
      
      
      <categories>
          
          <category> Hadoop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hive </tag>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习Cpp-从C到Cpp</title>
      <link href="/2019/09/05/%E4%BB%8EC%E5%88%B0Cpp/"/>
      <url>/2019/09/05/%E4%BB%8EC%E5%88%B0Cpp/</url>
      
        <content type="html"><![CDATA[<p>从了解 Cpp 已经有一点时间了，然后就转用了 Python 和 Vue 做项目。</p><p>好久不见，甚是想念。</p><span id="more"></span><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>避免命名冲突。</p><p><span style="color: red">需要注意的几点：</span></p><ol><li><p>同一个工程中允许存在多个相同名称的命名空间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line">    <span class="type">int</span> aa = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ab = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line"><span class="comment">//    int ab = 3;  // 提示已存在变量 ab</span></span><br><span class="line">    <span class="type">int</span> ac = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>命名空间可以嵌套</p></li><li><p>如下写法使用的是全局的变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">    std::cout &lt;&lt; ::a &lt;&lt; std::endl;  <span class="comment">// 输出 10</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="缺省参数"><a href="#缺省参数" class="headerlink" title="缺省参数"></a>缺省参数</h2><p>缺省参数是声明或定义函数时为函数的参数指定一个默认值。在调用该函数时，如果没有指定实参则采用该默 认值，否则使用指定的实参。</p><p>全缺省参数、半缺省参数。</p><p><span style="color: red">注意：</span></p><ol><li><p>缺省参数不能在声明和定义中同时出现。</p><p><span style="color: pink"><b>WHY?</b></span></p><p>如果生命与定义位置同时出现，恰巧两个位置提供的值不同，那编译器就无法确定到底该用那个缺省值。</p><p>在看完《高质量 C++/C 编程指南》后，我觉得下面的写法是比较舒服的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i=<span class="number">1</span>, <span class="type">double</span> d=<span class="number">1.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i, <span class="type">double</span> d)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl &lt;&lt; d &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>半缺省参数必须从右向左依次给出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i = <span class="number">0</span>, <span class="type">int</span> j, <span class="type">int</span> k = <span class="number">1</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j = <span class="number">0</span>, <span class="type">int</span> k = <span class="number">1</span>)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><span style="color: pink"><b>WHY?</b></span></p><p>我想了一会儿，难道又是王八的屁股？后来明白了~看下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d = <span class="number">10</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>我在调用 func 的时候是怎么给参数赋值的呢？对，从左往右写。</p><p>半缺省参数这样规定就可以让我们在调用传参的时候很方便的空出后面已经有了默认参数的参数。半缺省参数从左往右给的话就会有歧义。</p></li><li><p>缺省值必须是常量或者全局变量。</p><p><span style="color: pink"><b>WHY?</b></span></p><p>缺省值是变量编译器就无法在编译的时候确定值。</p></li></ol><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>同名函数的形参列表(参数个数/类型/顺序)必须不同。</p><p><span style="color: pink"><b>WHY?</b></span></p><p>这个和 C++ 编译器对函数的<strong>名字修饰</strong>有关。</p><h3 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h3><p>有时候在 C++ 工程中可能需要将某些函数按照 C 的风格来编译，在函数前加 extern “C”，意思是告诉编译器，将 该函数按照 C 语言规则来编译。文章：<a href="https://blog.csdn.net/lv_Amelia/article/details/79483481">extern和extern “C”</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">Add</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>我李逵，江湖人称黑旋风。</p><p>引用的底层（在 VS 中可以 debug 模式下看汇编代码）其实和指针的实现方式是一致的。</p><p><span style="color: red">注意：</span></p><ol><li>引用类型必须和引用实体是同类型的（就像别人叫你🐖🐖，你也不答应一样，人家 int a，你说人家是 double d，你经过 a 的监护人编译器的同意了吗）。</li><li>引用在定义时必须初始化。</li><li>引用一旦引用一个实体，再不能引用其他实体。</li><li>一个变量可以有多个引用。</li></ol><h3 id="常引用"><a href="#常引用" class="headerlink" title="常引用"></a>常引用</h3><p>看看下面几个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;ar = a;  <span class="comment">// 报错</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ar = a;  <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> &amp;rb1 = b;  <span class="comment">// ok</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;rb2 = b;  <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="type">int</span> c = <span class="number">30</span>;</span><br><span class="line"><span class="type">double</span> &amp;rc1 = c;  <span class="comment">// 报错</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> &amp;rc2 = c;  <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>先来看看 3，报错是因为类型不同，那为什么下面那一句加了 const 就可以了呢？</p><p><span style="color: pink"><b>WHY?</b></span></p><p>如果将 rc1 写成<code>double rc1 = c;</code>是可以的，中间发生了隐式类型转换，隐式类型转换的过程中会生成一个临时的空间 temp，这个临时变量是只读的（如果写成<code>double &amp;rc1 = c;</code>就变成可读可写的了，所以会报错），这个过程大致是这样子的：</p><p><img src="https://i.loli.net/2019/09/05/wq4hu2kNFKsUOm8.jpg" alt="62A37143-98D9-44E2-8ED3-032451FBAC7F.png"></p><p>总结一下：</p><p>不能赋值的根本原因是因为权限超过了原有的权限，权限降低是允许的，但是超越最初权限范围是错误的。/:)</p><h3 id="引用的使用场景"><a href="#引用的使用场景" class="headerlink" title="引用的使用场景"></a>引用的使用场景</h3><p>做函数参数、做函数的返回值。</p><p><span style="color: red">注意：</span></p><p>不能返回栈上面的变量。</p><p>如果函数返回时，离开函数作用域后，其栈上空间已经还给系统，因此不能用栈上的空间作为引用类型返回。如果以引用类型返回，返回值的生命周期必须不受函数的限制(即比函数生命周期长)。举个栗子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> c = a + b;</span><br><span class="line"><span class="keyword">return</span> c; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span>&amp; ret = <span class="built_in">Add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">Add</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Add(1, 2) is :&quot;</span>&lt;&lt; ret &lt;&lt;endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="传值和传引用的效率差距"><a href="#传值和传引用的效率差距" class="headerlink" title="传值和传引用的效率差距"></a>传值和传引用的效率差距</h4><p>以值作为参数或者返回值类型，在传参和返回期间，函数不会直接传递实参或者将变量本身直接返回，而是传递实<br>参或者返回变量的一份临时的拷贝，因此用值作为参数或者返回值类型，效率是非常低下的，尤其是当参数或者返回值类型非常大时，效率就更低。举 2 个栗子，可以从输出看出效率：</p><p>栗子 1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> data[<span class="number">10000</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(A &amp;a)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> begin = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i)</span><br><span class="line">        <span class="built_in">func1</span>(a);</span><br><span class="line">    <span class="type">size_t</span> end = <span class="built_in">clock</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;func1(A a) : &quot;</span> &lt;&lt; end - begin &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    begin = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i)</span><br><span class="line">        <span class="built_in">func2</span>(a);</span><br><span class="line">    end = <span class="built_in">clock</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;func2(A a) : &quot;</span> &lt;&lt; end - begin &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">func1(A a) : 36976</span></span><br><span class="line"><span class="comment">  func2(A &amp;a) : 22</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>栗子 2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> data[<span class="number">10000</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">A&amp; <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> begin = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i)</span><br><span class="line">        <span class="built_in">func1</span>();</span><br><span class="line">    <span class="type">size_t</span> end = <span class="built_in">clock</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;A func1() : &quot;</span> &lt;&lt; end - begin &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    begin = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i)</span><br><span class="line">        <span class="built_in">func2</span>();</span><br><span class="line">    end = <span class="built_in">clock</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;A&amp; func2() : &quot;</span> &lt;&lt; end - begin &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">A func1() : 174202</span></span><br><span class="line"><span class="comment">  A&amp; func2() : 264</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="指针和引用异同"><a href="#指针和引用异同" class="headerlink" title="指针和引用异同"></a>指针和引用异同</h3><ol><li><p>在<strong>语法概念上</strong>引用就是一个别名，没有独立空间，和其引用实体共用同一块空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="type">int</span>&amp; ra = a;</span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;&amp;a = &quot;</span>&lt;&lt;&amp;a&lt;&lt;endl;</span><br><span class="line"> cout&lt;&lt;<span class="string">&quot;&amp;ra = &quot;</span>&lt;&lt;&amp;ra&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<strong>底层实现上</strong>实际是有空间的，因为引用是按照指针方式来实现的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span>&amp; ra = a;</span><br><span class="line">  ra = <span class="number">20</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span>* pa = &amp;a;</span><br><span class="line">  *pa = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/09/05/Epzdjny4rvkSMxg.jpg" alt="汇编代码"></p></li></ol><p><span style="color: red">引用和指针的不同点：</span></p><ol><li><p>引用在定义时必须初始化，指针没有要求。</p></li><li><p>引用在初始化时引用一个实体后，不能再引用其他实体，而指针可以在任何时候指向任何一个同类型实</p><p>体。</p></li><li><p>没有NULL 引用，但有 NULL 指针。</p></li><li><p>在 sizeof 中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数（32 位平台下占 4 个字节）。</p></li><li><p>引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小。</p></li><li><p>有多级指针，但是没有多级引用。</p></li><li><p>访问实体方式不同，指针需要显式解引用，引用编译器自己处理。</p></li><li><p>引用比指针使用起来相对更安全。</p></li></ol><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>使用 inline 修饰的函数。编译时编译器会在调用处将内联函数展开，没有函数压栈的开销，内联函数提升程序运行的效率。</p><p><span style="color: red">注意：</span></p><ol><li>inline 函数是一种以空间换时间的方法，省去额外调用函数的开销，有循环或者递归的函数不适宜作为内联函数。</li><li>inline 对于编译器来说只是一个建议，至于编译器听不听你的就看情况了，编译器觉得你傻他就信自己的。</li><li>inline 不建议声明和定义分离，分离会导致链接错误。因为 inline 被展开，就没有函数地址了，链接就会找 不到。</li></ol><p><img src="https://i.loli.net/2019/09/05/uWJPcEbeGNqphgC.jpg" alt="E9EBA8AC-8FDA-4ADC-AAB3-A192C3D4CE80.png"></p><p><img src="https://i.loli.net/2019/09/05/54Qrq6zUWdEM7N3.jpg" alt="1DC0FD1A-E413-474E-9F72-5312C7D7FC3D.png"></p><h2 id="auto-关键字（C-11）"><a href="#auto-关键字（C-11）" class="headerlink" title="auto 关键字（C++11）"></a>auto 关键字（C++11）</h2><blockquote><p>在早期 C/C++ 中 auto 的含义是：使用 auto 修饰的变量，是具有自动存储器的局部变量，但遗憾的是一直没有人 去使用它。</p><p>C++11 中 auto 不再是一个存储类型指示符，而是作为一个新的类型指 示符来指示编译器，auto声明的变量必须由编译器在编译时期推导而得。</p></blockquote><p><span style="color: red">注意：</span></p><ol><li><p>使用 auto 定义变量时必须对其进行初始化。</p><p>在编译阶段编译器需要根据初始化表达式来推导 auto 的实际类型。因此 auto 并非是一种“类型”的声明，而是一个类型声明时的“占位符”，编译器在编译期会将 auto 替换为变 量实际的类型。</p></li><li><p>auto 与指针结合起来使用。</p><p>用 auto 声明指针类型时，用 auto 和 auto * 没有任何区别，但是用 auto 声明引用类型时则必须加 &amp;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> a = &amp;x;</span><br><span class="line"><span class="keyword">auto</span> *b = &amp;x;</span><br><span class="line"><span class="keyword">auto</span> &amp;c = x;</span><br><span class="line"></span><br><span class="line">*a = <span class="number">20</span>;</span><br><span class="line">*b = <span class="number">30</span>;</span><br><span class="line">c = <span class="number">40</span>;</span><br></pre></td></tr></table></figure></li><li><p>在同一行定义多个变量。</p><p>当在同一行声明多个变量时，这些变量必须是相同的类型，否则编译器将会报错，因为编译器实际只对第一个类型进行推导，然后用推导出来的类型定义后面的变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> c = <span class="number">3</span>, d = <span class="number">4.0</span>;  <span class="comment">// error!</span></span><br></pre></td></tr></table></figure></li><li><p>auto 不能作为函数的参数。</p></li><li><p>auto 不能直接用来声明数组。</p></li><li><p>为了避免与 C++98 中的 auto 发生混淆，C++11 只保留了 auto 作为类型指示符的用法。</p></li><li><p>auto 在实际中最常见的优势用法就是和 for 循环、lambda 表达式等进行配合使用。</p></li><li><p>auto 不能定义类的非静态成员变量。</p></li><li><p>实例化模板时不能使用 auto 作为模板参数。</p></li></ol><h2 id="基于范围-for（C-11）"><a href="#基于范围-for（C-11）" class="headerlink" title="基于范围 for（C++11）"></a>基于范围 for（C++11）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e : arr) &#123;</span><br><span class="line">  e *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : arr) &#123;</span><br><span class="line">  cout &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error! arr 已经是作为指针传入了，不能确定其范围。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> arr[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e : arr) &#123;</span><br><span class="line">    cout &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span style="color: red">注意：</span></p><ol><li><p>for 循环的迭代范围必须是确定的。</p><p>对于数组而言，就是数组中第一个元素和最后一个元素的范围。</p><p>对于类而言，类应该提供 begin 和 end 方法来确定循环范围。</p></li><li><p>迭代的对象要实现 ++ 和 == 操作。</p></li></ol><h2 id="nullptr（C-11）"><a href="#nullptr（C-11）" class="headerlink" title="nullptr（C++11）"></a>nullptr（C++11）</h2><p>NULL 可能被定义为字面常量 0，或者被定义为无类型指针 void * 的常量。</p>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV-图片几何变换</title>
      <link href="/2019/07/26/OpenCV-%E5%9B%BE%E7%89%87%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2/"/>
      <url>/2019/07/26/OpenCV-%E5%9B%BE%E7%89%87%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>缩放、裁剪、平移、镜像、旋转、仿射变换、透视变换。</p><span id="more"></span><p>OpenCV 提供了两个变换函数：cv2.warpAffine 和 cv2.warpPerspective，使用这两个函数可以实现所有类型的变换。</p><p>cv2.warpAffine 接收的参数是 2 * 3 的变换矩阵，cv2.warpPerspective 接收的是 3 * 3 的变换矩阵。</p><h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><p>扩展、缩放只是改变图像尺寸的大小。涉及到一些数学算法：最近邻域插值法、双线性插值法、立方插值法等。</p><p>cv2.resize() 可以实现扩展、缩放的功能，图像的尺寸可以自己手动设置，也可以指定缩放因子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> cv::cuda::<span class="built_in">resize</span>(</span><br><span class="line">InputArray src,</span><br><span class="line">  OutputArray dst,</span><br><span class="line">  Size dsize,</span><br><span class="line">  <span class="type">double</span> fx = <span class="number">0</span>,</span><br><span class="line">  <span class="type">double</span> fy = <span class="number">0</span>,</span><br><span class="line">  <span class="type">int</span> interpolation = INTER_LINEAR,</span><br><span class="line">  Stream &amp; stream = Stream::<span class="built_in">Null</span>() </span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>参数说明：具体查官方文档。</p><blockquote><p>在缩放时我们推荐使用 <strong>cv2.INTER_AREA</strong>，在扩展时我们推荐使用 <strong>v2.INTER_CUBIC</strong>(慢) 和 <strong>v2.INTER_LINEAR</strong>。默认情况下所有改变图像尺寸大小的操作使用的插值方法都是 <strong>cv2.INTER_LINEAR</strong>。</p></blockquote><table><thead><tr><th>interpolation 选项</th><th>所用的插值方法</th></tr></thead><tbody><tr><td>INTER_NEAREST</td><td>最近邻插值</td></tr><tr><td>INTER_LINEAR</td><td>双线性插值<span style="color: red">（默认）</span></td></tr><tr><td>INTER_AREA</td><td>使用像素区域关系进行重采样。 它可能是图像抽取的首选方法，因为它会产生无云纹理的结果。 但是当图像缩放时，它类似于 INTER_NEAREST 方法。</td></tr><tr><td>INTER_CUBIC</td><td>4x4像素邻域的双三次插值</td></tr><tr><td>INTER_LANCZOS4</td><td>8x8像素邻域的 Lanczos 插值</td></tr></tbody></table><p><strong>栗子：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;../messi5.jpg&#x27;</span>)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;img&#x27;</span>, img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面的 None 本应该是输出图像的尺寸，但是后面设置了缩放因子 fx 和 fy，所以这里为 None</span></span><br><span class="line">bg_img = cv2.resize(img, <span class="literal">None</span>, fx=<span class="number">2</span>, fy=<span class="number">2</span>, interpolation=cv2.INTER_CUBIC)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;bg_img&#x27;</span>, bg_img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意下面的 resize 的输出图像尺寸是一个有 2 个 int 类型的元组</span></span><br><span class="line">height, width = img.shape[:<span class="number">2</span>]</span><br><span class="line">sm_img = cv2.resize(img, (<span class="built_in">int</span>(<span class="number">0.5</span>*width), <span class="built_in">int</span>(<span class="number">0.5</span>*height)), interpolation=cv2.INTER_AREA)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;sm_img&#x27;</span>, sm_img)</span><br><span class="line"></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2019/07/26/5d3ac42acc2af35305.png" style="width: 50%"><h2 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h2><p>裁剪很方便，图片在存储时是二维的再加一个颜色通道值。</p><p>裁剪的话就是从这个二维矩阵上取下来一部分。</p><p><strong>栗子：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">src_img = cv2.imread(<span class="string">&#x27;../messi5.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line">dst_img = src_img[<span class="number">200</span>:<span class="number">700</span>, <span class="number">300</span>:<span class="number">600</span>]</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&#x27;dst&#x27;</span>, dst_img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2019/07/26/5d3acbf5506d269974.png" style="width: 50%"><h2 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h2><p>平移就是将对象换一个位置。如果要沿着（x，y）方向移动，移动的距离为（$t_x ，t_y$），可以以下面的方式构建移动矩阵：<br>$$<br>M =<br>\begin{bmatrix}<br>1&amp;0&amp;t_x\<br>0&amp;1&amp;t_y\<br>\end{bmatrix}<br>$$<br>使用 Numpy 数组构建这个矩阵，然后传递给 cv2.warpAffine()。</p><p><span style="color: red">注意：函数 cv2.warpAffine() 的第三个参数是输出图像的大小，格式是图像的（宽，高）。应该记住的是图像的 宽 = 列数，高 = 行数。</span></p><p><strong>栗子：</strong>$t_x = 100,t_y = 50$ 向右平移 100 像素，向下平移 50 像素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;../messi5.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line">M = np.float32([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">100</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">50</span>]])</span><br><span class="line"></span><br><span class="line">height, width = img.shape[:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">moved_img = cv2.warpAffine(img, M, (width, height))</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&#x27;moved_img&#x27;</span>, moved_img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2019/07/26/5d3ad163330f884551.png" width="50%"><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>镜像……先创建一个足够大的画布，然后把图片正着来一遍，反着来一遍。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;../LinuxLogo.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line">h, w, d = img.shape[:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">new_img_info = (h * <span class="number">2</span>, w, d)</span><br><span class="line">new_img = np.zeros(new_img_info, np.uint8)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, h):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, w):</span><br><span class="line">        new_img[i, j] = img[i, j]</span><br><span class="line">        new_img[h * <span class="number">2</span> - i - <span class="number">1</span>, j] = img[i, j]</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&#x27;new_img&#x27;</span>, new_img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><img style="width: 30%" src="https://i.loli.net/2019/07/26/5d3aea2f4d0eb49656.png"><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>对于一个图像旋转角度 $\theta$ ，需要使用下面形式的旋转矩阵：<br>$$<br>M_1 =<br>\begin{bmatrix}<br>cos \theta &amp; -sin \theta\<br>sin \theta &amp; cos \theta\<br>\end{bmatrix}<br>$$<br>OpenCV 允许在任意地方进行旋转，但旋转矩阵形式和上面不同：<br>$$<br>M_2 =<br>\begin{bmatrix}<br>\alpha &amp; \beta &amp; (1-\alpha) ·center.x - \beta·center.y \<br>-\beta &amp; \alpha &amp; \beta·center.x + (1-\alpha)·center.x<br>\end{bmatrix} \<br>其中：\alpha = scale·cos \theta ，\beta = scale·sin\theta，scale规模<br>$$<br>好吧，还是蛮麻烦的，还好看书的时候书中有提到：为了构建这个旋转矩阵，OpenCV 提供了一个函数 **cv2.getRotationMatrix2D()**。</p><p>getRotationMatrix2D() 参数：第一个是旋转中心，第二个是旋转角度，第三个是缩放系数。</p><p><strong>栗子：图像绕中心点旋转 $90^°$， 不缩放</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;../WindowsLogo.jpg&#x27;</span>)</span><br><span class="line">rows, cols = img.shape[:<span class="number">2</span>]  <span class="comment"># h = rows    w = cols</span></span><br><span class="line"></span><br><span class="line">M2 = cv2.getRotationMatrix2D((cols/<span class="number">2</span>, rows/<span class="number">2</span>), <span class="number">90</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">dst = cv2.warpAffine(img, M2, (cols, rows))</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&#x27;src&#x27;</span>, img)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;dst&#x27;</span>, dst)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2019/07/26/5d3aefe4f26b394211.png" style="width: 30%"><h3 id="翻转"><a href="#翻转" class="headerlink" title="翻转"></a>翻转</h3><p>cv2.flip() 函数可以直接帮我们把图像翻转。</p><p>参数：第一个参数为 src 图像，第二个参数是翻转方向。1 水平翻转，0 垂直翻转，-1 垂直+水平翻转。</p><p><strong>栗子：翻转</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">src = cv2.imread(<span class="string">&#x27;../LinuxLogo.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line">dst1 = cv2.flip(src, <span class="number">1</span>)</span><br><span class="line">dst0 = cv2.flip(src, <span class="number">0</span>)</span><br><span class="line">dst_1 = cv2.flip(src, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&#x27;src&#x27;</span>, src)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;dst0&#x27;</span>, dst0)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;dst1&#x27;</span>, dst1)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;dst_1&#x27;</span>, dst_1)</span><br><span class="line"></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2019/07/26/5d3af1c0ebe5613319.png"/><h2 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h2><p>在仿射变换中，原图中的所有的平行线在结果图像中同样平行。为了创建这个矩阵需要从图像中找到三个点以及他们在输出图像中的位置。然后使用 <strong>cv2.getAffineTransform</strong> 创建一个 2 * 3 的矩阵，传给 <strong>cv2.warpAffine</strong>。</p><p><strong>栗子：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">src = cv2.imread(<span class="string">&#x27;../WindowsLogo.jpg&#x27;</span>)</span><br><span class="line">r, c, d = src.shape</span><br><span class="line"><span class="built_in">print</span>(r, c, d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 原图像上的三个点</span></span><br><span class="line">pts1 = np.float32([</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>],  <span class="comment"># 左上角</span></span><br><span class="line">    [<span class="number">0</span>, r - <span class="number">1</span>],  <span class="comment"># 左下角</span></span><br><span class="line">    [c - <span class="number">1</span>, <span class="number">0</span>]  <span class="comment"># 右上角</span></span><br><span class="line">])</span><br><span class="line"><span class="comment"># 新图像上的三个点</span></span><br><span class="line">pts2 = np.float32([</span><br><span class="line">    [<span class="number">50</span>, <span class="number">50</span>],</span><br><span class="line">    [<span class="number">30</span>, r - <span class="number">20</span>],</span><br><span class="line">    [c - <span class="number">30</span>, <span class="number">10</span>]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">M = cv2.getAffineTransform(pts1, pts2)</span><br><span class="line"></span><br><span class="line">dst = cv2.warpAffine(src, M, (c, r))</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&#x27;src&#x27;</span>, src)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;dst&#x27;</span>, dst)</span><br><span class="line"></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/07/26/5d3af6bc1dd7474710.png"></p><img src="https://i.loli.net/2019/07/26/5d3af7db25ed486575.png" style="width: 50%"><h2 id="透视变换"><a href="#透视变换" class="headerlink" title="透视变换"></a>透视变换</h2><p>对于视角变换（透视变换），需要一个 3 * 3 的变换矩阵。在变换前后直线还是直线，要构建这个变换矩阵，需要在图像上找 4 个点，以及他们在输出图像上对应的位置。</p><p>这四个点中的任意三个都不能共线。这个变换矩阵可以由函数 <strong>cv2.getPerspectiveTransform()</strong> 构建。然后把这个矩阵传给函数 **cv2.warpPerspective()**。</p><p><strong>栗子：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">src = cv2.imread(<span class="string">&#x27;../sudoku.png&#x27;</span>)</span><br><span class="line">h, w, d = src.shape</span><br><span class="line"></span><br><span class="line"><span class="comment"># 原图像上的 4 个点</span></span><br><span class="line">pts1 = np.float32([</span><br><span class="line">    [<span class="number">56</span>, <span class="number">65</span>], [<span class="number">368</span>, <span class="number">52</span>], [<span class="number">28</span>, <span class="number">387</span>], [<span class="number">389</span>, <span class="number">390</span>]</span><br><span class="line">])</span><br><span class="line"><span class="comment"># 原图像上的点在目标图像上的点映射</span></span><br><span class="line">pts2 = np.float32([</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>], [<span class="number">300</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">300</span>], [<span class="number">300</span>, <span class="number">300</span>]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">M = cv2.getPerspectiveTransform(pts1, pts2)</span><br><span class="line"></span><br><span class="line">dst = cv2.warpPerspective(src, M, (<span class="number">300</span>, <span class="number">300</span>))</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&#x27;src&#x27;</span>, src)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;dst&#x27;</span>, dst)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/07/26/5d3b0a0f470db27199.png"></p><hr>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django-Cookie和Session</title>
      <link href="/2019/07/23/Django-Cookie%E5%92%8CSession/"/>
      <url>/2019/07/23/Django-Cookie%E5%92%8CSession/</url>
      
        <content type="html"><![CDATA[<p>all right，Cookie🍪 和 Session 并不是 Python 中特有的东西，只是我在学习 Django 框架的时候才搞清楚了其工作方式，所以记录在此。</p><p>在和学长写项目的过程中，只是有所了解，并不知道这是哪块小饼干，什么味道。</p><p>一直在用 GitHub，发现 GitHub 可以好久不用登陆，今天搞清楚了 Cookie 和 Session 的方式后打开 GitHub 看了下，明白liao~</p><p><img src="https://i.loli.net/2019/07/23/5d371106d7d7d16846.png" alt="访问 GitHub"></p><span id="more"></span><p>先说下状态保持吧。HTTP 协议是无状态的，下一次去访问一个页面并不知道上一次对这个页面做了什么东西。</p><p>所以就需要双方（浏览器和服务器）写一些小纸条记着。Cookie 和 Session 就是这两个人写的小纸条。</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>Cookie 是由服务器生成，<em><strong>存储在浏览器端</strong></em>的一小段文本信息。</p><p><strong>Cookie 的特点：</strong></p><ol><li>以键值对方式进行存储；</li><li>通过浏览器访问一个网站时，会将浏览器存储的跟此网站相关的所有 Cookie 信息在请求的时候发给该网站的服务器；</li><li>Cookie 是域名安全的；</li><li>Cookie 是由过期时间的，如果服务器不指定，默认关闭浏览器之后 Cookie 就会过期。</li></ol><p><img src="https://i.loli.net/2019/07/23/5d3712f08fffc13778.png" alt="Cookie"></p><p><strong>Django 设置和读取 Cookie：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;views.py&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_cookie</span>(<span class="params">req</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;设置cookie 信息&quot;&quot;&quot;</span></span><br><span class="line">    resp = HttpResponse(<span class="string">&#x27;设置 cookie&#x27;</span>)</span><br><span class="line">    <span class="comment"># 设置一个 cookie，名字为 num，值为 1，两周之后过期</span></span><br><span class="line">    resp.set_cookie(<span class="string">&#x27;num&#x27;</span>, <span class="number">1</span>, max_age=<span class="number">14</span> * <span class="number">24</span> * <span class="number">3600</span>)</span><br><span class="line">    <span class="comment"># resp.set_cookie(&#x27;num&#x27;, 1, expires=datetime.now()+timedelta(days=14)) # 与上同理</span></span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_cookie</span>(<span class="params">req</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;获取 cookie 信息&quot;&quot;&quot;</span></span><br><span class="line">    num = req.COOKIES[<span class="string">&#x27;num&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(num)</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/07/23/5d371522e7b7647793.png" alt="设置 Cookie"></p><p><img src="https://i.loli.net/2019/07/23/5d3715d25cdaf93771.png" alt="得到的 Cookie 里的值"></p><p><strong>Django 用户登录案例，Cookie 保存用户名：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;views.py&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">req</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;登录页面&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 获取 cookie 中的 username</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;username&#x27;</span> <span class="keyword">in</span> req.COOKIES:</span><br><span class="line">        username = req.COOKIES[<span class="string">&#x27;username&#x27;</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        username = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> render(req, <span class="string">&#x27;booktest/login.html&#x27;</span>, &#123;<span class="string">&#x27;username&#x27;</span>: username&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login_check</span>(<span class="params">req</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;登录验证&quot;&quot;&quot;</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;req.POST 保存 post 提交的参数， req.Get 保存 get 提交参数，参数类型都是 QueryDict 类型的对象&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 获取提交的用户名和密码</span></span><br><span class="line">    username = req.POST.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">    password = req.POST.get(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">    remember = req.POST.get(<span class="string">&#x27;remember&#x27;</span>)  <span class="comment"># on / None</span></span><br><span class="line">    <span class="comment"># 校验，根据用户名密码查找数据库</span></span><br><span class="line">    <span class="keyword">if</span> username == <span class="string">&#x27;ahojcn&#x27;</span> <span class="keyword">and</span> password == <span class="string">&#x27;200212&#x27;</span>:</span><br><span class="line">        resp = redirect(<span class="string">&#x27;/booktest/index&#x27;</span>)</span><br><span class="line">        <span class="comment"># 判断是否需要记住用户名</span></span><br><span class="line">        <span class="keyword">if</span> remember == <span class="string">&#x27;on&#x27;</span>:</span><br><span class="line">            resp.set_cookie(<span class="string">&#x27;username&#x27;</span>, username, max_age=<span class="number">7</span> * <span class="number">24</span> * <span class="number">3600</span>)  <span class="comment"># 记住 1 周</span></span><br><span class="line">        <span class="comment"># 用户名密码正确，跳转到首页</span></span><br><span class="line">        <span class="keyword">return</span> resp</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 用户名或密码错误，跳转到登录页面</span></span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&#x27;/booktest/login&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- login.html --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;login_check&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">        用户名：</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123; username &#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">        密码：</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;remember&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span>记住用户名<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/07/23/5d371785e530647720.png" alt="记住用户名"></p><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>Session 类似于我们老家镇子上的超市的做法。</p><p>我办了一张会员卡，会员号是我的手机号，每次我买完东西结账小姐姐总会问：“有会员嘛？会员号多少？(手动陕西话)”。我说：xxxxxx。</p><p>我的会员信息保存在小姐姐他们的电脑上，她给了我会员号。</p><p><strong>Session 的特点：</strong></p><ol><li>Session 存储在服务端，以<strong>键值对</strong>进行存储的；</li><li>Session 依赖于 Cookie，唯一的标识码保存在 cookie 中；</li><li>Session 也是有过期时间，如果不指定，默认是两周过期。</li></ol><p><img src="https://i.loli.net/2019/07/23/5d371c8e2f34b61895.png"></p><p><strong>Django 设置和获取 Session：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;views.py&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_session</span>(<span class="params">req</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;设置 session&quot;&quot;&quot;</span></span><br><span class="line">    req.session[<span class="string">&#x27;username&#x27;</span>] = <span class="string">&#x27;ahojcn&#x27;</span></span><br><span class="line">    req.session[<span class="string">&#x27;age&#x27;</span>] = <span class="number">19</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;设置 session&#x27;</span>)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_session</span>(<span class="params">req</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;获取 session&quot;&quot;&quot;</span></span><br><span class="line">    username = req.session[<span class="string">&#x27;username&#x27;</span>]</span><br><span class="line">    age = req.session[<span class="string">&#x27;age&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(username + <span class="string">&quot;:&quot;</span> + <span class="built_in">str</span>(age))</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/07/23/5d371db6e391642544.png" alt="set session"></p><p><img src="https://i.loli.net/2019/07/23/5d371e443c6d434659.png" alt="get session"></p><p><strong>记住用户登录状态：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;views.py&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">req</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;登录页面&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 判断用户是否登录</span></span><br><span class="line">    <span class="keyword">if</span> req.session.has_key(<span class="string">&#x27;islogin&#x27;</span>):</span><br><span class="line">        <span class="comment"># 已登录，跳转到首页</span></span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&#x27;/booktest/index&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 获取 cookie 中的 username</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;username&#x27;</span> <span class="keyword">in</span> req.COOKIES:</span><br><span class="line">            username = req.COOKIES[<span class="string">&#x27;username&#x27;</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            username = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> render(req, <span class="string">&#x27;booktest/login.html&#x27;</span>, &#123;<span class="string">&#x27;username&#x27;</span>: username&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login_check</span>(<span class="params">req</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;登录验证&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 获取提交的用户名和密码</span></span><br><span class="line">    username = req.POST.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">    password = req.POST.get(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">    remember = req.POST.get(<span class="string">&#x27;remember&#x27;</span>)  <span class="comment"># on / None</span></span><br><span class="line">    <span class="comment"># 校验，根据用户名密码查找数据库</span></span><br><span class="line">    <span class="keyword">if</span> username == <span class="string">&#x27;ahojcn&#x27;</span> <span class="keyword">and</span> password == <span class="string">&#x27;200212&#x27;</span>:</span><br><span class="line">        resp = redirect(<span class="string">&#x27;/booktest/index&#x27;</span>)</span><br><span class="line">        <span class="comment"># 判断是否需要记住用户名</span></span><br><span class="line">        <span class="keyword">if</span> remember == <span class="string">&#x27;on&#x27;</span>:</span><br><span class="line">            resp.set_cookie(<span class="string">&#x27;username&#x27;</span>, username, max_age=<span class="number">7</span> * <span class="number">24</span> * <span class="number">3600</span>)  <span class="comment"># 记住 1 周</span></span><br><span class="line">        <span class="comment"># 记录用户登录状态</span></span><br><span class="line">        req.session[<span class="string">&#x27;islogin&#x27;</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 用户名密码正确，跳转到首页</span></span><br><span class="line">        <span class="keyword">return</span> resp</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 用户名或密码错误，跳转到登录页面</span></span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">&#x27;/booktest/login&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- login.html --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;login_check&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">        用户名：</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123; username &#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">        密码：</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;remember&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span>记住用户名<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/07/23/5d37201138e1661315.gif" alt="test"></p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>cookie：记住用户名之类的，安全性要求不高用。</p><p>session：涉及到安全性要求比较高的数据用。</p><hr>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django-模型</title>
      <link href="/2019/07/16/Django-%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/07/16/Django-%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>Python=3.7.3 Django=2.2.3 MySQL=5.7 PyMySQL=0.9.3</p><span id="more"></span><h2 id="ORM-简介"><a href="#ORM-简介" class="headerlink" title="ORM 简介"></a>ORM 简介</h2><p>Object-Relation Mapping，对象-关系映射。</p><p><img src="https://i.loli.net/2019/07/22/5d35a46362ff271641.png" alt="ORM"></p><h3 id="使用-MySQL"><a href="#使用-MySQL" class="headerlink" title="使用 MySQL"></a>使用 MySQL</h3><p>在项目的 settings.py 中配置 DATABASES 项：</p><p><img src="https://i.loli.net/2019/07/16/5d2d30250b46934082.png"></p><p>当然光是这些还是不能使用数据库的，还要是用 PyMySQL 来驱动。</p><p>使用 pip install pymysql 后，还会有一些版本问题的坑，我碰到了一个，解决方法：<a href="https://blog.csdn.net/weixin_33127753/article/details/89100552">https://blog.csdn.net/weixin_33127753/article/details/89100552</a></p><h2 id="模型类"><a href="#模型类" class="headerlink" title="模型类"></a>模型类</h2><h3 id="模型类属性命名限制"><a href="#模型类属性命名限制" class="headerlink" title="模型类属性命名限制"></a>模型类属性命名限制</h3><ol><li><p>不能是 Python 的保留字</p></li><li><p>不能使用连续的下划线，因为 Django 中的查询要用到双下划线</p></li><li><p>定义属性时要指定字段类型，通过字段类型的参数指定选项，语法如下</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml">属性名 = models.字段类型(选项)</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="字段类型"><a href="#字段类型" class="headerlink" title="字段类型"></a>字段类型</h3><p>字段类型在 django.db.models 包中。</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>AutoField</td><td>自动增长的 IntegerField，通常不用指定，不指定时 Django 会自动创建属性名为 id 的自动增长属性。</td></tr><tr><td>BooleanField</td><td>布尔字段，值为 True 或 False。</td></tr><tr><td>NullBooleanField</td><td>支持 Null、True、False 三种值。</td></tr><tr><td>CharField(max_length=最大长度)</td><td>字符串。参数 max_length 表示最大字符个数。</td></tr><tr><td>TextField</td><td>大文本字段，一般超过 4000 个字符时使用。</td></tr><tr><td>IntegerField</td><td>整数。</td></tr><tr><td>DecimalField(max_digits=None,decimal_places=None)</td><td>十进制浮点数，参数 max_digits 表示总位。参数 decimal_places 表示小数位数。</td></tr><tr><td>FloatField</td><td>浮点数，参数同上。</td></tr><tr><td>DateField([auto_now=False,auto_now_add=False])</td><td>日期。1. 参数 auto_now 表示每次保存对象时，自动设置该字段为当前时间，用于”最后一次修改”的时间戳，它总是使用当前日期，默认为 false。2. 参数auto_now_add表示当对象第一次被创建时自动设置当前时间，用于创建的时间戳，它总是使用当前日期，默认为 false。3. 参数 auto_now_add 和 auto_now 是相互排斥的，组合将会发生错误。</td></tr><tr><td>TimeField</td><td>时间，参数同 DateField。</td></tr><tr><td>DateTimeField</td><td>日期时间，参数同 DateField。</td></tr><tr><td>FileField</td><td>上传文件字段。</td></tr><tr><td>ImageField</td><td>继承于 FileField，对上传的内容进行校验，确保是有效的图片。</td></tr></tbody></table><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p>通过选项实现对字段的约束。</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>default</td><td>默认值。</td></tr><tr><td>primary_key</td><td>若为 True，则该字段会成为模型的主键字段，默认值 False，一般作为 AutoField 的选项使用。</td></tr><tr><td>unique</td><td>如果为 True，这个字段在表中必须有唯一值，默认 False。</td></tr><tr><td>db_index</td><td>若值为 True，则表中会为此字段创建索引，默认值是 False。</td></tr><tr><td>db_column</td><td>字段的名称，如果未指定，则使用属性的名称。</td></tr><tr><td>null</td><td>如果为 True，表示允许为空，默认值 False。</td></tr><tr><td>blank</td><td>如果为 True，则该字段允许为空白，默认值 False。</td></tr></tbody></table><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><p>创建个对象，然后给对象的属性赋值，对象.save()。</p><h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><p>获取要删除的对象，对象.delete()。</p><h4 id="改"><a href="#改" class="headerlink" title="改"></a>改</h4><p>改嘛，获取到对象，然后赋值再save()。</p><h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><p>灵魂来了。</p><h5 id="查询函数"><a href="#查询函数" class="headerlink" title="查询函数"></a>查询函数</h5><p>通过 模型类.objects 可以调用下面的函数，实现对模型类对应的数据表查询。</p><table><thead><tr><th>函数名</th><th>功能</th><th>返回值</th><th>说明</th></tr></thead><tbody><tr><td>get</td><td>返回表中满足条件的<strong>一条并且只能有一条</strong>数据。</td><td>一个模型类对象。</td><td>参数中写查询条件。1. 如果查询到多条数据，抛异常：MultipleObjectsReturned。2. 查询不到数据，抛异常：DoesNotExist。</td></tr><tr><td>all</td><td>返回模型类型对应表中的所有数据。</td><td>QuerySet 类型。</td><td>查询集。</td></tr><tr><td>filter</td><td>返回满足条件的数据集。</td><td>QuerySet 类型。</td><td>参数写查询条件。</td></tr><tr><td>exclude</td><td>返回不满足条件的数据。</td><td>QuerySet类型。</td><td>参数写查询条件。</td></tr><tr><td>order_by</td><td>对查询结果进行排序。</td><td>QuerySet类型。</td><td>参数中写根据哪些字段进行排序。</td></tr></tbody></table><p>栗子：</p><ul><li><p>查询图书 id 为 3 的图书信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>BookInfo.objects.get(<span class="built_in">id</span>=<span class="number">3</span>)</span><br><span class="line">&lt;BookInfo: 笑傲江湖&gt;</span><br></pre></td></tr></table></figure></li><li><p>查询所有图书信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>BookInfo.objects.<span class="built_in">all</span>()</span><br><span class="line">&lt;QuerySet [&lt;BookInfo: 射雕英雄传&gt;, &lt;BookInfo: 天龙八部&gt;, &lt;BookInfo: 雪山飞狐&gt;, &lt;BookInfo: test0&gt;, &lt;BookInfo: test1&gt;]&gt;</span><br></pre></td></tr></table></figure></li><li><p>查询图书评论量为 34 的图书信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>BookInfo.objects.<span class="built_in">filter</span>(bread__gt=<span class="number">34</span>)</span><br><span class="line">&lt;QuerySet [&lt;BookInfo: 天龙八部&gt;, &lt;BookInfo: 雪山飞狐&gt;]&gt;</span><br></pre></td></tr></table></figure></li></ul><p>其他：</p><ol><li><p>判等 exact</p><p>查询编号为 1 的图书</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>&gt;&gt;&gt; BookInfo.objects.<span class="built_in">filter</span>(id__exact=<span class="number">1</span>)</span><br><span class="line">&lt;QuerySet [&lt;BookInfo: 射雕英雄传&gt;]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>BookInfo.objects.get(<span class="built_in">id</span>=<span class="number">1</span>)</span><br><span class="line">&lt;BookInfo: 射雕英雄传&gt;</span><br></pre></td></tr></table></figure></li><li><p>模糊查询 contains、endswith、startswith</p><p>查询书名包含’传’的图书</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>BookInfo.objects.<span class="built_in">filter</span>(btitle__contains=<span class="string">&#x27;传&#x27;</span>)</span><br><span class="line">&lt;QuerySet [&lt;BookInfo: 射雕英雄传&gt;]&gt;</span><br></pre></td></tr></table></figure><p>查询书名以’部’结尾的图书</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>BookInfo.objects.<span class="built_in">filter</span>(btitle__endswith=<span class="string">&#x27;部&#x27;</span>)</span><br><span class="line">&lt;QuerySet [&lt;BookInfo: 天龙八部&gt;]&gt;</span><br></pre></td></tr></table></figure></li><li><p>空查询 isnull</p><p>查询书名不为空的图书</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>BookInfo.objects.<span class="built_in">filter</span>(btitle__isnull=<span class="literal">False</span>)</span><br><span class="line">&lt;QuerySet [&lt;BookInfo: 射雕英雄传&gt;, &lt;BookInfo: 天龙八部&gt;, &lt;BookInfo: 笑傲江湖&gt;, &lt;BookInfo: 雪山飞狐&gt;, &lt;BookInfo: test0&gt;, &lt;BookInfo: test1&gt;]&gt;</span><br></pre></td></tr></table></figure></li><li><p>范围查询 in</p><p>查询 id 为 1 或 2 的图书</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>BookInfo.objects.<span class="built_in">filter</span>(id__in=[<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">&lt;QuerySet [&lt;BookInfo: 射雕英雄传&gt;, &lt;BookInfo: 天龙八部&gt;]&gt;</span><br></pre></td></tr></table></figure></li><li><p>比较查询 gt(greate than)、lt(less than)、gte(equal)大于等于、lte小于等于</p><p>查询 id 大于 2 的图书</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>BookInfo.objects.<span class="built_in">filter</span>(id__gt=<span class="number">2</span>)</span><br><span class="line">&lt;QuerySet [&lt;BookInfo: 笑傲江湖&gt;, &lt;BookInfo: 雪山飞狐&gt;, &lt;BookInfo: test0&gt;, &lt;BookInfo: test1&gt;]&gt;</span><br></pre></td></tr></table></figure></li><li><p>日期查询</p><p>查询 1980 年发表的图书</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>BookInfo.objects.<span class="built_in">filter</span>(bpub_date__year=<span class="number">1980</span>)</span><br><span class="line">&lt;QuerySet [&lt;BookInfo: 射雕英雄传&gt;]&gt;</span><br></pre></td></tr></table></figure><p>查询 1980-1-1 日后发表的图书</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>BookInfo.objects.<span class="built_in">filter</span>(bpub_date__gt=date(<span class="number">1980</span>,<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line">&lt;QuerySet [&lt;BookInfo: 射雕英雄传&gt;, &lt;BookInfo: 天龙八部&gt;, &lt;BookInfo: 笑傲江湖&gt;, &lt;BookInfo: 雪山飞狐&gt;, &lt;BookInfo: test0&gt;, &lt;BookInfo: test1&gt;]&gt;</span><br></pre></td></tr></table></figure></li><li><p>exclude</p><p>查询 id 不为 3 的图书信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>BookInfo.objects.exclude(<span class="built_in">id</span>=<span class="number">3</span>)</span><br><span class="line">&lt;QuerySet [&lt;BookInfo: 射雕英雄传&gt;, &lt;BookInfo: 天龙八部&gt;, &lt;BookInfo: 雪山飞狐&gt;, &lt;BookInfo: test0&gt;, &lt;BookInfo: test1&gt;]&gt;</span><br></pre></td></tr></table></figure></li><li><p>order_by</p><p>查询所有图书信息，按照 id <strong>从小到大</strong>进行排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>BookInfo.objects.<span class="built_in">all</span>().order_by(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">&lt;QuerySet [&lt;BookInfo: 射雕英雄传&gt;, &lt;BookInfo: 天龙八部&gt;, &lt;BookInfo: 雪山飞狐&gt;, &lt;BookInfo: test0&gt;, &lt;BookInfo: test1&gt;]&gt;</span><br></pre></td></tr></table></figure><p>查询所有图书信息，按照 id <strong>从大到小</strong>进行排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>BookInfo.objects.<span class="built_in">all</span>().order_by(<span class="string">&#x27;-id&#x27;</span>)</span><br><span class="line">&lt;QuerySet [&lt;BookInfo: test1&gt;, &lt;BookInfo: test0&gt;, &lt;BookInfo: 雪山飞狐&gt;, &lt;BookInfo: 天龙八部&gt;, &lt;BookInfo: 射雕英雄传&gt;]&gt;</span><br></pre></td></tr></table></figure><p>把 id 大于 3 的图书信息按阅读量聪大到小排序显示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>BookInfo.objects.<span class="built_in">filter</span>(id__gt=<span class="number">3</span>).order_by(<span class="string">&#x27;-bread&#x27;</span>)</span><br><span class="line">&lt;QuerySet [&lt;BookInfo: 雪山飞狐&gt;, &lt;BookInfo: test0&gt;, &lt;BookInfo: test1&gt;]&gt;</span><br></pre></td></tr></table></figure></li></ol><h5 id="F-对象、Q-对象"><a href="#F-对象、Q-对象" class="headerlink" title="F 对象、Q 对象"></a>F 对象、Q 对象</h5><p>F 对象用于类属性直线的比较，Q 属性用于查询条件之间的逻辑关系，and/or/not，可以有 &amp;|~ 操作。</p><p>首先要导入：from django.db.models import F, Q</p><p><strong>F：栗子</strong></p><ul><li><p>查询图书阅读量大于评论量的图书信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>BookInfo.objects.<span class="built_in">filter</span>(bread__gt=F(<span class="string">&#x27;bcomment&#x27;</span>))</span><br><span class="line">&lt;QuerySet [&lt;BookInfo: 雪山飞狐&gt;]&gt;</span><br></pre></td></tr></table></figure></li><li><p>查询图书阅读量大于 2 倍评论量的图书信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>BookInfo.objects.<span class="built_in">filter</span>(bread__gt=F(<span class="string">&#x27;bcomment&#x27;</span>)*<span class="number">2</span>)</span><br><span class="line">&lt;QuerySet [&lt;BookInfo: 雪山飞狐&gt;]&gt;</span><br></pre></td></tr></table></figure></li></ul><p><strong>Q：栗子</strong></p><ul><li><p>查询 id 大于 3 且阅读量大于 30 的图书信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>BookInfo.objects.<span class="built_in">filter</span>(id__gt=<span class="number">3</span>, bread__gt=<span class="number">30</span>)</span><br><span class="line">&lt;QuerySet [&lt;BookInfo: 雪山飞狐&gt;]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>BookInfo.objects.<span class="built_in">filter</span>(Q(id__gt=<span class="number">3</span>) &amp; Q(bread__gt=<span class="number">30</span>))</span><br><span class="line">&lt;QuerySet [&lt;BookInfo: 雪山飞狐&gt;]&gt;</span><br></pre></td></tr></table></figure></li><li><p>查询 id 大于 3 或者阅读量大于 30 的图书信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>BookInfo.objects.<span class="built_in">filter</span>(Q(id__gt=<span class="number">3</span>) | Q(bread__gt=<span class="number">30</span>))</span><br><span class="line">&lt;QuerySet [&lt;BookInfo: 天龙八部&gt;, &lt;BookInfo: 雪山飞狐&gt;, &lt;BookInfo: test0&gt;, &lt;BookInfo: test1&gt;]&gt;</span><br></pre></td></tr></table></figure></li><li><p>查询 id 不等于 3 的图书信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>BookInfo.objects.<span class="built_in">filter</span>(~Q(id__gt=<span class="number">3</span>))</span><br><span class="line">&lt;QuerySet [&lt;BookInfo: 射雕英雄传&gt;, &lt;BookInfo: 天龙八部&gt;, &lt;BookInfo: 笑傲江湖&gt;]&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h5><p>sum、count、avg、max、min</p><p>aggregate：调用这个函数来使用聚合，返回值是一个字典。</p><p>首先需要导入聚合函数：<code>from django.db.models import Sum, Count, Max, Min, Avg</code></p><p><strong>栗子：</strong></p><ul><li><p>查询所有图书的数量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>BookInfo.objects.<span class="built_in">all</span>().aggregate(Count(<span class="string">&#x27;id&#x27;</span>))</span><br><span class="line">&#123;<span class="string">&#x27;id__count&#x27;</span>: <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>查询所有图书阅读量的总和</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>BookInfo.objects.aggregate(Sum(<span class="string">&#x27;bread&#x27;</span>))</span><br><span class="line">&#123;<span class="string">&#x27;bread__sum&#x27;</span>: <span class="number">126</span>&#125;</span><br></pre></td></tr></table></figure></li></ul><p>count 函数返回一个数字，统计满足条件数据的数量。</p><p><strong>栗子：</strong></p><ul><li><p>统计所有图书的数量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>BookInfo.objects.<span class="built_in">all</span>().count()</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>BookInfo.objects.count()</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;这里不同是因为我的objects对象的all方法是自定义的，返回了isDelete=False的结果&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>统计 id 大于 3 的所有图书的树木</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>BookInfo.objects.<span class="built_in">filter</span>(id__gt=<span class="number">3</span>).count()</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="查询集"><a href="#查询集" class="headerlink" title="查询集"></a>查询集</h5><p>all、filter、exclude、order_by 调用这些函数会产生一个查询集，QuerySet 类对象可以继续调用上面的所有函数。</p><p><strong>查询集的特性：</strong></p><ol><li>惰性查询：只有在实际使用查询集中的数据的时候才会发生对数据库的整整查询</li><li>缓存：当使用的是同一个查询集时，第一次使用的时候会发生实际数据库的查询，然后把结果缓存起来，之后再使用这个查询集时，使用的是缓存中的结果。</li></ol><p><strong>限制查询集：</strong></p><p>可以对一个查询集进行_取下标或者切片_操作来限制查询集的结果。</p><p>对一个查询集进行切片操作会差生一个新的查询集，<strong>【下标不允许为负数】</strong>。</p><p>取出查询集第一条数据的两种方式：</p><table><thead><tr><th>方式</th><th>说明</th></tr></thead><tbody><tr><td>b[0]</td><td>如果不存在，会抛出 IndexError 异常。</td></tr><tr><td>b[0:1].get()</td><td>如果不存在，会抛出 DoesNotExist 异常。</td></tr></tbody></table><p>exists：判断一个查询集中是否由数据，True/False。</p><h5 id="关联查询（一对多）"><a href="#关联查询（一对多）" class="headerlink" title="关联查询（一对多）"></a>关联查询（一对多）</h5><p>查询和对象关联的数据：</p><p><img src="https://i.loli.net/2019/07/22/5d35c9ccbd1ce17566.png"></p><p>通过模型类实现关联查询：</p><p>【注意】</p><ol><li>通过模型类实现关联查询时，要查哪个表中的数据，就需要通过哪个类来查。</li><li>写关联查询条件的时候，如果类中没有关系属性，条件需要写对应类的名，如果类中有关系属性，直接写关系属性。</li></ol><p>通过多类的条件查询一类的数据：一类名.objects.filter(多类名小写__多类属性名__条件名) </p><p>通过一类的条件查询多类的数据：多类名.objects.filter(关联属性__一类属性名__条件名) </p><p><strong>栗子：</strong></p><ul><li><p>查询图书中关联的英雄描述包含‘八’</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>BookInfo.objects.<span class="built_in">filter</span>(heroinfo__hcomment__contains=<span class="string">&#x27;八&#x27;</span>)</span><br><span class="line">&lt;QuerySet [&lt;BookInfo: 射雕英雄传&gt;, &lt;BookInfo: 天龙八部&gt;]&gt;</span><br></pre></td></tr></table></figure></li><li><p>查询图书信息中英雄 id 大于 3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>BookInfo.objects.<span class="built_in">filter</span>(heroinfo__id__gt=<span class="number">3</span>)</span><br><span class="line">&lt;QuerySet [&lt;BookInfo: 射雕英雄传&gt;, &lt;BookInfo: 射雕英雄传&gt;, &lt;BookInfo: 射雕英雄传&gt;, &lt;BookInfo: 射雕英雄传&gt;, &lt;BookInfo: 射雕英雄传&gt;, &lt;BookInfo: 天龙八部&gt;, &lt;BookInfo: 天龙八部&gt;, &lt;BookInfo: 天龙八部&gt;, &lt;BookInfo: 天龙八部&gt;, &lt;BookInfo: 笑傲江湖&gt;, &lt;BookInfo: 笑傲江湖&gt;, &lt;BookInfo: 笑傲江湖&gt;, &lt;BookInfo: 笑傲江湖&gt;, &lt;BookInfo: 雪山飞狐&gt;, &lt;BookInfo: 雪山飞狐&gt;, &lt;BookInfo: 雪山飞狐&gt;, &lt;BookInfo: 雪山飞狐&gt;]&gt;</span><br></pre></td></tr></table></figure></li><li><p>查询书名为“天龙八部”的所有英雄</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>HeroInfo.objects.<span class="built_in">filter</span>(hbook__btitle=<span class="string">&#x27;天龙八部&#x27;</span>)</span><br><span class="line">&lt;QuerySet [&lt;HeroInfo: 乔峰&gt;, &lt;HeroInfo: 段誉&gt;, &lt;HeroInfo: 虚竹&gt;, &lt;HeroInfo: 王语嫣&gt;]&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="模型类关系"><a href="#模型类关系" class="headerlink" title="模型类关系"></a>模型类关系</h3><p><strong>一对多</strong></p><p>栗：图书类 - 英雄类，models.ForeignKey() 定义在多类中。</p><p><strong>多对多</strong></p><p>栗：新闻类 - 新闻类型类（体育新闻、国际新闻），models.ManyToManyField() 定义在哪个类都行。</p><p><strong>一对一</strong></p><p>栗：员工基本信息类 - 员工详细信息类，models.OneToOneField() 定义在哪个类都行。</p><h3 id="自关联"><a href="#自关联" class="headerlink" title="自关联"></a>自关联</h3><p>自关联是一种特殊的一对多的关系。</p><p><img src="https://i.loli.net/2019/07/22/5d35cd045fed233016.png"></p><h3 id="自定义管理器"><a href="#自定义管理器" class="headerlink" title="自定义管理器"></a>自定义管理器</h3><p>BookInfo.objects.all() 中的 objects 是一个什么东西呢？</p><p>objects 是 Django 自动生成的管理器对象，通过这个管理器可以实现对数据的查询。</p><p>objects 是 models.Manger 类的一个对象。</p><p>自定义管理器之后 Django 不再生成默认的 objects 管理器。</p><p><strong>自定义模型管理器类</strong></p><p>自定义一个管理器类，继承自 models.Manger 类，再在具体的模型类里定义一个自定义管理器类的对象。</p><p><strong>应用场景：</strong></p><ol><li><p>改变查询的结果集</p><p>比如调用 BookInfo.objects.all() 返回的是 isDelete=True 的图书的数据。</p></li><li><p>添加额外的方法</p><p>管理器类中定义一个方法，帮助我们操作模型类对应的数据表。</p><p>使用 self.model 就可以创建一个跟自定义管理器对应的模型类对象（解耦）。</p></li></ol><p>like this：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yourapp.models.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookInfoManager</span>(models.Manager):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;图书模型管理器类&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 改变查询的结果集</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">all</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 1. 获取所有的数据，调用父类的 all 方法</span></span><br><span class="line">        all_books = <span class="built_in">super</span>().<span class="built_in">all</span>()</span><br><span class="line">        <span class="comment"># 2. 对数据进行过滤</span></span><br><span class="line">        all_books = all_books.<span class="built_in">filter</span>(isDelete=<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">return</span> all_books</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 添加额外的方法，操作模型类对应的数据表，增删改查</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_book</span>(<span class="params">self, btitle, bpub_date</span>):</span><br><span class="line">        model_class = self.model  <span class="comment"># 获取 self 锁在的模型类</span></span><br><span class="line">        book = model_class()</span><br><span class="line"></span><br><span class="line">        book.btitle = btitle</span><br><span class="line">        book.bpub_date = bpub_date</span><br><span class="line">        book.save()</span><br><span class="line">        <span class="keyword">return</span> book</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookInfo</span>(models.Model):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;图书模型类&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 图书名</span></span><br><span class="line">    btitle = models.CharField(max_length=<span class="number">20</span>)</span><br><span class="line">    <span class="comment"># 出版日期</span></span><br><span class="line">    bpub_date = models.DateField()</span><br><span class="line">    <span class="comment"># 阅读量</span></span><br><span class="line">    bread = models.IntegerField(default=<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 评论量</span></span><br><span class="line">    bcomment = models.IntegerField(default=<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 逻辑删除标记，默认 False 代表未删除</span></span><br><span class="line">    isDelete = models.BooleanField(default=<span class="literal">False</span>)</span><br><span class="line">    <span class="comment"># 价格，最大位数 10，小数位 2，默认 0.0 ￥</span></span><br><span class="line">    bprice = models.DecimalField(max_digits=<span class="number">10</span>, decimal_places=<span class="number">2</span>, default=<span class="number">0.0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># book = models.Manager()  # 自定义一个 Manager 类对象</span></span><br><span class="line">    objects = BookInfoManager()  <span class="comment"># 自定义一个 BookInfoManager 类的对象</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/07/22/5d35d9f55772b10872.png"></p><h3 id="元选项"><a href="#元选项" class="headerlink" title="元选项"></a>元选项</h3><p>Django 默认生成的表名：应用名小写_模型类名小写</p><p>元选项需要在模型类中定义一个元类 Meta，在里面定义一个类属性 db_table 就可以指定表名。</p><!--more-->]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV-仿射变换、图片旋转</title>
      <link href="/2019/07/14/OpenCV-%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2%E3%80%81%E5%9B%BE%E7%89%87%E6%97%8B%E8%BD%AC/"/>
      <url>/2019/07/14/OpenCV-%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2%E3%80%81%E5%9B%BE%E7%89%87%E6%97%8B%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<p>图片仿射变换、图片旋转。</p><span id="more"></span><p>图片仿射变换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;../messi5.jpg&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;src&#x27;</span>, img)</span><br><span class="line"></span><br><span class="line">img_info = img.shape</span><br><span class="line">height = img_info[<span class="number">0</span>]</span><br><span class="line">width = img_info[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 点确定一个平面</span></span><br><span class="line"><span class="comment"># 仿射变换就是将 原图像 上的三个点映射到 目标图片 新的位置上</span></span><br><span class="line">mat_src = np.float32([[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, height - <span class="number">1</span>], [width - <span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line">mat_dst = np.float32([[<span class="number">50</span>, <span class="number">50</span>], [<span class="number">30</span>, height - <span class="number">20</span>], [width - <span class="number">30</span>, <span class="number">10</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到仿射变换矩阵</span></span><br><span class="line"><span class="comment"># 参数：原图像三个点的位置，这三个点的新的位置</span></span><br><span class="line">mat_affine = cv2.getAffineTransform(mat_src, mat_dst)</span><br><span class="line">dst = cv2.warpAffine(img, mat_affine, (width, height))</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&#x27;dst&#x27;</span>, dst)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/07/14/5d2b02dc9add355373.png" alt="仿射变换效果"></p><p>图片旋转：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;../WindowsLogo.jpg&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;src&#x27;</span>, img)</span><br><span class="line"></span><br><span class="line">imgInfo = img.shape</span><br><span class="line">height = imgInfo[<span class="number">0</span>]</span><br><span class="line">width = imgInfo[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 旋转矩阵</span></span><br><span class="line"><span class="comment"># getRotationMatrix2D 得到一个旋转矩阵</span></span><br><span class="line"><span class="comment"># 参数：旋转中心点、旋转角度、缩放系数</span></span><br><span class="line">matRotate = cv2.getRotationMatrix2D((height*<span class="number">0.5</span>, width*<span class="number">0.5</span>), <span class="number">45</span>, <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">dst = cv2.warpAffine(img, matRotate, (height, width))</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&#x27;dst&#x27;</span>, dst)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/07/14/5d2b0347bd2ba19250.png" alt="图片旋转效果"></p><p>获取图片旋转矩阵为什么要有缩放？</p><p>因为不缩放后图片就超出去了，缩放就是为了看清图片全貌。</p><p><img src="https://i.loli.net/2019/07/14/5d2b04031665c10552.png" alt="缩放系数==1表示不缩放"></p><hr>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV-图片移位</title>
      <link href="/2019/07/14/OpenCV-%E5%9B%BE%E7%89%87%E7%A7%BB%E4%BD%8D/"/>
      <url>/2019/07/14/OpenCV-%E5%9B%BE%E7%89%87%E7%A7%BB%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<p>cv2 的图片移位操作原理和实现。</p><span id="more"></span><p>调用 opencv 的 api 实现图片位移操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 读取图片</span></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;../messi5.jpg&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;src&#x27;</span>, img)</span><br><span class="line"></span><br><span class="line">img_info = img.shape</span><br><span class="line">height = img_info[<span class="number">0</span>]</span><br><span class="line">width = img_info[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">mat_shift = np.float32([</span><br><span class="line">    [<span class="number">1</span>, <span class="number">0</span>, <span class="number">100</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">200</span>]</span><br><span class="line">])  <span class="comment"># 2 * 3 的移位矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数：原始图片，移位矩阵，宽高</span></span><br><span class="line">dst = cv2.warpAffine(img, mat_shift, (height, width))</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&#x27;dst&#x27;</span>, dst)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/07/14/5d2aecbda580082864.png"></p><p><strong>原理：</strong></p><p>移位矩阵 mat_shift 是一个2 * 3的矩阵。</p><p>把移位矩阵拆成两个矩阵 A 和 B。<br>$$<br>matshift =<br>\begin{bmatrix}<br>1&amp;0&amp;100 \\<br>0&amp;1&amp;200<br>\end{bmatrix}<br>，<br>A =<br>\begin{bmatrix}<br>1&amp;0 \\<br>0&amp;1<br>\end{bmatrix}<br>，<br>B =<br>\begin{bmatrix}<br>100 \\<br>200<br>\end{bmatrix}<br>$$<br>输入的图像矩阵设为 C。<br>$$<br>A \times C + B =<br>\begin{bmatrix}<br>1&amp;0\\<br>0&amp;1<br>\end{bmatrix}<br>\times<br>\begin{bmatrix}<br>x\\<br>y<br>\end{bmatrix}<br>+<br>\begin{bmatrix}<br>100\\<br>200<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>1 \times x + 0 \times y\\<br>0 \times x + 1 \times y<br>\end{bmatrix}<br>+<br>\begin{bmatrix}<br>100\\<br>200<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>x + 100\\<br>y+ 200<br>\end{bmatrix}<br>$$<br>所以最终运算后得到的效果就是 x 向右移动 100 像素，y 向下移动 200 像素。</p><p>Python 实现图片移动：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;../messi5.jpg&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;src&#x27;</span>, img)</span><br><span class="line"></span><br><span class="line">img_info = img.shape</span><br><span class="line">height = img_info[<span class="number">0</span>]</span><br><span class="line">width = img_info[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">dst = np.zeros(img.shape, np.uint8)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, height):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, width-<span class="number">100</span>):</span><br><span class="line">        dst[i, j+<span class="number">100</span>] = img[i, j]</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&#x27;dst&#x27;</span>, dst)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/07/14/5d2af3bef168e75749.png" alt="效果"></p><hr>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV-图片缩放</title>
      <link href="/2019/07/14/OpenCV-%E5%9B%BE%E7%89%87%E7%BC%A9%E6%94%BE/"/>
      <url>/2019/07/14/OpenCV-%E5%9B%BE%E7%89%87%E7%BC%A9%E6%94%BE/</url>
      
        <content type="html"><![CDATA[<p>最近邻域插值法、双线性插值法。</p><span id="more"></span><p>OpenCV 中提供了 4 中常用的缩放方法，最近邻域差值、双线性差值、像素关系重采样、立方差值。默认采用<strong>双线性差值法</strong>来缩放图片。</p><p>缩放一张图片代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;../01image.JPG&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">img_info = img.shape</span><br><span class="line"><span class="built_in">print</span>(img_info)</span><br><span class="line"></span><br><span class="line">height = img_info[<span class="number">0</span>]  <span class="comment"># 原图高度</span></span><br><span class="line">width = img_info[<span class="number">1</span>]  <span class="comment"># 原图宽度</span></span><br><span class="line">mode = img_info[<span class="number">2</span>]  <span class="comment"># 原图的颜色模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 放大和缩小两种，又等比例缩放和非等比例缩放</span></span><br><span class="line"><span class="comment"># 等比例缩放：原始图像的宽高 * 一个相同的系数</span></span><br><span class="line"><span class="comment"># 非等比例缩放：原始宽高 * 不同的系数</span></span><br><span class="line"><span class="comment"># 下面是等比例缩放</span></span><br><span class="line">dst_height = <span class="built_in">int</span>(height * <span class="number">0.5</span>)</span><br><span class="line">dst_width = <span class="built_in">int</span>(width * <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">dst_img = cv2.resize(img, (dst_width, dst_height))</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&#x27;img&#x27;</span>, img)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;dst_img&#x27;</span>, dst_img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/07/14/5d2ad5f5ab27789916.png" alt="运行结果"></p><p>##最近邻域插值</p><p>在一维空间中，最近点插值就相当于四舍五入取整。在二维图像中，像素点的坐标都是整数，该方法就是选取离目标点最近的点。会在一定程度上损失<strong>空间对称性（Alignment）</strong>。</p><p>src 10*20<br>dst 5*10<br>dst &lt;- src<br>(1, 2) &lt;- (2, 4)</p><p>new_x = src_x * (src 行 / dst 行)<br>new_y = src_y * (src 列 / dst 列)<br>例如： (1, 2) 这个点<br>new_x = 1 * (10 / 5) = 2<br>new_y = 2 * (20 / 10) = 4</p><p>如果是像素点 12.3 则取 12。</p><blockquote><p>这是一种最基本、最简单的图像缩放算法，效果也是最不好的，放大后的图像有很严重的马赛克，缩小后的图像有很严重的失真；效果不好的根源就是其简单的最临 近插值方法引入了严重的图像失真，比如，当由目标图的坐标反推得到的源图的的坐标是一个浮点数的时候，采用了四舍五入的方法，直接采用了和这个浮点数最接 近的象素的值，这种方法是很不科学的，当推得坐标值为 0.75的时候，不应该就简单的取为1，既然是0.75，比1要小0.25 ，比0要大0.75 ,那么目标象素值其实应该根据这个源图中虚拟的点四周的四个真实的点来按照一定的规律计算出来的，这样才能达到更好的缩放效果。</p></blockquote><p>最近领域插值法Python代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">src_img = cv2.imread(<span class="string">&#x27;../WindowsLogo.jpg&#x27;</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">src_img_info = src_img.shape</span><br><span class="line">src_img_height = src_img_info[<span class="number">0</span>]</span><br><span class="line">src_img_width = src_img_info[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">dst_img_height = <span class="built_in">int</span>(src_img_height / <span class="number">2</span>)</span><br><span class="line">dst_img_width = <span class="built_in">int</span>(src_img_width / <span class="number">2</span>)</span><br><span class="line">dst_img = np.zeros((dst_img_height, dst_img_width, <span class="number">3</span>), np.uint8)  <span class="comment"># 0-255</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> dst_x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, dst_img_height):  <span class="comment"># 行</span></span><br><span class="line">    <span class="keyword">for</span> dst_y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, dst_img_width):  <span class="comment"># 列</span></span><br><span class="line">        src_x = <span class="built_in">int</span>(dst_x * (src_img_height * <span class="number">1.0</span> / dst_img_height))</span><br><span class="line">        src_y = <span class="built_in">int</span>(dst_y * (src_img_width * <span class="number">1.0</span> / dst_img_width))</span><br><span class="line">        dst_img[dst_x, dst_y] = src_img[src_x, src_y]</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&#x27;src_img&#x27;</span>, src_img)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;dst_img&#x27;</span>, dst_img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/07/14/5d2ad9113e5ca79382.png" alt="效果"></p><h2 id="双线性插值"><a href="#双线性插值" class="headerlink" title="双线性插值"></a>双线性插值</h2><p>A1 = 20% * 上点 + 80% * 下点，A2 相同。</p><p>B1 = 30% * 左点 + 70% * 右点，B2 相同。</p><p>最终点：A1 * 30% + A2 * 70% 或者 B1 * 20% + B2 * 80%。</p><p>注意这里 A1 和最终点的距离和 A2 距离最重点的距离是 0.3 和 0.7。</p><p><img src="https://i.loli.net/2019/07/14/5d2ade605e20316332.png"></p><p>双线性内插值法计算量大，但缩放后图像质量高，不会出现像素值不连续的的情况。由于双线性插值具有低通滤波器的性质，使高频分量受损，所以可能会使图像轮廓在一定程度上变得模糊。</p><hr><blockquote><p>资料：<br><a href="https://blog.csdn.net/JNingWei/article/details/78822026">https://blog.csdn.net/JNingWei/article/details/78822026</a><br><a href="https://blog.csdn.net/csdnforyou/article/details/82315683">https://blog.csdn.net/csdnforyou/article/details/82315683</a><br><a href="https://blog.csdn.net/coy_wang/article/details/5027872">https://blog.csdn.net/coy_wang/article/details/5027872</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV-粗略调整图片对比度和亮度</title>
      <link href="/2019/07/10/OpenCV-%E7%B2%97%E7%95%A5%E8%B0%83%E6%95%B4%E5%9B%BE%E7%89%87%E5%AF%B9%E6%AF%94%E5%BA%A6%E5%92%8C%E4%BA%AE%E5%BA%A6/"/>
      <url>/2019/07/10/OpenCV-%E7%B2%97%E7%95%A5%E8%B0%83%E6%95%B4%E5%9B%BE%E7%89%87%E5%AF%B9%E6%AF%94%E5%BA%A6%E5%92%8C%E4%BA%AE%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>基本原理：两张图片合成。</p><p>先按照原来的图片的格式新建一个色素全为零的图片，然后按照两张图的比例不同合成一张新图片。主要用到函数：addWeighted函数</p><span id="more"></span><blockquote><p>addWeighted()计算两个数组的加权和。函数addWeighted计算两个数组的加权和，如下所示：</p><p><img src="https://i.loli.net/2019/07/10/5d25f8c6a975089632.png"></p><p>其中我是数组元素的多维索引。在多通道阵列的情况下，每个通道都是独立处理的。该函数可以用矩阵表达式替换：<code>dst = src1*alpha + src2*beta + gamma;</code></p><p>Parameters 参数</p><table><thead><tr><th>src1</th><th>first input array.</th></tr></thead><tbody><tr><td>alpha</td><td>weight of the first array elements.</td></tr><tr><td>src2</td><td>second input array of the same size and channel number as src1.</td></tr><tr><td>beta</td><td>weight of the second array elements.</td></tr><tr><td>gamma</td><td>scalar added to each sum.</td></tr><tr><td>dst</td><td>output array that has the same size and number of channels as the input arrays.</td></tr><tr><td>dtype</td><td>optional depth of the output array; when both input arrays have the same depth, dtype can be set to -1, which will be equivalent to <a href="../../d0/daf/group__projection.html#ga8b5e5413af41caf3f2a0bbf4cdf517a8">src1.depth()</a>.</td></tr></tbody></table></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">contrast_brightness_demo</span>(<span class="params">image, c, b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;c 对比度；b 亮度&quot;&quot;&quot;</span></span><br><span class="line">    h, w, ch = image.shape  <span class="comment"># 获取shape的数值，height和width、通道</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 新建全零图片数组src2,将height和width，类型设置为原图片的通道类型(色素全为零，输出为全黑图片)</span></span><br><span class="line">    blank = np.zeros([h, w, ch], image.dtype)</span><br><span class="line"></span><br><span class="line">    dst = cv.addWeighted(image, c, blank, <span class="number">1</span>-c, b)</span><br><span class="line">    cv.imshow(<span class="string">&#x27;demo&#x27;</span>, dst)</span><br><span class="line">    </span><br><span class="line">test = cv.imread(<span class="string">&#x27;01image.JPG&#x27;</span>)</span><br><span class="line">contrast_brightness_demo(test, <span class="number">1.5</span>, <span class="number">50</span>)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/07/10/5d25fa3661cd186596.png" alt="效果图"></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV-像素运算</title>
      <link href="/2019/07/10/OpenCV-%E5%83%8F%E7%B4%A0%E8%BF%90%E7%AE%97/"/>
      <url>/2019/07/10/OpenCV-%E5%83%8F%E7%B4%A0%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>两张大小相等图片的运算（算数运算、逻辑运算）。</p><span id="more"></span><h2 id="算术运算-加减乘除"><a href="#算术运算-加减乘除" class="headerlink" title="算术运算 加减乘除"></a>算术运算 加减乘除</h2><p>相加：add()    </p><p>相减：subtract()    </p><p>相乘：divide()    </p><p>相除：multiply()</p><p>原理就是：通过获取两张（一次只能是两张）个图片的同一个位置的色素值来实现运算。</p><p>运算的要求：两张图片的shape要一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_demo</span>(<span class="params">m1, m2</span>):</span><br><span class="line">    dst = cv.add(m1, m2)</span><br><span class="line">    cv.imshow(<span class="string">&#x27;add_demo&#x27;</span>, dst)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub_demo</span>(<span class="params">m1, m2</span>):</span><br><span class="line">    dst = cv.subtract(m1, m2)</span><br><span class="line">    cv.imshow(<span class="string">&#x27;sub_demo&#x27;</span>, dst)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">div_demo</span>(<span class="params">m1, m2</span>):</span><br><span class="line">    dst = cv.divide(m2, m1)</span><br><span class="line">    cv.imshow(<span class="string">&#x27;div_demo&#x27;</span>, dst)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mul_demo</span>(<span class="params">m1, m2</span>):</span><br><span class="line">    dst = cv.multiply(m1, m2)</span><br><span class="line">    cv.imshow(<span class="string">&#x27;mul_demo&#x27;</span>, dst)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">img1 = cv.imread(<span class="string">&#x27;LinuxLogo.jpg&#x27;</span>)</span><br><span class="line">img2 = cv.imread(<span class="string">&#x27;WindowsLogo.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cv.namedWindow(<span class="string">&#x27;img1&#x27;</span>, cv.WINDOW_AUTOSIZE)</span><br><span class="line">cv.imshow(<span class="string">&#x27;img1&#x27;</span>, img1)</span><br><span class="line">cv.imshow(<span class="string">&#x27;img2&#x27;</span>, img2)</span><br><span class="line"></span><br><span class="line">add_demo(img1, img2)</span><br><span class="line">sub_demo(img1, img2)</span><br><span class="line">div_demo(img1, img2)</span><br><span class="line">mul_demo(img1, img2)</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/07/10/5d25f4d4117f845831.png" alt="加减乘除运算"></p><h2 id="其他运算-均值、方差"><a href="#其他运算-均值、方差" class="headerlink" title="其他运算 均值、方差"></a>其他运算 均值、方差</h2><p>均值、方差。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">other_demo</span>(<span class="params">m1, m2</span>):</span><br><span class="line">    <span class="comment"># im1 = cv.mean(m1)  # 求平均值，均值可以说明这个图像的主色调是什么</span></span><br><span class="line">    <span class="comment"># im2 = cv.mean(m2)</span></span><br><span class="line"></span><br><span class="line">    im1, dev1 = cv.meanStdDev(m1)  <span class="comment"># 得到均值和方差</span></span><br><span class="line">    im2, dev2 = cv.meanStdDev(m2)  <span class="comment"># 方差表示图片之间的差异性（对比度），方差是一个小于某个值，可能图像是无效的</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;img1&#x27;</span>, im1, dev1)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;img2&#x27;</span>, im2, dev2)</span><br></pre></td></tr></table></figure><h2 id="逻辑运算-与或非亦或"><a href="#逻辑运算-与或非亦或" class="headerlink" title="逻辑运算 与或非亦或"></a>逻辑运算 与或非亦或</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">logic_demo</span>(<span class="params">m1, m2</span>):</span><br><span class="line">    dst = cv.bitwise_and(m1, m2)  <span class="comment"># 与运算，做遮罩</span></span><br><span class="line">    cv.imshow(<span class="string">&#x27;and&#x27;</span>, dst)</span><br><span class="line">    dst = cv.bitwise_or(m1, m2)  <span class="comment"># 或运算</span></span><br><span class="line">    cv.imshow(<span class="string">&#x27;or&#x27;</span>, dst)</span><br><span class="line">    dst = cv.bitwise_not(m2)  <span class="comment"># 非操作，就是 255 - px</span></span><br><span class="line">    cv.imshow(<span class="string">&#x27;not&#x27;</span>, dst)</span><br><span class="line">    dst = cv.bitwise_xor(m1, m2)  <span class="comment"># 亦或运算</span></span><br><span class="line">    cv.imshow(<span class="string">&#x27;xor&#x27;</span>, dst)</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/07/10/5d25f6961609f11059.png" alt="逻辑运算"></p><hr>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django-初识Django开发</title>
      <link href="/2019/07/10/Django-%E5%88%9D%E8%AF%86Django%E5%BC%80%E5%8F%91/"/>
      <url>/2019/07/10/Django-%E5%88%9D%E8%AF%86Django%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p>Python=3.7.3 &amp; Django=2.2.3</p><span id="more"></span><h2 id="初识框架"><a href="#初识框架" class="headerlink" title="初识框架"></a>初识框架</h2><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><ul><li>M表示model，主要用于对数据库层的封装</li><li>V表示view，用于向用户展示结果</li><li>C表示controller，是核心，用于处理请求、获取数据、返回结果</li></ul><p>MVC框架的核心思想是：解耦，降低各功能模块之间的耦合性，方便变更，更容易重构代码，最大程度上实现代码的重用。</p><h3 id="MVT"><a href="#MVT" class="headerlink" title="MVT"></a>MVT</h3><p>Django 属于 MVT 框架。</p><ul><li>M表示model，负责与数据库交互</li><li>V表示view，是核心，负责接收请求、获取数据、返回结果</li><li>T表示template，负责呈现内容到浏览器</li></ul><p><img src="https://i.loli.net/2019/07/10/5d257a11af7db95884.png" alt="Django MVT"></p><h2 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h2><h3 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h3><p>virtualenv、virtualenvwrapper、anaconda。</p><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1019273143120480">资料：廖雪峰老湿的Python教程</a></p><p><a href="https://www.jianshu.com/p/a83a8f5d68dd?utm_campaign=maleskine&utm_content=note&utm_medium=writer_share&utm_source=weibo">资料：Python基础42-虚拟环境(创建/激活/操作/删除-virtualenv、Pycharm、virtualenvwrapper、pipenv)</a></p><h3 id="安装-Django"><a href="#安装-Django" class="headerlink" title="安装 Django"></a>安装 Django</h3><p>创建好虚拟环境，并进入虚拟环境。直接<code>pip3 install django</code>就可以，如果要指定版本<code>pip3 install django=1.8.1</code>。</p><p>安装好后可以使用<code>pip3 list</code>查看是否下载好Django 包。</p><p><img src="https://i.loli.net/2019/07/10/5d257bfd3cdab44108.png" alt="pip3 list"></p><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p><code>django-admin startproject test2</code>，创建出一个 test2 目录如下图，其中文件的意思是：</p><ul><li>manage.py：一个命令行工具，可以使用多种方式对Django项目进行交互</li><li>内层的目录：项目的真正的Python包</li><li>__init__.py：一个空文件，它告诉Python这个目录应该被看做一个Python包</li><li>settings.py：项目的配置</li><li>urls.py：项目的URL声明，我理解的是路由 router，根据 url 进行跳转。</li><li>wsgi.py：项目与 <a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017805733037760">WSGI</a> 兼容的Web服务器入口</li></ul><p><img src="https://i.loli.net/2019/07/10/5d257da1a5d0b48598.png" alt="test2 结构"></p><h2 id="Models-模型"><a href="#Models-模型" class="headerlink" title="Models 模型"></a>Models 模型</h2><p>Django 中 Models 主要是对数据库的一些操作（增删改查呗?），如笔记最开始的第一张图所示。</p><p>Django 支持的数据库包括：sqlite、mysql 等主流数据库，默认使用的示 sqlite 数据库。在settings.py文件中，通过 DATABASES 项进行数据库设置。</p><p><img src="https://i.loli.net/2019/07/10/5d25825d6841122918.png" alt="DATABASES 设置"></p><h3 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h3><p>在一个项目中可以创建一到多个应用，每个应用进行一种业务处理。</p><p><code>python manage.py startapp booktest</code></p><p><img src="https://i.loli.net/2019/07/10/5d25831a2752242843.png" alt="创建 booktest 应用"></p><h3 id="定义模型类"><a href="#定义模型类" class="headerlink" title="定义模型类"></a>定义模型类</h3><p>在 models.py 中定义模型类，模型类继承自 Django 的 models.Model 类。</p><p>每一个模型类对应一张数据表，主键是 Django 自己生成的自动增长类型，所以不用管主键。</p><p>模型类的类成员就是这张数据表中的属性。</p><p><strong>【注】</strong>使用 vscode、pycharm 等工具要配置一下当前是用的是虚拟环境中的 Python。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;models.py&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"><span class="comment"># 学校表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">School</span>(models.Model):</span><br><span class="line">    <span class="comment"># 学校名</span></span><br><span class="line">    school_name = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line">    <span class="comment"># 学校地址</span></span><br><span class="line">    school_addr = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line">    <span class="comment"># 建校日期</span></span><br><span class="line">    school_build_date = models.DateTimeField()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(models.Model):</span><br><span class="line">    <span class="comment"># 学生名</span></span><br><span class="line">    stu_name = models.CharField(max_length=<span class="number">20</span>)</span><br><span class="line">    <span class="comment"># 学生出生日期</span></span><br><span class="line">    stu_birth = models.DateTimeField()</span><br><span class="line">    <span class="comment"># 学生性别</span></span><br><span class="line">    stu_gender = models.BooleanField()</span><br><span class="line">    <span class="comment"># 学生是哪个学校的</span></span><br><span class="line">    stu_school = models.ForeignKey(<span class="string">&#x27;School&#x27;</span>, on_delete=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><h3 id="生成数据表"><a href="#生成数据表" class="headerlink" title="生成数据表"></a>生成数据表</h3><ol><li><p>激活模型</p><p>编辑 settings.py 文件，将 booktest 应用加入到 INSTALLED_APPS 中</p><p><img src="https://i.loli.net/2019/07/10/5d2588c5d4a6529343.png" alt="激活模型"></p></li><li><p>生成迁移文件：根据模型类生成sql语句</p><p><code>python3 manage.py makemigrations</code></p><p><img src="https://i.loli.net/2019/07/10/5d2589413ad8651657.png" alt="迁移文件被生成到应用的 migrations 目录"></p></li><li><p>执行迁移：执行sql语句生成数据表</p><p><code>python3 manage.py migrate</code></p><p><img src="https://i.loli.net/2019/07/10/5d258990c373d45602.png" alt="生成数据表"></p></li></ol><h3 id="测试数据表"><a href="#测试数据表" class="headerlink" title="测试数据表"></a>测试数据表</h3><p>进入python shell，看看模型（表）是否已经OK。</p><p><code>python manage.py shell</code></p><p><img src="https://i.loli.net/2019/07/10/5d258c1e9332469206.png" alt="一些操作"></p><p><img src="https://i.loli.net/2019/07/10/5d258c88e833323885.png" alt="打印上图中的 b 对象"></p><p>可以看到打印出来的是这些信息，这里就可以重写<code>__str__()</code>方法了，类似于 Java 中的<code>toString()</code>方法的作用。下图为测试结果。对于 Student 模型也是同理的。</p><p><img src="https://i.loli.net/2019/07/10/5d258df68964526735.png" alt="重写 __str__() 后的结果"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b=School.objects.get(pk=<span class="number">1</span>)  <span class="comment"># pk 表示主键，这个是获取 主键 为1的那条数据对象</span></span><br><span class="line">b.delete()  <span class="comment"># 删除一条数据</span></span><br></pre></td></tr></table></figure><h4 id="关联对象操作"><a href="#关联对象操作" class="headerlink" title="关联对象操作"></a>关联对象操作</h4><p>学生：学校 = n：1</p><p>获得关联集合：返回当前 School 对象的所有 Student</p><p><img src="https://i.loli.net/2019/07/10/5d25918c6566582362.png"></p><h3 id="管理站点"><a href="#管理站点" class="headerlink" title="管理站点"></a>管理站点</h3><p>Django 默认提供了后台管理功能（对数据表增删改查、增加用户）</p><p><code>python manage.py runserver ip:port</code></p><p>可以不写ip，默认端口为8000，这是一个纯python编写的轻量级web服务器，仅在开发阶段使用。</p><h4 id="管理操作"><a href="#管理操作" class="headerlink" title="管理操作"></a>管理操作</h4><p>站点分为“内容发布”和“公共访问”两部分。</p><p>“内容发布”的部分负责添加、修改、删除内容，开发这些重复的功能是一件单调乏味、缺乏创造力的工作。为此，Django 会根据定义的模型类完全自动地生成管理模块。</p><p>生成一个管理员账户：<br><code>python manage.py createsuperuser</code></p><p>启动服务器，通过“127.0.0.1:8000/admin”访问，输入上面创建的用户名、密码完成登录</p><p><img src="https://i.loli.net/2019/07/10/5d25969f2175180606.png" alt="创建超级管理员账号"></p><p>默认可以对groups、users进行管理，不能对创建的模型（表）进行增删改查。如果要对刚刚定义的模型进行增删改查的话，要做下面的操作：</p><ol><li><p>在 booktest/admin.py 文件中，注册模型</p></li><li><p>刷新管理页面，可以对BookInfo的数据进行增删改查操作</p><p><img src="https://i.loli.net/2019/07/10/5d2596cb5819168673.png" alt="admin.py"></p><p><img src="https://i.loli.net/2019/07/10/5d2597191a71b32563.png" alt="基本的管理"></p></li></ol><p><strong>【注】</strong><br>问题：如果在str方法中返回中文，在修改和添加时会报ascii的错误<br>解决：在str()方法中，将字符串末尾添加“.encode(‘utf-8’)”</p><h4 id="管理界面本地化"><a href="#管理界面本地化" class="headerlink" title="管理界面本地化"></a>管理界面本地化</h4><p>编辑settings.py文件，设置编码、时区</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LANGUAGE_CODE = <span class="string">&#x27;zh-Hans&#x27;</span></span><br><span class="line">TIME_ZONE = <span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/07/10/5d2597cda936456378.png" alt="中文的管理界面"></p><h4 id="自定义管理界面"><a href="#自定义管理界面" class="headerlink" title="自定义管理界面"></a>自定义管理界面</h4><p>在 booktest/admin.py 中增加一些代码实现自定义管理界面。</p><p>Django提供了admin.ModelAdmin类，通过定义ModelAdmin的子类，来定义模型在Admin界面的显示方式。</p><h5 id="列表页属性"><a href="#列表页属性" class="headerlink" title="列表页属性"></a>列表页属性</h5><ul><li><p>list_display：显示字段，可以点击列头进行排序</p><p><img src="https://i.loli.net/2019/07/10/5d2598d1eaa5783188.png" alt="默认的界面"></p><p><img src="https://i.loli.net/2019/07/10/5d259a124e4e376789.png" alt="添加代码"></p><p><img src="https://i.loli.net/2019/07/10/5d259a34a712323170.png" alt="刷新后的效果"></p></li><li><p>list_filter：过滤字段，过滤框会出现在右侧</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_filter = [<span class="string">&#x27;school_name&#x27;</span>]</span><br></pre></td></tr></table></figure><ul><li>search_fields：搜索字段，搜索框会出现在上侧</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">search_fields = [<span class="string">&#x27;school_name&#x27;</span>]</span><br></pre></td></tr></table></figure><ul><li>list_per_page：分页，分页框会出现在下侧</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_per_page = <span class="number">10</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/07/10/5d259af83808122165.png" alt="代码"></p><p><img src="https://i.loli.net/2019/07/10/5d259b8f3cb8a26829.png" alt="效果"></p><h5 id="添加、修改页属性"><a href="#添加、修改页属性" class="headerlink" title="添加、修改页属性"></a>添加、修改页属性</h5><ul><li>fields：属性的先后顺序</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fields = [&#x27;bpub_date&#x27;, &#x27;btitle&#x27;]</span><br></pre></td></tr></table></figure><ul><li>fieldsets：属性分组</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fieldsets = [</span><br><span class="line">        (&#x27;base&#x27;, &#123;&#x27;fields&#x27;: [&#x27;school_name&#x27;, &#x27;school_addr&#x27;]&#125;),</span><br><span class="line">        (&#x27;else&#x27;, &#123;&#x27;fields&#x27;: [&#x27;school_build_date&#x27;]&#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/07/10/5d259beb3697082911.png" alt="默认效果"></p><p><img src="https://i.loli.net/2019/07/10/5d259cb6dcde025745.png" alt="修改代码"></p><p><img src="https://i.loli.net/2019/07/10/5d259c9225e1578240.png" alt="效果"></p><h5 id="关联属性"><a href="#关联属性" class="headerlink" title="关联属性"></a>关联属性</h5><p>Student 模型类，有两种添加数据的方式。第一个就是一个一个创建，然后把外键约束给了就行，第二个方法就是在创建 School 模型类对象的时候，直接加入一些 Student 数据。</p><p>下面实现关联注册：</p><ul><li>接下来实现关联注册</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> models <span class="keyword">import</span> School, Student</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StudentInline</span>(admin.StackedInline):</span><br><span class="line">    model = Student</span><br><span class="line">    extra = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">School</span>(admin.ModelAdmin):</span><br><span class="line">    inlines = [StudentInline]</span><br><span class="line"></span><br><span class="line">admin.site.register(BookInfo, BookInfoAdmin)</span><br></pre></td></tr></table></figure><ul><li>可以将内嵌的方式改为表格</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StudentInline</span>(admin.TabularInline)</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/07/10/5d259dd45754c43176.png" alt="默认"></p><p><img src="https://i.loli.net/2019/07/10/5d259e5f74a9a12037.png" alt="添加代码"></p><p><img src="https://i.loli.net/2019/07/10/5d259e290734180861.png" alt="修改后效果"></p><h5 id="布尔值的显示"><a href="#布尔值的显示" class="headerlink" title="布尔值的显示"></a>布尔值的显示</h5><ul><li>发布性别的显示不是一个直观的结果，可以使用方法进行封装</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gender</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">if</span> self.stu_gender:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;男&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;女&#x27;</span></span><br><span class="line">gender.short_description = <span class="string">&#x27;性别&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>在admin注册中使用 gender 代替 stu_gender</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HeroInfoAdmin</span>(admin.ModelAdmin):</span><br><span class="line">    list_display = [<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;stu_name&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;stu_birth&#x27;</span>]</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/07/10/5d259fbc3a93159364.png" alt="效果"></p><h2 id="Views-视图"><a href="#Views-视图" class="headerlink" title="Views 视图"></a>Views 视图</h2><p>在 Django 中，视图对 Web 请求进行回应</p><p>视图接收 reqeust 对象作为第一个参数，包含了请求的信息</p><p>视图就是一个 Python 函数，被定义在 views.py 中</p><p><img src="https://i.loli.net/2019/07/10/5d25a15fdec9753916.png" alt="定义视图函数"></p><p>定义完成视图后，需要配置urlconf，否则无法处理请求</p><p>在Django中，定义URLconf包括正则表达式、视图两部分</p><p>Django使用正则表达式匹配请求的URL，一旦匹配成功，则调用应用的视图</p><p>注意：只匹配路径部分，即除去域名、参数后的字符串</p><p>在 test1/urls.py 插入 booktest，使主 urlconf 连接到 booktest.urls 模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;&#x27;</span>, include(<span class="string">&#x27;booktest.urls&#x27;</span>)),</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/07/10/5d25a21c5ea0f75947.png" alt="项目下的 urls.py"></p><p>在booktest中新建urls.py并在这个urls.py中添加urlconf</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r&#x27;^$&#x27;</span>, views.index),</span><br><span class="line">    <span class="comment"># path(&#x27;&#x27;, views.index)</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/07/10/5d25a2e6617df30553.png" alt="booktest/urls.py"></p><p><img src="https://i.loli.net/2019/07/10/5d25a32c6b89144360.png" alt="okk~"></p><h2 id="Templates-模板"><a href="#Templates-模板" class="headerlink" title="Templates 模板"></a>Templates 模板</h2><p>模板是html页面，可以根据视图中传递的数据填充值。</p><p>在项目目录 test2 下创建一个 templates 目录，里面再创建一个 app 名文件夹，目录结构如下：</p><p><img src="https://i.loli.net/2019/07/10/5d25d457375e916900.png" alt="目录结构"></p><ul><li>修改settings.py文件，设置TEMPLATES的DIRS值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;DIRS&#x27;</span>: [os.path.join(BASE_DIR, <span class="string">&#x27;templates&#x27;</span>)],</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/07/10/5d25d4bda8d9671195.png" alt="settings.py 设置"></p><ul><li><p>使用模板</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;views.py&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your views here.</span></span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Student, School</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>(<span class="params">req</span>):</span><br><span class="line">    stu_list = Student.objects.<span class="built_in">all</span>()</span><br><span class="line">    context = &#123;<span class="string">&#x27;stu_list&#x27;</span>: stu_list&#125;</span><br><span class="line">    <span class="keyword">return</span> render(req, <span class="string">&#x27;booktest/index.html&#x27;</span>, context=context)</span><br></pre></td></tr></table></figure></li><li><p>在模板中访问视图传递的数据</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;输出值，可以是变量，也可以是对象.属性&#125;&#125;</span><br><span class="line">&#123;%执行代码段%&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>index page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>index page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            &#123;% for i in stu_list %&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">                &#123;&#123; i.stu_name &#125;&#125;</span><br><span class="line">                &#123;&#123; i.stu_birth &#125;&#125;</span><br><span class="line">                &#123;&#123; i.gender &#125;&#125;</span><br><span class="line">                &#123;&#123; i.stu_school &#125;&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            &#123;% endfor %&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/07/10/5d25d74c3f6c036095.png" alt="效果"></p><p><a href="https://ahoj.cc/pythonbook/12-django/part1/6.html">资料：黑马学习笔记</a></p><p>end.</p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> Django </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV-通道分离、合并、修改</title>
      <link href="/2019/07/08/OpenCV-%E9%80%9A%E9%81%93%E5%88%86%E7%A6%BB%E3%80%81%E5%90%88%E5%B9%B6%E3%80%81%E4%BF%AE%E6%94%B9/"/>
      <url>/2019/07/08/OpenCV-%E9%80%9A%E9%81%93%E5%88%86%E7%A6%BB%E3%80%81%E5%90%88%E5%B9%B6%E3%80%81%E4%BF%AE%E6%94%B9/</url>
      
        <content type="html"><![CDATA[<p>split() 将彩色图像分割成3个通道，merge()通道合并。</p><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">src = cv.imread(<span class="string">&quot;01image.jpg&quot;</span>)</span><br><span class="line">cv.namedWindow(<span class="string">&quot;原来&quot;</span>, cv.WINDOW_NORMAL)</span><br><span class="line">cv.imshow(<span class="string">&quot;原来&quot;</span>, src)</span><br><span class="line"></span><br><span class="line"><span class="comment">#通道分离，输出三个单通道图片</span></span><br><span class="line">b, g, r = cv.split(src)<span class="comment">#将彩色图像分割成3个通道</span></span><br><span class="line">cv.imshow(<span class="string">&quot;blue&quot;</span>, b)</span><br><span class="line">cv.imshow(<span class="string">&quot;green&quot;</span>, g)</span><br><span class="line">cv.imshow(<span class="string">&quot;red&quot;</span>, r)</span><br><span class="line"></span><br><span class="line"><span class="comment">#通道合并</span></span><br><span class="line">src = cv.merge([b, g, r])</span><br><span class="line">cv.imshow(<span class="string">&quot;合并&quot;</span>, src)</span><br><span class="line"> =</span><br><span class="line"><span class="comment">#修改某个通道的值</span></span><br><span class="line">src[:, :, <span class="number">2</span>] = <span class="number">100</span></span><br><span class="line">cv.imshow(<span class="string">&quot;单通道&quot;</span>, src)</span><br><span class="line"></span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV-inRange提取视频中的一种颜色</title>
      <link href="/2019/07/08/OpenCV-inRange%E6%8F%90%E5%8F%96%E8%A7%86%E9%A2%91%E4%B8%AD%E7%9A%84%E4%B8%80%E7%A7%8D%E9%A2%9C%E8%89%B2/"/>
      <url>/2019/07/08/OpenCV-inRange%E6%8F%90%E5%8F%96%E8%A7%86%E9%A2%91%E4%B8%AD%E7%9A%84%E4%B8%80%E7%A7%8D%E9%A2%9C%E8%89%B2/</url>
      
        <content type="html"><![CDATA[<p>将视频流读进来，把每一帧图像色彩空间转换为 HSV，然后用 inRange 把颜色分离出来。</p><span id="more"></span><p>H：0~180</p><p>S：0~255</p><p>V：0~255</p><p><img src="https://i.loli.net/2019/07/08/5d22e2036495493111.png" alt="HSV颜色对应的分量范围"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">extrace_obj_demo</span>():</span><br><span class="line">    capture = cv.VideoCapture(<span class="string">&quot;/Users/hanoi_ahoj/Downloads/2.mp4&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        ret, frame = capture.read()</span><br><span class="line">        <span class="comment"># 当视频流读完的时候，ret 就为 False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        hsv = cv.cvtColor(frame, cv.COLOR_BGR2HSV)</span><br><span class="line">        lower_hsv = np.array([<span class="number">35</span>, <span class="number">43</span>, <span class="number">46</span>])  <span class="comment"># 绿色的低值</span></span><br><span class="line">        upper_hsv = np.array([<span class="number">77</span>, <span class="number">255</span>, <span class="number">255</span>])  <span class="comment"># 绿色的高值</span></span><br><span class="line">        mask = cv.inRange(hsv, lowerb=lower_hsv, upperb=upper_hsv)</span><br><span class="line">        cv.imshow(<span class="string">&#x27;video&#x27;</span>, frame)</span><br><span class="line">        cv.imshow(<span class="string">&#x27;mask&#x27;</span>, mask)</span><br><span class="line"></span><br><span class="line">        c = cv.waitKey(<span class="number">40</span>)</span><br><span class="line">        <span class="keyword">if</span> c == <span class="number">27</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    extrace_obj_demo()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/07/08/5d22e194ccbd793008.gif" alt="运行结果"></p><hr>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV-色彩空间转换</title>
      <link href="/2019/07/08/OpenCV-%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2/"/>
      <url>/2019/07/08/OpenCV-%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>注意：OpenCV 中的 HSV 色彩空间的 H 是 0~180，但是标准的是 360。这是为什么呢？</p><p>因为其他两个都是 255，而 H 是 360 存进去就会 overflow。</p><span id="more"></span><p>常见的色彩空间：</p><p>RGB、HSV、HIS、YCrCb、YUV。</p><p><img src="https://i.loli.net/2019/07/08/5d22dd690beec97412.png" alt="HSV 色彩空间"></p><p>色彩空间的转换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">color_space_demo</span>(<span class="params">image</span>):</span><br><span class="line">    gray = cv.cvtColor(image, cv.COLOR_BGR2GRAY)</span><br><span class="line">    cv.imshow(<span class="string">&#x27;gray&#x27;</span>, gray)</span><br><span class="line"></span><br><span class="line">    hsv = cv.cvtColor(image, cv.COLOR_BGR2HSV)</span><br><span class="line">    cv.imshow(<span class="string">&#x27;hsv&#x27;</span>, hsv)</span><br><span class="line"></span><br><span class="line">    yuv = cv.cvtColor(image, cv.COLOR_BGR2YUV)</span><br><span class="line">    cv.imshow(<span class="string">&#x27;yuv&#x27;</span>, yuv)</span><br><span class="line"></span><br><span class="line">    ycrcb = cv.cvtColor(image, cv.COLOR_BGR2YCrCb)</span><br><span class="line">    cv.imshow(<span class="string">&#x27;ycrcb&#x27;</span>, ycrcb)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    img = cv.imread(<span class="string">&#x27;01image.JPG&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">    cv.imshow(<span class="string">&#x27;bgr&#x27;</span>, img)</span><br><span class="line"></span><br><span class="line">    color_space_demo(img)</span><br><span class="line"></span><br><span class="line">    cv.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV-无中生图</title>
      <link href="/2019/07/07/OpenCV-%E6%97%A0%E4%B8%AD%E7%94%9F%E5%9B%BE/"/>
      <url>/2019/07/07/OpenCV-%E6%97%A0%E4%B8%AD%E7%94%9F%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>无中生有？无中生‘图’！</p><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">create_img</span>():</span><br><span class="line">    <span class="comment"># 生成一个多通道图片</span></span><br><span class="line">    img = np.zeros([<span class="number">400</span>, <span class="number">400</span>, <span class="number">3</span>], np.uint8)</span><br><span class="line">    img[:, :, <span class="number">0</span>] = np.ones([<span class="number">400</span>, <span class="number">400</span>]) * <span class="number">255</span>  <span class="comment"># 上色，给 b 通道赋值，400 * 400个像素均为 255（蓝色）</span></span><br><span class="line">    img[:, :, <span class="number">1</span>] = np.ones([<span class="number">400</span>, <span class="number">400</span>]) * <span class="number">255</span>  <span class="comment"># 与上同理 (green)</span></span><br><span class="line">    cv.imshow(<span class="string">&#x27;new image0&#x27;</span>, img)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 单通道图片（单通道一般为灰度图片）</span></span><br><span class="line">    img = np.zeros([<span class="number">400</span>, <span class="number">400</span>, <span class="number">1</span>], np.uint8)  <span class="comment"># zeros 初始化了一个三维数组，并且里面都是 0</span></span><br><span class="line">    img[:, :, <span class="number">0</span>] = np.ones([<span class="number">400</span>, <span class="number">400</span>]) * <span class="number">127</span>  <span class="comment"># ones 给对应的坐标赋值为 1，如果 * 了 127 就是赋值127呗。</span></span><br><span class="line">    cv.imshow(<span class="string">&#x27;new image1&#x27;</span>, img)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    create_img()</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ol><li><p><code>np.zeros()</code></p><p>Return a new array of given shape and type, filled with zeros.</p></li><li><p><code>np.ones()</code></p><p>Return a new array of given shape and type, filled with ones.</p></li></ol><p><strong>运行结果：</strong></p><p>new image0 是 [255，255，0]，new image1 是 [127]。</p><p><img src="https://i.loli.net/2019/07/07/5d21cf2f9660215741.png" alt="result"></p><hr>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV-修改图片颜色通道并保存</title>
      <link href="/2019/07/07/OpenCV-%E4%BF%AE%E6%94%B9%E5%9B%BE%E7%89%87%E9%A2%9C%E8%89%B2%E9%80%9A%E9%81%93%E5%B9%B6%E4%BF%9D%E5%AD%98/"/>
      <url>/2019/07/07/OpenCV-%E4%BF%AE%E6%94%B9%E5%9B%BE%E7%89%87%E9%A2%9C%E8%89%B2%E9%80%9A%E9%81%93%E5%B9%B6%E4%BF%9D%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p>读取一张图片，修改颜色通道后输出。</p><p>cv 读取进来可以获得图像的行数,列数,通道数的矩阵,对矩阵进行操作可改变图像。</p><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">access_pixels</span>(<span class="params">img</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;访问每一个像素&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(img.shape)</span><br><span class="line">    height = img.shape[<span class="number">0</span>]  <span class="comment"># 宽</span></span><br><span class="line">    width = img.shape[<span class="number">1</span>]  <span class="comment"># 高</span></span><br><span class="line">    channels = img.shape[<span class="number">2</span>]  <span class="comment"># 颜色通道 blue green red (bgr)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;width:%s, height:%s, channels:%s&quot;</span> % (width, height, channels))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(channels):</span><br><span class="line">                pv = img[i, j, k]</span><br><span class="line">                img[i, j, k] = <span class="number">255</span> - pv</span><br><span class="line"></span><br><span class="line">    cv.imshow(<span class="string">&#x27;demo&#x27;</span>, img)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    img = cv.imread(<span class="string">&#x27;01image.JPG&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">    cv.imshow(<span class="string">&#x27;06&#x27;</span>, img)</span><br><span class="line"></span><br><span class="line">    t_start = cv.getTickCount()  <span class="comment"># 记录了系统启动以来的毫秒数 ms</span></span><br><span class="line">    access_pixels(img)</span><br><span class="line">    t_end = cv.getTickCount()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;time: %s ms&quot;</span> % ((t_end - t_start) / cv.getTickFrequency() * <span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line">    cv.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/07/07/5d21b7d84ea5b88542.png" alt="输出"></p><p>可以看到总共耗时 9.4 秒，实在是太长了啊~~~~。</p><p>有没有快一点的方法呢？</p><p>当然，python 解释执行的效率是没有 C/C++ 快滴，OpenCV 是一个用 C/C++ 的开源库，里面也提供了和上面那个<code>access_pixels</code>函数同样功能的函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GMat cv::gapi::<span class="built_in">bitwise_not</span>(<span class="type">const</span> GMat &amp; src); <span class="comment">// 函数原型</span></span><br><span class="line"><span class="comment">// 反转数组的每一位。函数bitwise_not计算输入矩阵的逐元素逐位反转</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Python 中调用</span></span><br><span class="line"><span class="comment">// cv.bitwise_not(img)，快乐不止一点点~~ happy</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/07/07/5d21b9679382839577.png" alt="doc of func bitwise_not"></p><hr>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV-调用摄像头、读取视频文件</title>
      <link href="/2019/07/07/OpenCV-%E8%B0%83%E7%94%A8%E6%91%84%E5%83%8F%E5%A4%B4%E3%80%81%E8%AF%BB%E5%8F%96%E8%A7%86%E9%A2%91%E6%96%87%E4%BB%B6/"/>
      <url>/2019/07/07/OpenCV-%E8%B0%83%E7%94%A8%E6%91%84%E5%83%8F%E5%A4%B4%E3%80%81%E8%AF%BB%E5%8F%96%E8%A7%86%E9%A2%91%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>发现我摄像头拍出来我还挺 shuai 的。</p><span id="more"></span><p><strong>调用摄像头：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">video_demo</span>():</span><br><span class="line">    capture = cv.VideoCapture(<span class="number">0</span>)  <span class="comment"># 从 0 号摄像头读取，可能电脑上有多个摄像头，从0开始编号</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        ret, frame = capture.read()</span><br><span class="line">        frame = cv.flip(frame, <span class="number">1</span>)  <span class="comment"># 摄像头翻转</span></span><br><span class="line">        cv.imshow(<span class="string">&#x27;video&#x27;</span>, frame)</span><br><span class="line">        </span><br><span class="line">        c = cv.waitKey(<span class="number">50</span>)</span><br><span class="line">        <span class="keyword">if</span> c == <span class="number">27</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>说明：</p><ol><li><p><code>VideoCapture()</code>，一个类，官方文档挺全的。</p><p><img src="https://i.loli.net/2019/07/07/5d2167e79f8a315368.png" alt="doc of class VideoCapture"></p></li><li><p><code>read()</code>读取摄像头，返回两个参数（ret, frame)，ret 是 bool 类型，表示有没有读到图片；frame 是读取的每一帧的图片。</p></li><li><p><code>flip()</code>表示翻转，默认读取的摄像头数据是左右翻的。</p><p>0，上下翻</p><p>大于0，水平翻</p><p>小于0，180旋转</p><blockquote><p>a flag to specify how to flip the array; 0 means flipping around the x-axis and positive value (for example, 1) means flipping around y-axis. Negative value (for example, -1) means flipping around both axes.</p></blockquote><p><img src="https://i.loli.net/2019/07/07/5d2166b4dfa3a56212.png" alt="doc of func flip"></p></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV-图片属性、保存图片</title>
      <link href="/2019/07/07/OpenCV-%E5%9B%BE%E7%89%87%E5%B1%9E%E6%80%A7%E3%80%81%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87/"/>
      <url>/2019/07/07/OpenCV-%E5%9B%BE%E7%89%87%E5%B1%9E%E6%80%A7%E3%80%81%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p>图片的基本属性、读取图片并转换成其他格式保存。</p><span id="more"></span><p><strong>图片的基本属性：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出图片属性</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_img_info</span>(<span class="params">img</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(img))  <span class="comment"># 显示图片类型 numpy类型的数组     &lt;class &#x27;numpy.ndarray&#x27;&gt;</span></span><br><span class="line">    <span class="comment"># 图像矩阵的shape属性表示图像的大小，shape会返回tuple元组，第一个元素表示矩阵行数，第二个元组表示矩阵列数，第三个元素是3，表示像素值由光的三原色组成    (878, 1242, 3)</span></span><br><span class="line">    <span class="built_in">print</span>(img.shape)</span><br><span class="line">    <span class="built_in">print</span>(img.size)  <span class="comment"># 图像大小   3271428 bit = 878*1242*3*8/8</span></span><br><span class="line">    <span class="built_in">print</span>(img.dtype)  <span class="comment"># 图像类型</span></span><br><span class="line"></span><br><span class="line">    pixel_data = np.array(img)  <span class="comment"># 获取像素数据</span></span><br><span class="line">    <span class="built_in">print</span>(pixel_data)  <span class="comment"># 打印像素数据(是一个矩阵)</span></span><br></pre></td></tr></table></figure><p><strong>图片写入：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;01image.jpg&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;02image.jpg&#x27;</span>, img) <span class="comment"># 参数1 写入的文件名称；参数2 图片数据</span></span><br></pre></td></tr></table></figure><p><strong>保存图片为不同质量：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;01image.jpg&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;03image.jpg&#x27;</span>, img, [cv2.IMWRITE_JPEG_QUALITY, <span class="number">50</span>])  <span class="comment"># 0~100 有损压缩</span></span><br><span class="line">cv2.imwrite(<span class="string">&#x27;03-2image.png&#x27;</span>, img, [cv2.IMWRITE_PNG_COMPRESSION,<span class="number">0</span>])  <span class="comment"># 0~9</span></span><br></pre></td></tr></table></figure><p>说明：</p><p>jpg 有损压缩，png 无损压缩。</p><p>png 还可以修改透明度属性，但是 jpg 不可以修改，因为 png 中还保存了图片的 alpha 通道数据。</p><p>对于 jpg 来说，数字越小，压缩比越高，图片质量损失严重，压缩范围 0~100。</p><p>对于 png 来说，数字越小，压缩比越低，压缩范围 0~9。</p><hr>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV-读取显示一张图片</title>
      <link href="/2019/07/06/OpenCV-%E8%AF%BB%E5%8F%96%E6%98%BE%E7%A4%BA%E4%B8%80%E5%BC%A0%E5%9B%BE%E7%89%87/"/>
      <url>/2019/07/06/OpenCV-%E8%AF%BB%E5%8F%96%E6%98%BE%E7%A4%BA%E4%B8%80%E5%BC%A0%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p>这算是 OpenCV 中的 <code>hello world!</code> 吧，今天 hello world 明天 change world。</p><span id="more"></span><p>读取、显示一张图片：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;01image.jpg&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;image&#x27;</span>, img)</span><br><span class="line"></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ol><li><p><code>Mat imread(const String&amp; filename,int flags);</code></p><p>参数1：图片路径+图片名。</p><p>参数2：图片读取方式，默认正常读取，0 为灰度图，1 是彩色图。</p></li><li><p><code>cv.NamedWindow( const char* name, int flags );</code></p><p>设置一个窗口，其实不写这行代码，也可以显示出来。</p><p>参数1：窗口名字，设置为中文时 .py 文件上要加上 <code># -*- coding=GBK -*-</code>，如果不加会报错，如果加的是 utf-8 会乱码，但不会报错。</p><p>参数2：窗口显示方式，为 0 或 cv.WINDOW_NORMAL，则可以改变窗口大小；不写或 cv.WINDOW_AUTOSIZE 则不可改变大小。</p></li><li><p><code>imshow(const string&amp; winname, InputArray mat);</code></p><p>参数1：窗口名称，如果上面有 NamedWindow 函数，这个名称要和它一样，不然会出现两个窗口，一个 NamedWindow 的空白窗口，一个事 imshow 窗口。</p><p>参数2：要显示的图片。</p></li><li><p><code>waitKey(K);</code></p><p>窗口显示时间，单位 ms。</p><p>K &lt;= 0，一直显示，键盘上按下一个键就会消失；K &gt; 0，要显示多少毫秒。</p></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-调用C写的动态库</title>
      <link href="/2019/07/05/Python-%E8%B0%83%E7%94%A8C%E5%86%99%E7%9A%84%E5%8A%A8%E6%80%81%E5%BA%93/"/>
      <url>/2019/07/05/Python-%E8%B0%83%E7%94%A8C%E5%86%99%E7%9A%84%E5%8A%A8%E6%80%81%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>Python 在一些情况下效率并不理想，但是 Python 这种胶水语言可以使用 C 来处理这个问题呀。</p><span id="more"></span><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">helloworld</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello world, python and c.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>首先生成一个动态库<code>.so</code>。</strong></p><p><img src="https://i.loli.net/2019/07/05/5d1ec69c21cd718502.png" alt="生成动态库"></p><p><strong>然后在Python中这么使用：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载动态库</span></span><br><span class="line">lib = cdll.LoadLibrary(<span class="string">&quot;./libhello.so&quot;</span>)</span><br><span class="line"></span><br><span class="line">lib.helloworld()</span><br></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><p><img src="https://i.loli.net/2019/07/05/5d1ec712aa63323477.png" alt="输出"></p><p>使用这种方法可以解决 Python 中的 GIL 问题。</p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知乎上 40 个有趣的回复</title>
      <link href="/2019/07/02/%E7%9F%A5%E4%B9%8E%E4%B8%8A40%E4%B8%AA%E6%9C%89%E8%B6%A3%E7%9A%84%E5%9B%9E%E5%A4%8D/"/>
      <url>/2019/07/02/%E7%9F%A5%E4%B9%8E%E4%B8%8A40%E4%B8%AA%E6%9C%89%E8%B6%A3%E7%9A%84%E5%9B%9E%E5%A4%8D/</url>
      
        <content type="html"><![CDATA[<p>来自微信公众号：<a href="https://mp.weixin.qq.com/s/HrJlXrRI490zVL0LDYoR0g">人民日报【荐读】知乎上40个有趣回复，很精辟</a></p><span id="more"></span> <ol><li><p><strong>交朋友的标准是什么？</strong></p><p>出世的智者，入世的强者，或者正常而阳光的普通人。</p></li><li><p><strong>有哪些可以令人清醒的句子？</strong></p><p>你多学一样本事，就少说一句求人的话。</p></li><li><p><strong>做哪些事情可以提升生活品质？</strong></p><p>定期扔东西。</p></li><li><p><strong>结婚以后两个人在一起最重要的是什么？</strong></p><p>就当这婚还没结。</p></li><li><p><strong>把学费拿来念书还是环游世界更合适？</strong> <strong>为什么？</strong></p><p>在没有充分的知识作为前提的情况下，</p><p>即使行了万里路，</p><p>也不过是邮差而已。</p></li><li><p><strong>你是如何强迫自己不断学习提升的？</strong></p><p>看过更大的世界后，</p><p>就再也不甘心留在原地。</p><p>不甘心就是动力。</p></li><li><p><strong>你对自由的理解是什么？</strong></p><p>说“不”的能力。</p></li><li><p><strong>你是如何走出人生的阴霾的？</strong></p><p>多走几步。</p></li><li><p><strong>哪些技能，经较短时间的学习，就可以给人的生活带来巨大帮助？</strong></p><p>夸奖他人。</p></li><li><p><strong>我读过很多书，但后来大部分都被我忘记了，那阅读的意义是什么？</strong></p><p>当我还是个孩子的时候，</p><p>我吃过很多食物，</p><p>现在已经记不起来吃过什么了。</p><p>但可以肯定的是，</p><p>它们中的一部分已经长成为我的骨头和肉。</p></li></ol><hr><ol start="11"><li><p><strong>要怎样努力，才能成为很厉害的人？</strong></p><p>如果你注定要成为厉害的人，</p><p>那问题的答案就深藏在你的血脉里；</p><p>如果你注定不是厉害的人，</p><p>那你便只需要做好你自己。</p></li><li><p><strong>你在生活中得到过的最好的建议是什么？</strong></p><p>“永远不要为尚未发生的事儿拧巴”、</p><p>“觉得为时已晚，恰恰是最早的时候”。</p></li><li><p><strong>前半生与后半生的分界线是在哪里？</strong></p><p>此时此刻。</p></li><li><p><strong>同样是别人比自己强，为什么有时会产生嫉妒心理，而有时会产生崇拜？</strong></p><p>远的崇拜，近的嫉妒；</p><p>够不着的崇拜，够得着的嫉妒；</p><p>有利益冲突的嫉妒，没利益冲突的崇拜。</p></li><li><p><strong>如何让这个世界变得美好？</strong></p><p>把你自己变得更美好。</p></li><li><p><strong>二十六岁，工作三年，却将留学三年，值得吗？</strong></p><p>普通玩家选择标准配置，</p><p>高端玩家选择自定义配置。</p></li><li><p><strong>世界上有那么多好书好电影，注定看不完，我们对这个事实该持何种态度？</strong></p><p>怕什么真理无穷，</p><p>进一寸有一寸的欢喜。</p></li><li><p><strong>听过最落寞的一句话或诗句是什么？</strong></p><p>不如意事常八九，</p><p>可与言者无二三。</p></li><li><p><strong>人这一生为什么要努力？</strong></p><p>最痛苦的事，不是失败，</p><p>是我本可以。</p></li><li><p><strong>省钱的好办法有哪些？</strong></p><p>在买任何东西之前牢记九字箴言：</p><p>你喜欢，你需要，你适合。</p><p>PS：适用于很多事，包括感情也一样。</p></li></ol><hr><ol start="21"><li><p><strong>哪一段话让你有醍醐灌顶的感觉？</strong></p><p>人会长大三次。</p><p>第一次是在发现</p><p>自己不是世界中心的时候。</p><p>第二次是在发现即使再怎么努力，</p><p>终究还是有些事令人无能为力的时候。</p><p>第三次是在，</p><p>明知道有些事可能会无能为力，</p><p>但还是会尽力争取的时候。</p></li><li><p><strong>哪些行为是浪费时间？</strong></p><p>思而不学＋犹豫不决</p></li><li><p><strong>为什么当看到好照片时，人们通常的反应是：“真不错，你用的是什么相机”，当看到烂照片时，则往往笑话拍摄者水平很臭？</strong></p><p>人习惯性地</p><p>将自己的成功归因于自身，</p><p>失败归因于环境；</p><p>而将他人的成功归因于环境，</p><p>失败归因于其自身。</p></li><li><p><strong>如果好人不一定得到好报，那我们为什么还要做好事？</strong></p><p>我们坚持一件事情，</p><p>并不是因为这样做了会有效果，</p><p>而是坚信，这样做是对的。</p></li><li><p><strong>如何看待“年轻的时候需要的是朋友而不是人脉”？</strong></p><p>没有目的之交往，</p><p>才能感动人。</p></li><li><p><strong>有哪些道理是你读了不信、听不进去，直到你亲身经历方笃信不疑的？</strong></p><p>不要低估你的能力，</p><p>不要高估你的毅力。</p></li><li><p><strong>最能燃起你学习激情的一句话是什么？</strong></p><p>你不能把这个世界，</p><p>让给你所鄙视的人。</p></li><li><p><strong>你心中的完美爱情是怎么样的？</strong></p><p>可以有不完美。</p></li><li><p><strong>怎样才能做到不在乎别人骂？</strong></p><p>你要相信，比你优秀的人</p><p>基本没空骂你。</p></li><li><p><strong>什么叫见过大世面？</strong></p><p>能享受最好的，</p><p>能承受最坏的。</p></li></ol><hr><ol start="31"><li><p><strong>如何反驳“现实点，这个社会就是这样”？</strong></p><p>“你是怎样，你的世界就是怎样。”</p></li><li><p><strong>如何让感情保持新鲜感？</strong></p><p>所谓新鲜感，</p><p>不是和未知的人一起去做同样的事情，</p><p>而是和已知的人一起去体验未知的人生。</p></li><li><p><strong>情商不高的例子有哪些？</strong></p><p>对陌生人毕恭毕敬，</p><p>对亲近的人随意发怒。</p></li><li><p><strong>三十岁才开始学习编程，靠谱吗？</strong></p><p>种一棵树最好的时间是十年前，</p><p>其次是现在。</p></li><li><p><strong>怎样在有效提出推荐或建议的同时，避免给人灌输和强迫的感觉？</strong></p><p>说服他人不要诉诸理性，</p><p>应求于利益。</p></li><li><p><strong>在一个足够小的星球上行走，我们是在上坡还是下坡？</strong></p><p>你感觉累就是上坡，</p><p>感觉轻松就是下坡。</p></li><li><p><strong>你遇到过哪些让你眼前一亮、醍醐灌顶，或对你改变很大的理念？</strong></p><p>天赋决定了你能达到的上限，</p><p>努力程度决定了你能达到的下限。</p><p>以绝大多数人的努力程度之低，</p><p>远远没有达到要去拼天赋的地步。</p></li><li><p><strong>扎克伯格初期是怎么保护Facebook的最初创意？为什么Facebook上线后没被其他大公司抄走?</strong></p><p>保护创意的最好方法，就是——将其最好地执行。</p></li><li><p><strong>如何看待“年轻时就释怀与淡泊，是没有希望的”这句话？</strong></p><p>试图用一句话就来总结复杂的人生，</p><p>是没有希望的。</p></li><li><p><strong>异国长期生活，改变了你的哪些“是非观”？</strong></p><p>很多事情，</p><p>只是不同，并无是非。</p></li></ol><h2 id="END"><a href="#END" class="headerlink" title="- END -"></a>- END -</h2>]]></content>
      
      
      <categories>
          
          <category> 反思 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反思 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-元类</title>
      <link href="/2019/06/29/Python-%E5%85%83%E7%B1%BB/"/>
      <url>/2019/06/29/Python-%E5%85%83%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>先有鸡还是先有蛋，this is a question。</p><p>在大多数编程语言中，类就是一组用来描述如何生成一个对象的代码段。Python 中也是如此。</p><p>那么是哪个东西创建的<strong>类</strong>这个东西呢？女娲或者上帝？</p><span id="more"></span><p>尝试着站在更高的地方想这个问题（比如6楼别人的宿舍 :) ）。</p><p>好吧，其实类同样也是一种对象，类对象。下面这段代码，我没有创建对象，也没有调用他，只要一运行，就会输出那句print。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-- person test print --&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.name = <span class="string">&#x27;abc&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/06/29/5d17215c0ba5b29237.png" alt="运行结果"></p><p>这就是 Python 在创建<strong>类对象</strong>。创建 Person 类的东西，称为元类。</p><h2 id="动态的创建类"><a href="#动态的创建类" class="headerlink" title="动态的创建类"></a>动态的创建类</h2><p>类也是对象，那么可以在运行时动态的创建他们吗？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">choose_class</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">&#x27;foo&#x27;</span>:</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Foo</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> Foo <span class="comment"># 返回的是类，不是类的实例</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Bar</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> Bar</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    mc = choose_class(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(mc)   <span class="comment"># 函数返回的是类，不是类的实例</span></span><br><span class="line">    <span class="built_in">print</span>(mc()) <span class="comment"># 可以通过这个类创建实例对象</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/06/29/5d1722782877d57042.png" alt="运行结果"></p><h2 id="使用-type-创建类"><a href="#使用-type-创建类" class="headerlink" title="使用 type 创建类"></a>使用 type 创建类</h2><p><code>type()</code>不仅可以查看参数是个啥类型的，还可以动态的创建类！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法</span></span><br><span class="line"><span class="built_in">type</span>(类名, 由父类名称组成的元组（针对继承的情况，可以为空），包含属性的字典（名称和值）)</span><br></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Person = <span class="built_in">type</span>(<span class="string">&quot;Person&quot;</span>, (), &#123;&#125;)</span><br><span class="line">p1 = Person()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(p1))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printName</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(self.name)</span><br><span class="line"></span><br><span class="line">Student = <span class="built_in">type</span>(<span class="string">&quot;Student&quot;</span>, (Person,), &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&#x27;ahojcn&#x27;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">20</span>, <span class="string">&quot;printName&quot;</span>: printName&#125;)</span><br><span class="line">s1 = Student()</span><br><span class="line">s1.printName()</span><br><span class="line"><span class="built_in">print</span>(s1.age)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Person.__class__)</span><br><span class="line"><span class="built_in">print</span>(Student.__class__)</span><br><span class="line"><span class="built_in">print</span>(p1.__class__)</span><br><span class="line"><span class="built_in">print</span>(s1.__class__)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>.__class__) <span class="comment"># type</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/06/29/5d1723559e6de41008.png" alt="运行结果"></p><h2 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h2><p>元类就是用来创建<strong>类</strong>的东西。</p><blockquote><p>函数type实际上是一个元类。type就是Python在背后用来创建所有类的元类。现在你想知道那为什么type会全部采用小写形式而不是Type呢？好吧，我猜这是为了和str保持一致性，str是用来创建字符串对象的类，而int是用来创建整数对象的类。type就是创建类对象的类。你可以通过检查__class__属性来看到这一点。Python中所有的东西，注意，我是指所有的东西——都是对象。这包括整数、字符串、函数以及类。它们全部都是对象，而且它们都是从一个类创建而来，这个类就是type。</p></blockquote><h3 id="metaclass-属性"><a href="#metaclass-属性" class="headerlink" title="__metaclass__ 属性"></a>__metaclass__ 属性</h3><p>这个属性决定了这个类长什么样子，不指定的话就是使用系统默认的。</p><p>下面这段测试代码，使用自定义的函数来创建 Foo 类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">upper_attr</span>(<span class="params">future_class_name, future_class_parents, future_class_attr</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历字典，把不是__开头的属性名称变成大写</span></span><br><span class="line">    newAttr = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> name, value <span class="keyword">in</span> future_class_attr.items():</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">&quot;__&quot;</span>):</span><br><span class="line">            newAttr[name.upper()] = value</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调用 type 创建一个类</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">type</span>(future_class_name, future_class_parents, newAttr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>(<span class="built_in">object</span>, metaclass=upper_attr):</span><br><span class="line">    <span class="comment"># __metaclass__ = upper_attr # py2 要写在这里</span></span><br><span class="line">    bar = <span class="string">&#x27;bip&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hasattr</span>(Foo, <span class="string">&#x27;bar&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hasattr</span>(Foo, <span class="string">&#x27;BAR&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    f = Foo()</span><br><span class="line">    <span class="built_in">print</span>(f.BAR)</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/06/29/5d1724801696e39594.png" alt="运行结果"></p><p>下面这段代码使用自定义的class来当做元类(代码参考：网络)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UpperAttrMetaClass</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="comment"># __new__ 是在__init__之前被调用的特殊方法</span></span><br><span class="line">    <span class="comment"># __new__是用来创建对象并返回之的方法</span></span><br><span class="line">    <span class="comment"># 而__init__只是用来将传入的参数初始化给对象</span></span><br><span class="line">    <span class="comment"># 你很少用到__new__，除非你希望能够控制对象的创建</span></span><br><span class="line">    <span class="comment"># 这里，创建的对象是类，我们希望能够自定义它，所以我们这里改写__new__</span></span><br><span class="line">    <span class="comment"># 如果你希望的话，你也可以在__init__中做些事情</span></span><br><span class="line">    <span class="comment"># 还有一些高级的用法会涉及到改写__call__特殊方法，但是我们这里不用</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, future_class_name, future_class_parents, future_class_attr</span>):</span><br><span class="line">        <span class="comment">#遍历属性字典，把不是__开头的属性名字变为大写</span></span><br><span class="line">        newAttr = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> name,value <span class="keyword">in</span> future_class_attr.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">&quot;__&quot;</span>):</span><br><span class="line">                newAttr[name.upper()] = value</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 方法1：通过&#x27;type&#x27;来做类对象的创建</span></span><br><span class="line">        <span class="comment"># return type(future_class_name, future_class_parents, newAttr)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 方法2：复用type.__new__方法</span></span><br><span class="line">        <span class="comment"># 这就是基本的OOP编程，没什么魔法</span></span><br><span class="line">        <span class="comment"># return type.__new__(cls, future_class_name, future_class_parents, newAttr)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 方法3：使用super方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>(UpperAttrMetaClass, cls).__new__(cls, future_class_name, future_class_parents, newAttr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#python2的用法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    __metaclass__ = UpperAttrMetaClass</span><br><span class="line">    bar = <span class="string">&#x27;bip&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># python3的用法</span></span><br><span class="line"><span class="comment"># class Foo(object, metaclass = UpperAttrMetaClass):</span></span><br><span class="line"><span class="comment">#     bar = &#x27;bip&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(Foo, <span class="string">&#x27;bar&#x27;</span>))</span><br><span class="line"><span class="comment"># 输出: False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hasattr</span>(Foo, <span class="string">&#x27;BAR&#x27;</span>))</span><br><span class="line"><span class="comment"># 输出:True</span></span><br><span class="line"></span><br><span class="line">f = Foo()</span><br><span class="line"><span class="built_in">print</span>(f.BAR)</span><br><span class="line"><span class="comment"># 输出:&#x27;bip&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="metaclass-属性的作用？"><a href="#metaclass-属性的作用？" class="headerlink" title="__metaclass__ 属性的作用？"></a>__metaclass__ 属性的作用？</h3><ol><li>拦截类的创建</li><li>修改类</li><li>返回修改之后的类</li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-查询</title>
      <link href="/2019/06/28/MySQL-%E6%9F%A5%E8%AF%A2/"/>
      <url>/2019/06/28/MySQL-%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<p>好吧，查询这个重要的操作，可能是数据库操作的“灵魂”吧。</p><span id="more"></span><p>简单的查询操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from students;</span><br></pre></td></tr></table></figure><p>消除重复行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select distinct gender from students;</span><br></pre></td></tr></table></figure><h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><p>使用 where 子句对表中的数据筛选，结果为 True 的行会出现在结果集中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from students where id &gt;= 3;</span><br></pre></td></tr></table></figure><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><ul><li>等于=</li><li>大于&gt;</li><li>大于等于&gt;=</li><li>小于&lt;</li><li>小于等于&lt;=</li><li>不等于!=或&lt;&gt;</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 查询 id 不小于 3 的学生</span><br><span class="line">select * from students where id &gt;= 3;</span><br><span class="line"># 查询 name 不是 &#x27;ahojcn&#x27; 的学生</span><br><span class="line">select * from students where name != &#x27;ahojcn&#x27;;</span><br><span class="line"># 查询没被删除的学生</span><br><span class="line">select * from students where isdelete = 0;</span><br></pre></td></tr></table></figure><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ul><li>and</li><li>or</li><li>not</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查询编号大于 3 的女同学</span><br><span class="line">select * from students where id &gt; 3 and gender = 0;</span><br><span class="line"># 查询编号小于 4 或没有删除的学生</span><br><span class="line">select * from students where id &lt; 4 and isdelete = 0;</span><br></pre></td></tr></table></figure><h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><ul><li>like</li><li>%表示任意多个任意字符</li><li>_表示一个任意字符</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 查询姓 黄 的学生</span><br><span class="line">select * from students where name like &#x27;黄%&#x27;;</span><br><span class="line"># 查询姓 黄 并且名字是一个字的学生</span><br><span class="line">select * from students where name like &#x27;黄_&#x27;;</span><br><span class="line"># 查询姓 黄 或名字中含有 景 的学生</span><br><span class="line">select * from students where name like &#x27;黄%&#x27; or name like &#x27;%景%&#x27;;</span><br></pre></td></tr></table></figure><h3 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h3><ul><li>in表示在一个非连续的范围内</li><li>between … and …表示在一个连续的范围内</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 查询 id 是 1 或 2 或 6 的学生</span><br><span class="line">select * from students where id in (1, 2, 6);</span><br><span class="line"># 查询 id 在 3~8 之间的学生</span><br><span class="line">select * from students where id between 3 and 8;</span><br><span class="line"># 查询 id 在 3~8 的男生</span><br><span class="line">select * from students where id between 3 and 8 and gender = 1;</span><br></pre></td></tr></table></figure><h3 id="NULL-判断"><a href="#NULL-判断" class="headerlink" title="NULL 判断"></a>NULL 判断</h3><p><strong>注意：NULL 与 <code>&#39;&#39;</code> 不同</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查找没有填 birthday 的学生</span><br><span class="line">select * from students where birthday is null;</span><br><span class="line"># 查找填写了 birthday 的女生</span><br><span class="line">select * from students where birthday is not null and gender = 0;</span><br></pre></td></tr></table></figure><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><ul><li>小括号，not，比较运算符，逻辑运算符</li><li>and比or先运算，如果同时出现并希望先算or，需要结合()使用</li></ul><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p>MySQL 提供了 5 个聚合函数，可以快读得到统计数据。</p><ol><li><p>count(*) 表示计算总行数，括号中写星与列名，结果是相同的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查询学生总数</span><br><span class="line">select count(*) from students;</span><br></pre></td></tr></table></figure></li><li><p>max(列)表示求此列的最大值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查询女生的编号最大值</span><br><span class="line">select max(id) from students where gender = 0;</span><br></pre></td></tr></table></figure></li><li><p>min(列)表示求此列的最小值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查询未删除的学生最小编号</span><br><span class="line">select min(id) from students where isdelect = 0;</span><br></pre></td></tr></table></figure></li><li><p>sum(列)表示求此列的和</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查询男生编号之和</span><br><span class="line">select sum(id) from students where gender = 1;</span><br></pre></td></tr></table></figure></li><li><p>avg(列)表示求此列的平均值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查询未删除女生的编号平均值</span><br><span class="line">select avg(id) from students where gender = 0;</span><br></pre></td></tr></table></figure></li></ol><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>按照此字段分组，表示此字段相同的数据会被分到一个组中。</p><p>分组后，只能查询出相同的列，对于有差异的数据列无法从结果集中查出来。</p><p>可以对分组后的数据进行统计，做聚合运算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 语法</span><br><span class="line">select 列1,列2,聚合... from 表名 group by 列1,列2,列3...</span><br><span class="line"></span><br><span class="line"># 查询男、女生总数</span><br><span class="line">select gender as 性别,count(*)</span><br><span class="line">from students</span><br><span class="line">group by gender;</span><br><span class="line"></span><br><span class="line"># 查询各城市总人数</span><br><span class="line">select hometown as 家乡,count(*)</span><br><span class="line">from studnets</span><br><span class="line">group by hometown;</span><br></pre></td></tr></table></figure><h3 id="分组后筛选"><a href="#分组后筛选" class="headerlink" title="分组后筛选"></a>分组后筛选</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 语法</span><br><span class="line">select 列1,列2,聚合... from 表名</span><br><span class="line">group by 列1,列2,列3...</span><br><span class="line">having 列1,...聚合...;</span><br></pre></td></tr></table></figure><p>having后面的条件运算符与 where 的相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 查询男生总人数 1</span><br><span class="line">select count(*) from students where gender = 1;</span><br><span class="line"></span><br><span class="line"># 查询男生总人数 2</span><br><span class="line">select gender as 性别,count(*) from students</span><br><span class="line">group by gender</span><br><span class="line">having gender = 1;</span><br></pre></td></tr></table></figure><h3 id="对比-where-和-having"><a href="#对比-where-和-having" class="headerlink" title="对比 where 和 having"></a>对比 where 和 having</h3><p>where 是对 from 后面指定的表进行数据筛选，属于对原始数据的筛选</p><p>having 是对 group by 的结果进行筛选</p><p><img src="https://i.loli.net/2019/06/28/5d161badbdeb099157.png" alt="对比 where 和 having"></p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>为了方便查看数据，可以对数据进行排序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 语法</span><br><span class="line">select * from 表名</span><br><span class="line">order by 列1 asc|desc,列2 asc|desc,...;</span><br></pre></td></tr></table></figure><ul><li>将行数据按照列1进行排序，如果某些行列1的值相同时，则按照列2排序，以此类推</li><li>默认按照列值从小到大排列</li><li>asc从小到大排列，即升序</li><li>desc从大到小排序，即降序</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 查询未删除男生信息，按学号降序</span><br><span class="line">select * from students</span><br><span class="line">where gender = 1 and isdelete = 0</span><br><span class="line">order by id desc;</span><br><span class="line"></span><br><span class="line"># 查询未删除科目信息，按名称升序</span><br><span class="line">select * from subject</span><br><span class="line">where isdelete = 0</span><br><span class="line">order by title;</span><br></pre></td></tr></table></figure><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>当数据量过大时，在一页中查看数据是一件非常麻烦的事情。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 语法</span><br><span class="line">select * from 表名</span><br><span class="line">limit start,count</span><br></pre></td></tr></table></figure><ul><li>从start开始，获取count条数据</li><li>start索引从0开始</li></ul><h3 id="示例：分页"><a href="#示例：分页" class="headerlink" title="示例：分页"></a>示例：分页</h3><ul><li>已知：每页显示m条数据，当前显示第n页</li><li>求总页数：此段逻辑后面会在python中实现<ul><li>查询总条数p1</li><li>使用p1除以m得到p2</li><li>如果整除则p2为总数页</li><li>如果不整除则p2+1为总页数</li></ul></li><li>求第n页的数据</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from students</span><br><span class="line">where isdelete=0</span><br><span class="line">limit (n-1)*m,m</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/06/28/5d161ceeba31610261.png" alt="结果"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>完整的select语句</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select distinct *</span><br><span class="line">from 表名</span><br><span class="line">where ....</span><br><span class="line">group by ... having ...</span><br><span class="line">order by ...</span><br><span class="line">limit star,count</span><br></pre></td></tr></table></figure><ul><li>执行顺序为：<ul><li>from 表名</li><li>where ….</li><li>group by …</li><li>select distinct *</li><li>having …</li><li>order by …</li><li>limit star,count</li></ul></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-基础</title>
      <link href="/2019/06/28/MySQL-%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/06/28/MySQL-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>好吧，最近快数据库课设了，赶紧<del>复习</del>预习下。虽然之前在阿里云大学看了数据库的课，但是都还给老师了。写课设的东西还需要补一哈子。</p><p>数据无价，谨慎操作。</p><span id="more"></span><h2 id="E-R-模型"><a href="#E-R-模型" class="headerlink" title="E-R 模型"></a>E-R 模型</h2><ul><li>当前物理的数据库都是按照E-R模型进行设计的</li><li>E表示entry，实体</li><li>R表示relationship，关系</li><li>一个实体转换为数据库中的一个表</li><li>关系描述两个实体之间的对应规则，包括<ul><li>一对一</li><li>一对多</li><li>多对多</li></ul></li><li>关系转换为数据库表中的一个列 *在关系型数据库中一行就是一个对象</li></ul><h2 id="三范式"><a href="#三范式" class="headerlink" title="三范式"></a>三范式</h2><ul><li>经过研究和对使用中问题的总结，对于设计数据库提出了一些规范，这些规范被称为范式</li><li>第一范式（1NF)：列不可拆分</li><li>第二范式（2NF)：唯一标识</li><li>第三范式（3NF)：引用主键</li><li>说明：后一个范式，都是在前一个范式的基础上建立的</li></ul><h2 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h2><ul><li>一个数据库就是一个完整的业务单元，可以包含多张表，数据被存储在表中</li><li>在表中为了更加准确的存储数据，保证数据的正确有效，可以在创建表的时候，为表添加一些强制性的验证，包括数据字段的类型、约束</li></ul><h2 id="字段类型"><a href="#字段类型" class="headerlink" title="字段类型"></a>字段类型</h2><ul><li>在mysql中包含的数据类型很多，这里主要列出来常用的几种</li><li>数字：int,decimal</li><li>字符串：varchar,text</li><li>日期：datetime</li><li>布尔：bit</li></ul><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><ul><li>主键primary key</li><li>非空not null</li><li>惟一unique</li><li>默认default</li><li>外键foreign key</li></ul><h2 id="Ubuntu-安装-MySQL"><a href="#Ubuntu-安装-MySQL" class="headerlink" title="Ubuntu 安装 MySQL"></a>Ubuntu 安装 MySQL</h2><p>我用的 centos 7 好吧，还是记一下，以后会用到。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mysql-server mysql-client</span><br><span class="line">然后按照提示输入</span><br></pre></td></tr></table></figure><ul><li>启动</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql start</span><br></pre></td></tr></table></figure><ul><li>停止</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql stop</span><br></pre></td></tr></table></figure><ul><li>重启</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql restart</span><br></pre></td></tr></table></figure><ul><li>允许远程连接</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 找到mysql配置文件</span><br><span class="line">sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf</span><br><span class="line"># 将bind-address=127.0.0.1注释</span><br><span class="line"># 登录mysql，运行命令</span><br><span class="line">grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;mysql&#x27; with grant option;</span><br><span class="line">flush privileges;</span><br><span class="line"># 重启mysql服务</span><br></pre></td></tr></table></figure><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p><strong>远程连接：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -hip地址 -uroot -p</span><br></pre></td></tr></table></figure><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><ul><li>创建数据库</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 注意字符集</span><br><span class="line">create database 数据库名 charset=utf8;</span><br></pre></td></tr></table></figure><ul><li>删除数据库</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop database 数据库名;</span><br></pre></td></tr></table></figure><ul><li>切换数据库</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use 数据库名;</span><br></pre></td></tr></table></figure><ul><li>查看当前选择的数据库</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select database();</span><br></pre></td></tr></table></figure><h3 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h3><p>查看当前选择的数据库里的所有表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show tables;</span><br></pre></td></tr></table></figure><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table 表名(列及类型);</span><br><span class="line">如：</span><br><span class="line">create table students(</span><br><span class="line">id int auto_increment primary key, # auto_increment表示自动增长</span><br><span class="line">sname varchar(10) not null</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 add|change|drop 列名 类型;</span><br><span class="line">如：</span><br><span class="line">alter table students add birthday datetime;</span><br><span class="line"></span><br><span class="line"># 更改表名称</span><br><span class="line">rename table 原表名 to 新表名;</span><br></pre></td></tr></table></figure><h4 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table 表名;</span><br></pre></td></tr></table></figure><h4 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a>查看表结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">desc 表名;</span><br></pre></td></tr></table></figure><h4 id="查看表的创建语句"><a href="#查看表的创建语句" class="headerlink" title="查看表的创建语句"></a>查看表的创建语句</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show create table 表名;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/06/28/5d15cbd71eca981886.png" alt="查看表的创建语句"></p><h3 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h3><h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">全列插入：insert into 表名 values(...)</span><br><span class="line">缺省插入：insert into 表名(列1,...) values(值1,...)</span><br><span class="line"></span><br><span class="line"># 注意一下，同时插入多条数据 MySQL 支持，其他数据库不一定支持</span><br><span class="line">同时插入多条数据：insert into 表名 values(...),(...)...;</span><br><span class="line">或insert into 表名(列1,...) values(值1,...),(值1,...)...;</span><br></pre></td></tr></table></figure><h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from 表名 where 条件</span><br></pre></td></tr></table></figure><h4 id="改"><a href="#改" class="headerlink" title="改"></a>改</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update 表名 set 列1=值1,... where 条件</span><br></pre></td></tr></table></figure><h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from 表名</span><br></pre></td></tr></table></figure><h4 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h4><p>数据无价，谨慎操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter table students add isdelete bit default 0;</span><br><span class="line">如果需要删除则</span><br><span class="line">update students isdelete=1 where ...;</span><br></pre></td></tr></table></figure><h3 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h3><h4 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h4><ul><li>进入超级管理员</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -s</span><br></pre></td></tr></table></figure><ul><li>进入mysql库目录</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /var/lib/mysql</span><br></pre></td></tr></table></figure><ul><li>运行mysqldump命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqldump –uroot –p 数据库名 &gt; ~/Desktop/备份文件.sql;</span><br><span class="line">按提示输入mysql的密码</span><br></pre></td></tr></table></figure><h4 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h4><ul><li>连接mysql，创建数据库</li><li>退出连接，执行如下命令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot –p 数据库名 &lt; ~/Desktop/备份文件.sql</span><br><span class="line">根据提示输入mysql密码</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python删除list时的一个坑</title>
      <link href="/2019/06/26/Python%E5%88%A0%E9%99%A4list%E6%97%B6%E7%9A%84%E4%B8%80%E4%B8%AA%E5%9D%91/"/>
      <url>/2019/06/26/Python%E5%88%A0%E9%99%A4list%E6%97%B6%E7%9A%84%E4%B8%80%E4%B8%AA%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p>啥东西都有坑。</p><p>记 Python 删除 list 元素的一个坑。</p><span id="more"></span><h2 id="果"><a href="#果" class="headerlink" title="果"></a>果</h2><p><img src="https://i.loli.net/2019/06/26/5d1383594dc0935169.png" alt="？"></p><p><strong>描述：</strong></p><p>在循环删除一个 list 中的元素的时候，会出现上面的结果。</p><h2 id="因"><a href="#因" class="headerlink" title="因"></a>因</h2><p>上图，一张图描述清楚。</p><p><img src="https://i.loli.net/2019/06/26/5d1385529739359471.png" alt="！"></p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p><img src="https://i.loli.net/2019/06/26/5d13860c8808049879.png" alt="b"></p><hr>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>孤儿进程和僵尸进程</title>
      <link href="/2019/06/18/%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/"/>
      <url>/2019/06/18/%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>孤儿进程和僵尸进程的概念，回收进程资源(wait、waitpid)。</p><span id="more"></span><h2 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h2><p>孤儿进程：父进程先于子进程结束，则子进程程伟孤儿进程，子进程的父进程成为 init 进程，称为 init 领养了这个孤儿进程。</p><p>init 进程会循环地 wait() 它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。因此孤儿进程并不会有什么危害。</p><h3 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> ret = fork();</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1. i&#x27; am child, my father is: %d\n&quot;</span>, getppid()); </span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;2. i&#x27; am child, my father is: %d\n&quot;</span>, getppid());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i&#x27;m going to die.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/06/18/5d08bed266b4420376.png" alt="孤儿进程被init领养"></p><h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><p>僵尸进程：进程终止，父进程对其不管不顾，子进程残留资源(PCB)存放于内核中，变成僵尸(Zombie)进程。</p><p>僵尸进程是不能使用 kill 命令清除掉的。因为 kill 命令指示用来终止进程的，而僵尸进程已经终止。杀掉僵尸进程的方法就是 kill 掉他的父进程。</p><p>想到个栗子：武林大哥让小弟去干一件事，小弟在办事途中意外挂了，但他留了一封血书信给大哥，告诉他大哥自己是怎么挂的，让大哥去给他报仇去。这封信就是PCB。但是如果大哥不在意这件事，这个 PCB 就会一直存在。</p><h3 id="栗子-1"><a href="#栗子-1" class="headerlink" title="栗子"></a>栗子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> ret = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child process : i&#x27;m going to die.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;father process : pid = %d, and my son pid = %d\n&quot;</span>, getpid(), ret);</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/06/18/5d08c4500fafd63657.png" alt="运行中"></p><p><img src="https://i.loli.net/2019/06/18/5d08c4ea435af39607.png" alt="僵尸进程，杀不死"></p><h2 id="回收"><a href="#回收" class="headerlink" title="回收"></a>回收</h2><p>一个进程在终止的时候会关闭所有文件描述符，释放在用户控件分配的内存，但它的 PCB 还保留着，内核在其中保存了一些信息：如果进程是正常终止则保存着退出状态，如果是异常终止则保存着导致该进程终止的信号是哪个。</p><p>这个进程的父进程可以调用 wait 或 waitpid 获取这些信息，然后彻底清除掉这个进程。</p><p>一个进程的退出状态可以在 shell 中用 <code>$?</code> 查看，因为 shell 是它的父进程，当它终止时 shell 调用 wait 或 waitpid 得到它的退出状态同时彻底清除掉这个进程占用的资源。</p><p>当进程终止时，操作系统的隐式回收机制：1.关闭所有文件描述符；2.释放用户空间分配的内存。内核的 PCB 仍存在。其中保存该进程的退出状态。(正常终止：退出值；异常终止：终止信号)</p><p>注意wait 和 waitpid 获取退出状态的时候并不是一个 int 都是退出的状态。在网上找到的资料画出来应该是下面这样的，这个status 是由操作系统填充的，他并不真的、简单的当做一个 int 类型。status 的低 16 位是真正我们关心的。当然也可以用宏获取这个进程的退出状态。下文中有</p><p><img src="https://i.loli.net/2019/06/12/5d006eaa2202331296.png" alt="status"></p><h3 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *stat_loc)</span>;</span><br><span class="line"></span><br><span class="line">返回：</span><br><span class="line">成功：清理掉的子进程 ID</span><br><span class="line">失败：<span class="number">-1</span>(没有子进程)</span><br><span class="line"></span><br><span class="line">参数：输出型参数，不关心子进程的退出状态可以填 <span class="literal">NULL</span></span><br></pre></td></tr></table></figure><ul><li>阻塞式的等待子进程退出</li><li>回收子进程残留资源</li><li>获取子进程结束状态</li><li>一次 wait 只回收一个子进程 </li></ul><h4 id="栗子1"><a href="#栗子1" class="headerlink" title="栗子1"></a>栗子1</h4><p>直接回收，不关心子进程的退出码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> ret = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child process : i&#x27;m going to die.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="type">pid_t</span> w_ret = wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (w_ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;wait error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/06/18/5d08ce0b3638042606.png" alt="执行结果"></p><p><img src="https://i.loli.net/2019/06/18/5d08ce34dec7c69546.png" alt="ps 查看，子进程已经被回收"></p><h4 id="栗子2"><a href="#栗子2" class="headerlink" title="栗子2"></a>栗子2</h4><p>使用 wait 的参数 status 来保存进程的退出状态。借助红函数来进一步判断进程终止的具体原因。宏函数在 man page 中有详细的介绍。</p><blockquote><ol><li><p>WIFEXITED(status) 为非0，进程正常结束『wait, if exited』</p><p>WEXITSTATUS(status) 如上宏为真，使用此宏，获取进程退出状态『wait, exit status』</p></li><li><p>WIFSIGNALED(status) 为非0，进程异常终止『wait, if signaled』</p><p>WTERMSIG(status) 如上宏为真，使用此宏，取得使进程终止的那个信号的编号『wait, term signaled』</p></li><li><p>WIFSTOPPED(status) 为非0，进程处于暂停状态『wait, if stopped』</p><p>WSTOPSIG(status) 如上宏为真，使用此宏，取得使进程暂停的那个信号的编号『wait, stop signal』</p><p>WIFCONTINUED(status) 为真，进程暂停后已经继续运行『wait, if continued』</p></li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    调用 wait 回收子进程资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> ret = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child process : i&#x27;m going to die.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">101</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line">        <span class="type">pid_t</span> w_ret = wait(&amp;status);</span><br><span class="line">        <span class="keyword">if</span> (w_ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;wait error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child exit with %d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/06/18/5d08d2a15f6d132781.png" alt="获取子进程的退出状态"></p><h4 id="栗子3"><a href="#栗子3" class="headerlink" title="栗子3"></a>栗子3</h4><p>获取让子进程退出的信号，奥，对还有信号这个知识还不是很了解，看看书找找资料学习学习写到博客里。<code>kill -l</code>查看信号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    调用 wait 回收子进程资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> ret = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child process : i&#x27;m going to die.\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">101</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line">        <span class="type">pid_t</span> w_ret = wait(&amp;status);</span><br><span class="line">        <span class="keyword">if</span> (w_ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;wait error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child exit with %d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (WIFSIGNALED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child exit by sig %d\n&quot;</span>, WTERMSIG(status));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/06/18/5d08d418c1be347460.png" alt="kill 子进程"></p><p><img src="https://i.loli.net/2019/06/18/5d08d436ef76b36645.png" alt="kill by 15"></p><h3 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid"></a>waitpid</h3><p>可以指定 pid 进行清理，<strong>可以</strong>不阻塞。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *stat_loc, <span class="type">int</span> options)</span>;</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">pid：</span><br><span class="line">&gt; <span class="number">0</span>，回收指定的子进程</span><br><span class="line"><span class="number">-1</span> ，回收任意子进程</span><br><span class="line"><span class="number">0</span>  ，回收和当前调用 waitpid 一个组的所有子进程</span><br><span class="line">&lt; <span class="number">-1</span>，回收指定进程组内的任意子进程</span><br><span class="line">status：</span><br><span class="line"> 输出参数，子进程的退出状态</span><br><span class="line">  options：</span><br><span class="line">  WNOHANG，非阻塞方式 <span class="comment">// would no hang, 不会挂起(不会阻塞, hang 悬挂；暂停，中止)</span></span><br><span class="line">  <span class="number">0</span> ,阻塞方式</span><br><span class="line">  nohang</span><br><span class="line"></span><br><span class="line">返回：</span><br><span class="line">成功：返回清理掉的子进程pid</span><br><span class="line">失败：<span class="number">-1</span>(无子进程)</span><br><span class="line">  <span class="number">0</span>  ：参数 options 为 WNOHANG，且子进程正在运行</span><br><span class="line">  </span><br><span class="line">waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>) == wait(<span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态库和静态库</title>
      <link href="/2019/06/16/%E5%8A%A8%E6%80%81%E5%BA%93%E5%92%8C%E9%9D%99%E6%80%81%E5%BA%93/"/>
      <url>/2019/06/16/%E5%8A%A8%E6%80%81%E5%BA%93%E5%92%8C%E9%9D%99%E6%80%81%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>动态链接库、静态链接库。</p><span id="more"></span><h2 id="库的命名规则"><a href="#库的命名规则" class="headerlink" title="库的命名规则"></a>库的命名规则</h2><p>Linux 下，以 lib 开头，<code>.a</code>结尾是静态库，<code>.so</code>结尾是动态库。</p><p>Windows 下，以 lib 开头，<code>.lib</code>是静态库，<code>.dll</code>是动态库。</p><h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><p>Windows 下 的后缀是 .lib，Linux 下的后缀是 .a。</p><p>把一些 .o 文件打包到一起生成了一种特殊的二进制程序，自身不能直接执行，但是可以和其他的 .c/.cpp 文件一起编译生成一个新的可执行程序，这个新的可执行程序就可以单独发布出去了。</p><p><strong>应用场景：</strong>发布小型程序的时候，就可以使用静态库的方式编译生成一个单独的可执行程序，并且不依赖其他的库，发布比较方便。</p><h3 id="栗子-mymath-a"><a href="#栗子-mymath-a" class="headerlink" title="栗子 mymath.a"></a>栗子 mymath.a</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;add.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sub.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sub.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sub.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sub.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;add.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;add(20, 10) = %d\n&quot;</span>, add(a, b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sub(20, 10) = %d\n&quot;</span>, sub(a, b));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/06/16/5d06115c7d6a781665.png" alt="生成静态库并使用"></p><h4 id="生成静态库"><a href="#生成静态库" class="headerlink" title="生成静态库"></a>生成静态库</h4><p><code>ar -rc libmymath.a add.o sub.o</code></p><p>ar 是 GNU 归档工具；rc 表示(replace and create)</p><h4 id="查看静态库中的目录列表"><a href="#查看静态库中的目录列表" class="headerlink" title="查看静态库中的目录列表"></a>查看静态库中的目录列表</h4><p><code>ar -tv libmymath.a</code></p><p>t 列出静态库中的文件；v 详细信息(verbose)。</p><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p><code>gcc main.c -L. -lmymath</code></p><p>-L 指定库路径，在当前目录下；-l 指定库名。</p><h2 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h2><p>把一些 .c/.cpp 文件编译成了一种特殊的二进制程序，自身不能直接执行，但是可以被其他可执行程序调用。在可执行文件开始运行以前，外部函数的机器码由操作系统从磁盘上的该动态库中复制到内存中，这个过程称为动态链接(dynamic linking)。</p><p>动态库可以在多个程序间共享，所以动态链接使得可执行文件更小，节省了磁盘空间。操作系统采用虚拟内存机制允许物理内存中的一份动态库被要用到该库的所有进程共用，节省了内存和磁盘空间。</p><p><strong>应用场景：</strong>客户端更新时不必要更新整个程序，而是只更新其中的一部分模块。其中的模块就是以动态链接库的方式组织的。</p><h3 id="栗子-mymath-so"><a href="#栗子-mymath-so" class="headerlink" title="栗子 mymath.so"></a>栗子 mymath.so</h3><p><img src="https://i.loli.net/2019/06/16/5d0616afa13cf36936.png" alt="生成动态库并使用"></p><h4 id="生成动态库"><a href="#生成动态库" class="headerlink" title="生成动态库"></a>生成动态库</h4><p><code>gcc -fPIC -c sub.c add.c</code></p><p>-fPIC 产生位置无关码(position independent code)</p><p><code>gcc -shared -o libmymath.so *.o</code></p><p>-shared 表示生成共享库格式</p><h4 id="使用动态库"><a href="#使用动态库" class="headerlink" title="使用动态库"></a>使用动态库</h4><p><code>gcc main.c -L. -lmymath</code></p><p>-L 指定路径；-l 指定动态库名称。</p><h4 id="查看某个程序的动态库依赖"><a href="#查看某个程序的动态库依赖" class="headerlink" title="查看某个程序的动态库依赖"></a>查看某个程序的动态库依赖</h4><ul><li><p>Linux 下<code>ldd exeFileName</code></p><p><img src="https://i.loli.net/2019/06/16/5d0618971448496206.png" alt="ldd"></p></li><li><p>Mac 下<code>otool -L execFileName</code></p><p><img src="https://i.loli.net/2019/06/16/5d0618c6340d860386.png" alt="otool -L"></p></li></ul><h4 id="运行动态库"><a href="#运行动态库" class="headerlink" title="运行动态库"></a>运行动态库</h4><p>有的时候可能找不到库，就需要配置下了。</p><ol><li><p>拷贝.so文件到系统共享库路径下，一般指<code>/usr/lib</code></p></li><li><p>更改 LIBRARY_PATH 环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=.</span><br></pre></td></tr></table></figure></li><li><p>ldconfig 配置<code>/etc/ld.so.conf.d/</code>，ldconfig更新</p></li></ol><h2 id="库的搜索路径"><a href="#库的搜索路径" class="headerlink" title="库的搜索路径"></a>库的搜索路径</h2><ol><li>从左到右搜索 -L 指定的目录。</li><li>由环境变量指定的目录(LIBRARY_PATH，设定这个环境变量来提醒系统去哪些目录找动态库)</li><li>由系统指定的目录(<code>/usr/lib /usr/local/lib</code>)</li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重定向</title>
      <link href="/2019/06/16/%E9%87%8D%E5%AE%9A%E5%90%91/"/>
      <url>/2019/06/16/%E9%87%8D%E5%AE%9A%E5%90%91/</url>
      
        <content type="html"><![CDATA[<p>当时看翁凯老师的 C 语言课程，用到了 &gt;。懵逼状态，这几天在看 Linux 系统编程和鸟哥的私房菜，逐渐明白点了。</p><p>这个重定向呢……其实就是本来要输出到一个文件(从一个文件获取输入)后来被重定向到别的地方了。上图</p><p><img src="https://i.loli.net/2019/06/16/5d05e4e87aae536852.png" alt="重定向"></p><h2 id="dup2-系统调用重定向"><a href="#dup2-系统调用重定向" class="headerlink" title="dup2 系统调用重定向"></a>dup2 系统调用重定向</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">       <span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br></pre></td></tr></table></figure><p>对比上图，应该这样调用：<code>dup2(3, 1)</code>，这样原本要输出到屏幕的东西就输出到 myfile 文件中了。</p><h3 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;log&quot;</span>, O_CREAT | O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dup2(fd, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hahahahaha\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/06/16/5d05e6f63f07179523.png" alt="dup2Test.c"></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统文件IO</title>
      <link href="/2019/06/16/Linux%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6IO/"/>
      <url>/2019/06/16/Linux%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6IO/</url>
      
        <content type="html"><![CDATA[<p>在 C 中有 fread、fwrite 等读写文件的库函数，Linux 系统也提供了操作文件的系统调用。</p><span id="more"></span><p>fopen、fclose、fread、fwrite 都是 C 标准库中的函数，libc。</p><p>Linux 中关于文件 IO 的系统调用：open、close、read、write、lseek。</p><p>注意缓冲策略：</p><p>write 无缓冲，printf 行缓冲。</p><blockquote><p>常见缓冲策略：</p><ol><li><p>无缓冲</p><p>例如：write 系统调用</p></li><li><p>行缓冲：遇到 \n 就刷新，或者缓冲区满才刷新，或者手动花心(fflush)</p><p>例如：打印到显示器</p></li><li><p>全缓冲：一直到缓冲区满才刷新，或者手动刷新</p><p>例如：输出到文件</p></li></ol></blockquote><h2 id="文件描述符-fd"><a href="#文件描述符-fd" class="headerlink" title="文件描述符 fd"></a>文件描述符 fd</h2><p>Linux 上一个进程运行了后，默认打开三个文件：stdin、stdout、stderr。</p><p>用什么来确定这三个文件在哪里呢？或者说如果我要从键盘读入一些东西，应该从哪个文件读呢？</p><p>文件描述符、文件描述符表。</p><p><strong>文件描述符表</strong>是一个指针数组，每一个元素都是一个 file* 指针，指向一个已经打开的文件。</p><p><strong>文件描述符</strong>是这个指针数组的下标，所以只要拿着文件描述符，就可以找到对应的文件。</p><p>我在网上看到别人说在 Linux 内核中并不是简单的数组下标，是通过 hash 计算出来的，咱现在也不懂，后面看到了再补充。</p><p><img src="https://i.loli.net/2019/06/16/5d05c4a47026183736.png" alt="文件描述符表"></p><h2 id="文件描述符分配规则"><a href="#文件描述符分配规则" class="headerlink" title="文件描述符分配规则"></a>文件描述符分配规则</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// close(0);</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;baseCIO.c&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd : %d\n&quot;</span>, fd);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/06/16/5d05c6cc8181014005.png" alt="//close(0)"></p><p><img src="https://i.loli.net/2019/06/16/5d05d39291f3279914.png" alt="close(0)"></p><p><strong>文件描述符分配规则：在数组中找到当前没有被使用的最小的下标，作为新的文件描述符。</strong></p><h2 id="open"><a href="#open" class="headerlink" title="open"></a>open</h2><p>man open：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line">       <span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> <span class="title function_">creat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p><strong>pathname：</strong>要打开或创建的目标文件</p><p><strong>flags：</strong>打开文件时，可以传入多个参数选项(位图的方式)，用下面的一个或者多个常量进行”或”运算，构成 flags。</p><ul><li><p>O_RDONLY 只读打开</p></li><li><p>O_WRONLY 只写打开</p></li><li><p>O_RDWR 读，写打开</p><p>上面这三个常量，必须指定并且只能指定一个。</p></li><li><p>O_CREAT 若文件不存在，则创建。需要使用 mode 选项来指明新文件的访问权限。</p></li><li><p>O_APPEND 追加写</p></li></ul><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>成功：新打开的文件描述符</p><p>失败：-1</p><h3 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写文件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">writeFile</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;test&quot;</span>, O_WRONLY | O_CREAT, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* msg = <span class="string">&quot;hello sys io\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// msg:缓冲区首地址， len: 本次读取，期望写入多少个字节的数据。 </span></span><br><span class="line">        <span class="comment">// 返回值:实际写了多少字节数据</span></span><br><span class="line">        <span class="type">ssize_t</span> real_len = write(fd, msg, <span class="built_in">strlen</span>(msg));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;real len = %lu\n&quot;</span>, real_len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读文件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">readFile</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;test&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* msg = <span class="string">&quot;hello sys io\n&quot;</span>;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">ssize_t</span> s = read(fd, buf, <span class="built_in">strlen</span>(msg));</span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;buf = %s&quot;</span>, buf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    writeFile();</span><br><span class="line">    </span><br><span class="line">    readFile();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/06/16/5d05dbbe8fb9362656.png" alt="sysIO.c 读写文件"></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>exec函数族</title>
      <link href="/2019/06/15/exec%E5%87%BD%E6%95%B0%E6%97%8F/"/>
      <url>/2019/06/15/exec%E5%87%BD%E6%95%B0%E6%97%8F/</url>
      
        <content type="html"><![CDATA[<p>进程的程序替换，exec 函数族。</p><span id="more"></span><p>fork 创建子进程后执行的是和父进程相同的程序，如果需要他执行不同的代码分支，子进程旺旺需要调用一种 exec 函数以执行另一个程序。当进程调用一种 exec 函数时，该进程的用户空间代码的数据完全被新程序替换，从新程序的启动例程开始执行。调用 exec 并不创建新的进程，所以调用 exec 前后该进程的 id 并未改变。</p><p>当前进程的 .text 和 .data 替换为所需要加载的程序的 .text 和 .data，然后让进程从新的 .text 第一条指令开始执行，进程的 id 不变，换核子不换壳子。</p><p>exec 函数族的一些参数有些不同，底层实现原理一样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SYNOPSIS</span><br><span class="line">     <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">     <span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line">     <span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg0, ... <span class="comment">/*, (char *)0 */</span>)</span>;</span><br><span class="line">     <span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg0, ... <span class="comment">/*, (char *)0, char *const envp[] */</span>)</span>;</span><br><span class="line">     <span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg0, ... <span class="comment">/*, (char *)0 */</span>)</span>;</span><br><span class="line">     <span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line">     <span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line">     <span class="type">int</span> <span class="title function_">execvP</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *search_path, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br></pre></td></tr></table></figure><ul><li>l(list) : 表示参数采用列表</li><li>v(vector) : 参数用数组</li><li>p(path) : 有p自动搜索环境变量PATH</li><li>e(env) : 表示自己维护环境变量</li></ul><p>事实上，只有 execve 是真正的系统调用，其他五个函数最终都调用 execve，所以 execve 在 man 手册第 2 节，其他函数在 man 手册的第 3 节。这些函数之间的关系如下图：</p><p><img src="https://i.loli.net/2019/06/15/5d0502939704b54309.png" alt="exec函数族，图片来源于网络"></p><h2 id="execl"><a href="#execl" class="headerlink" title="execl()"></a>execl()</h2><p>加载一个进程，通过 路径+程序名 来加载。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg0, ... <span class="comment">/*, (char *)0 */</span>)</span>;</span><br></pre></td></tr></table></figure><p><strong>返回：</strong>成功：无返回；失败：-1。</p><p><strong>参数：</strong>path：可执行程序的路径，如<code>/bin/ls</code>。后面跟要传给这个程序的参数。</p><p>有了这个函数就可以来加载一个自定义的程序了。</p><p><strong>栗子：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> ret = fork();</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        execl(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-a&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;father process\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/06/15/5d04fafe493f341303.png" alt="execl_ls.c"></p><h2 id="execlp"><a href="#execlp" class="headerlink" title="execlp()"></a>execlp()</h2><p>加载一个进程，借助 PATH 环境变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg0, ... <span class="comment">/*, (char *)0 */</span>)</span>;</span><br></pre></td></tr></table></figure><p><strong>返回：</strong>成功：没有返回；失败：-1。</p><p><strong>参数：</strong>file：要加载的程序名。该函数需要配合 PATH 环境变量来使用，当 PATH 中所有目录搜索后没有参数 file 则返回出错。后面跟传给要执行程序的参数。</p><p>该函数通常用来调用系统程序。如：ls、date、cp、cat 等。</p><p><strong>栗子：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> ret = fork();</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        execlp(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-al&quot;</span>, <span class="literal">NULL</span>); <span class="comment">// 注意第二个参数 ls 对应到main函数的参数就是argv[0]，传给ls其实他并没有使用这个参数</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;father process\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/06/15/5d04f8c740edb46877.png" alt="execlp_ls.c"></p><h2 id="execle"><a href="#execle" class="headerlink" title="execle()"></a>execle()</h2><p>最后一个参数是一个数组，自己的环境变量数组，这个数组必须以 NULL 结尾。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg0, ... <span class="comment">/*, (char *)0, char *const envp[] */</span>)</span>;</span><br></pre></td></tr></table></figure><h2 id="execv"><a href="#execv" class="headerlink" title="execv()"></a>execv()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br></pre></td></tr></table></figure><p><strong>栗子：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> ret = fork();</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="type">char</span>* argv[] = &#123;<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-a&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">        execv(<span class="string">&quot;/bin/ls&quot;</span>, argv);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;father process\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/06/15/5d04fe272568247345.png" alt="execv_ls.c"></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在linux中查找</title>
      <link href="/2019/06/14/%E5%9C%A8linux%E4%B8%AD%E6%9F%A5%E6%89%BE/"/>
      <url>/2019/06/14/%E5%9C%A8linux%E4%B8%AD%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<p>find / -name python</p><p>whereis python</p><p>which python</p><p>查找文件中的文本信息 grep -r “task_struct {“ /usr</p><p>参考：</p><p><a href="https://linux.cn/article-9384-1.html">为初学者介绍 Linux whereis 命令（5个例子）</a></p><p><a href="https://www.runoob.com/linux/linux-comm-whereis.html">Linux whereis命令</a></p><p><a href="https://www.cnblogs.com/cjjjj/p/9846374.html">linux中whereis、which、find、location的区别和用法</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PCB-task_struct</title>
      <link href="/2019/06/14/PCB-task-struct/"/>
      <url>/2019/06/14/PCB-task-struct/</url>
      
        <content type="html"><![CDATA[<p>之前总结知识的时候有个图是稍微有些问题的。task_struct 应该画在内核空间里面，我画在外面了。</p><p>每个进程在内核中都有一个进程控制块(PCB)来维护进程相关的信息，Linux 内核的进程控制块是task_struct 结构体。之前有一篇笔记，这里是补充。<a href="https://ahoj.cc/2019/06/cjww8ru23006pzyo4vc40niei/"><a href="https://ahoj.cc/2019/06/cjww8ru23006pzyo4vc40niei/">https://ahoj.cc/2019/06/cjww8ru23006pzyo4vc40niei/</a></a></p><span id="more"></span><p><img src="https://i.loli.net/2019/06/14/5d03c0686924018792.png" alt="task_struct的位置"></p><p>这个结构体大概 400 多行。。。好大啊🙄。</p><p>这个结构体中有以下内容(找资料弄得，不全，后面看到了再补上)：</p><p><strong>进程id</strong>，系统中每个进程有唯一的 id，在 C 语言中用 pid_t 表示，pid_t 是 typedef 的，本质是一个 unsigned int。</p><p><strong>进程状态</strong>，有init、就绪、运行、挂起、停止等状态。</p><p><strong>上下文</strong>，进程切换时候需要保存和恢复的一些 CPU 寄存器。</p><p><strong>虚拟地址-物理地址映射表</strong>。</p><p><strong>描述控制终端的信息</strong>，运行 ps 后 TTY 那一列。</p><p><strong>当前进程的工作目录</strong>，每个进程的工作目录可能是不一样的，所以要记录一下。</p><p><strong>umask掩码</strong>。</p><p><strong>文件描述符表</strong>，包含很多指向 file 结构体的指针。</p><p><strong>和信号相关的信息</strong>。</p><p><strong>用户 id 和组 id</strong>。</p><p><strong>会话（Session）和进程组。</strong></p><p><strong>进程可以使用的资源上限（resource limit）</strong>。ulimit -a  (╯3╰)。</p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>环境变量操作函数</title>
      <link href="/2019/06/14/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0/"/>
      <url>/2019/06/14/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>代码以及一些注意事项。</p><span id="more"></span><p>代码实验：</p><h2 id="getenv"><a href="#getenv" class="headerlink" title="getenv()"></a>getenv()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>The  getenv() function searches the environment list to find the environment variable name, and returns a pointer to the corresponding value string. The getenv() function returns a pointer to the value in the environment, or NULL if there is no match.</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取一个不存在的环境变量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name = <span class="string">&quot;ABCD&quot;</span>;</span><br><span class="line">    <span class="type">char</span>* ret_val = getenv(name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s = %s\n&quot;</span>, name, ret_val); <span class="comment">// 直接 %s 输出 null 是输出的 (null)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取一个存在的环境变量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* path = <span class="string">&quot;PATH&quot;</span>;</span><br><span class="line">    <span class="type">char</span>* path_val = getenv(path);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s = %s\n&quot;</span>, path, path_val);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/06/14/5d03afb46558684199.png" alt="getenv输出"></p><h2 id="setenv-amp-putenv"><a href="#setenv-amp-putenv" class="headerlink" title="setenv() &amp; putenv()"></a>setenv() &amp; putenv()</h2><h3 id="setenv"><a href="#setenv" class="headerlink" title="setenv()"></a>setenv()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *value, <span class="type">int</span> overwrite)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">putenv</span><span class="params">(<span class="type">char</span> *<span class="built_in">string</span>)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>The  setenv()  function  adds the variable name to the environment with the value value, if name does not already exist.  If name does exist in the environment, then its value is changed to value if overwrite is nonzero; if overwrite is zero, then the value of name  is not changed.  This function makes copies of the strings pointed to by name and value (by contrast with putenv(3)).</p><p>The setenv() function returns zero on success, or -1 on error, with errno set to indicate the cause of the error.</p><p>注意一哈哈：如果这个环境变量已经存在了，overwrite传非0值，会覆盖原有的环境变量。传0则不会覆盖。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 设置一个不存在的环境变量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name = <span class="string">&quot;ABCD&quot;</span>;</span><br><span class="line">    setenv(name, <span class="string">&quot;aaa-bbb-ccc-ddd&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="type">char</span>* ret_val = getenv(name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s = %s\n&quot;</span>, name, ret_val);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/06/14/5d03b0ec1442255840.png" alt="输出及测试"></p><h3 id="putenv"><a href="#putenv" class="headerlink" title="putenv()"></a>putenv()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    setenv(<span class="string">&quot;ABCD&quot;</span>, <span class="string">&quot;aaa-bbb-ccc-ddd&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s = %s\n&quot;</span>, <span class="string">&quot;ABCD&quot;</span>, getenv(<span class="string">&quot;ABCD&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> abcd[<span class="number">1024</span>] = <span class="string">&quot;ABCD=abcd&quot;</span>; <span class="comment">// 注意这里如果是 const char * 会有警告，因为参数要的是char *</span></span><br><span class="line">    <span class="type">int</span> ret = putenv(abcd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s = %s\n&quot;</span>, <span class="string">&quot;ABCD&quot;</span>, getenv(<span class="string">&quot;ABCD&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/06/14/5d03bbb11a1cd12741.png" alt="输出"></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>运行<code>env.out</code>程序后设置的环境变量是给这个程序设置的环境变量。emmm，没描述清楚，我想想怎么表达。</p><p>env.out执行setenv设置的环境变量，只有在它的那个进程中可用。</p><h2 id="unsetenv"><a href="#unsetenv" class="headerlink" title="unsetenv()"></a>unsetenv()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">unsetenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>The  unsetenv() function deletes the variable name from the environment.  If name does not exist in the environment, then the function succeeds, and the environment is unchanged. The unsetenv() function returns zero on success, or -1 on error, with errno set to indicate the cause of the error.</p><p>如果要删除的环境变量不存在，返回的是0。也就是说你没有这个环境变量他也会帮你抹除，如果传入的参数是有误的(比如传入”ABCD=”)，则会返回错误（-1）。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    setenv(<span class="string">&quot;ABCD&quot;</span>, <span class="string">&quot;aaa-bbb-ccc-ddd&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s = %s\n&quot;</span>, <span class="string">&quot;ABCD&quot;</span>, getenv(<span class="string">&quot;ABCD&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = unsetenv(<span class="string">&quot;ABCD&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/06/14/5d03b84795f8438953.png" alt="ret = 0"></p><p>将unsetenv的参数修改为：<code>&quot;ABC=&quot;</code></p><p><img src="https://i.loli.net/2019/06/14/5d03b8a692b8080906.png" alt="ret = -1"></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程控制</title>
      <link href="/2019/06/12/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
      <url>/2019/06/12/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>进程退出return、exit()、_exit()、进程等待（接儿子放学咯）。</p><span id="more"></span><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>Linux 系统中，用户创建子进程的唯一方法就是使用 <a href="https://ahoj.cc/2019/06/cjwrvtuz10041zyqx26a5n0er/">fork</a> 系统调用。</p><p><img src="https://i.loli.net/2019/06/12/5d0061b90db4111903.png" alt="大致流程，图片来源于网络"></p><h2 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h2><p>一个程序（进程）退出了，无非有一下几种情况：</p><ul><li>代码运行完毕，结果正确</li><li>代码执行完毕，结果不正确</li><li>代码异常终止</li></ul><p>之前看GitHub上别人代码里用 <code>exit(1)</code> 这样的方式写，虽然知道他就是结束程序，但并不知道具体的意思。查下资料吧。</p><h3 id="常见退出方法"><a href="#常见退出方法" class="headerlink" title="常见退出方法"></a>常见退出方法</h3><ul><li>正常终止<ul><li>main 函数 return</li><li>调用 exit</li><li>调用 _exit 系统调用</li></ul></li><li>异常终止<ul><li>ctrl + c、ctrl + d之类的</li><li>程序异常(比如除数为0等)</li></ul></li></ul><h4 id="exit-系统调用"><a href="#exit-系统调用" class="headerlink" title="_exit 系统调用"></a>_exit 系统调用</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">man _exit</span></span><br><span class="line">NAME</span><br><span class="line">     _exit -- terminate the calling process</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">     #include &lt;unistd.h&gt;</span><br><span class="line">     void _exit(int status);</span><br></pre></td></tr></table></figure><p>status 定义了进程的终止状态，父进程通过 wait 来获取该值，在 bash 中使用 <code>$?</code> 来看上一个进程(程序)的退出码。虽然 status 是 int，但是仅有低8位可以被父进程所用。所以<code>_exit(-1)</code>时，在终端执行<code>$?</code>发现返回值<br>是255。</p><h4 id="exit-库函数"><a href="#exit-库函数" class="headerlink" title="exit 库函数"></a>exit 库函数</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SYNOPSIS</span><br><span class="line">    #include &lt;unistd.h&gt;</span><br><span class="line">    void exit(int status);</span><br></pre></td></tr></table></figure><p>这是一个 C 的库函数，本质上调用了 _exit，有一些区别：</p><ol><li><p>关闭了文件流并刷新了缓冲区，通过简单的代码即可实验验证</p></li><li><p>exit 比 _exit 多调用了一个结束处理函数( atexit/on_exit 函数，参数是一个函数指针，这个好比vue中的生命周期钩子函数)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">man atexit</span></span><br><span class="line">NAME</span><br><span class="line">     atexit -- register a function to be called on exit</span><br><span class="line">SYNOPSIS</span><br><span class="line">     #include &lt;stdlib.h&gt;</span><br><span class="line">     int atexit(void (*function)(void));</span><br><span class="line">     int atexit_b(void (^function)(void));</span><br></pre></td></tr></table></figure></li></ol><h4 id="return"><a href="#return" class="headerlink" title="return"></a>return</h4><p>return是一种更常见的退出进程方法。执行<code>return n</code>等同于执行<code>exit(n)</code>,因为调用main的运行时函数会将main的返回值当做 exit 的参数。</p><h2 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h2><p><a href="https://ahoj.cc/2019/06/cjwrvtuzr0053zyqxemzp2klf/#%E6%A8%A1%E6%8B%9F">进程状态</a>，子进程退出，父进程不管不顾就可能造成”僵尸🧟‍♀️”进程，造成内存泄漏。交给子进程的任务也不知道他完成的怎么样了，父进程为了获取子进程完成任务的情况以及回收资源，可以通过<strong>进程等待</strong>的方式进行。</p><h3 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">man 2 <span class="built_in">wait</span></span></span><br><span class="line">SYNOPSIS</span><br><span class="line">       #include &lt;sys/types.h&gt;</span><br><span class="line">       #include &lt;sys/wait.h&gt;</span><br><span class="line">       pid_t wait(int *status);</span><br><span class="line">返回：</span><br><span class="line">成功，返回被等待进程pid。失败，返回-1。</span><br><span class="line">参数：</span><br><span class="line">status 输出型参数，获取子进程退出的状态码，不关心可以传为 NULL</span><br></pre></td></tr></table></figure><p>wait 是一个阻塞式函数。</p><p>wait 的调用次数必须和子进程的个数一致，少了导致僵尸进程，多了出错。</p><p>如果有多个子进程，任何一个子进程的结束都会触发 wait。</p><h3 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid"></a>waitpid</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SYNOPSIS</span><br><span class="line">       #include &lt;sys/types.h&gt;</span><br><span class="line">       #include &lt;sys/wait.h&gt;</span><br><span class="line">       pid_t waitpid(pid_t pid, int *status, int options);</span><br><span class="line">返回：</span><br><span class="line">当正常返回的时候，返回收集到的子进程的进程ID;</span><br><span class="line">如果设置了选项WNOHANG,而调用中waitpid发现没有已退出的子进程可收集,则返回0;</span><br><span class="line">如果调用中出错,则返回-1,这时errno会被设置成相应的值以指示错误;</span><br><span class="line">参数：</span><br><span class="line">pid：</span><br><span class="line">pid=-1,等待任一个子进程。与wait等效。</span><br><span class="line"><span class="meta prompt_">pid&gt;</span><span class="language-bash">0.等待其进程ID与pid相等的子进程。</span></span><br><span class="line">status：</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">具体看 man 2 waitpid</span></span><br><span class="line">WIFEXITED(status): 若为正常终止子进程返回的状态，则为真。(查看进程是否是正常退出)</span><br><span class="line">WEXITSTATUS(status): 若WIFEXITED非零，提取子进程退出码。(查看进程的退出码)</span><br><span class="line">options：</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">目前在Linux中只支持WNOHANG和WUNTRACED两个选项，这是两个常数，可以用<span class="string">&quot;|&quot;</span>运算符把它们连接起来使用</span></span><br><span class="line">WNOHANG: 若pid指定的子进程没有结束，则waitpid()函数返回0，不予以等待。若正常结束，则返回该子进程的PID。</span><br></pre></td></tr></table></figure><p>如果子进程已经退出，调用wait/waitpid时，wait/waitpid会立即返回，并且释放资源，获得子进程退出信息。</p><p>如果在任意时刻调用wait/waitpid，子进程存在且正常运行，则进程可能<strong>阻塞</strong>。</p><p>如果不存在该子进程，则立即出错返回。</p><h3 id="注意-status"><a href="#注意-status" class="headerlink" title="注意 status"></a>注意 status</h3><p>wait 和 waitpid 的参数 status 不关心可以填 NULL，但如果关心，还得注意一下。</p><p>这个status是由操作系统填充的，他并不真的、简单的当做一个 int 类型。status 的低 16 位是真正我们关心的。</p><p><img src="https://i.loli.net/2019/06/12/5d006eaa2202331296.png" alt="status"></p><h2 id="代码实践"><a href="#代码实践" class="headerlink" title="代码实践"></a>代码实践</h2><h3 id="阻塞式"><a href="#阻塞式" class="headerlink" title="阻塞式"></a>阻塞式</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;string.h&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;errno.h&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;sched.h&gt; // pid_t</span></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  pid_t ret = fork();</span><br><span class="line">  if (ret &lt; 0) &#123;</span><br><span class="line">    perror(&quot;fork&quot;);</span><br><span class="line">  &#125; else if (ret == 0) &#123;</span><br><span class="line">    sleep(20);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    int status;</span><br><span class="line">    int t = wait(&amp;status);</span><br><span class="line">    if (t &gt; 0 &amp;&amp; (status &amp; 0x7f) == 0) &#123; // 正常退出</span><br><span class="line">      printf(&quot;child exit code : %d\n&quot;, (status&gt;&gt;8)&amp;0xff);</span><br><span class="line">    &#125; else if (t &gt; 0) &#123;</span><br><span class="line">      printf(&quot;sig code : %d\n&quot;, status &amp; 0x7f);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><p><img src="https://i.loli.net/2019/06/12/5d00b9ae3570495720.png" alt="阻塞式测试"></p><h3 id="非阻塞轮询"><a href="#非阻塞轮询" class="headerlink" title="非阻塞轮询"></a>非阻塞轮询</h3><hr><p>参考：<br><a href="https://blog.csdn.net/zhangxiao93/article/details/72859312">https://blog.csdn.net/zhangxiao93/article/details/72859312</a><br><a href="https://www.cnblogs.com/LUO77/p/5804436.html">https://www.cnblogs.com/LUO77/p/5804436.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oh,Vim</title>
      <link href="/2019/06/12/Oh-Vim/"/>
      <url>/2019/06/12/Oh-Vim/</url>
      
        <content type="html"><![CDATA[<p>哦卧槽，是Vim。</p><p>这里有一些Vim操作，整理起来，方便以后查阅。</p><span id="more"></span><h2 id="跳转到声明再跳回去"><a href="#跳转到声明再跳回去" class="headerlink" title="跳转到声明再跳回去"></a>跳转到声明再跳回去</h2><p><code>ctrl + ]</code>，跳转回去<code>ctrl + o</code></p><h2 id="保存并退出"><a href="#保存并退出" class="headerlink" title="保存并退出"></a>保存并退出</h2><ul><li><p><code>:x!</code></p></li><li><p><code>:wq</code></p></li></ul><h2 id="行号"><a href="#行号" class="headerlink" title="行号"></a>行号</h2><ul><li><p>显示行号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:set number</span><br><span class="line">:set nu</span><br></pre></td></tr></table></figure></li><li><p>不显示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set nu!</span><br></pre></td></tr></table></figure></li><li><p>每次打开都显示行号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.vimrc 文件，添加：set number</span><br></pre></td></tr></table></figure></li></ul><h2 id="跳跃"><a href="#跳跃" class="headerlink" title="跳跃"></a>跳跃</h2><ul><li><code>:5</code>，跳转到第 5 行。</li><li><code>G</code>，跳转到文件末尾。</li><li><code>$</code> ，跳转到本行末尾。</li><li><code>o</code>，跳到行首第一个字符。</li><li><code>^</code>，跳到行首。</li><li><code>gg</code>，回到文件第一行。</li><li><code>&#39;&#39;</code>，回到上次位置。</li></ul><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><ul><li><p><code>:%s/func/fun/g</code>，全局的替换，把func替换为fun。</p></li><li><p><code>:%s/old/new/gc</code>，会找到整个文件中的匹配项，提示是否替换。</p></li><li><p><code>R</code>，进入连续替换模式。</p></li></ul><h2 id="执行指令"><a href="#执行指令" class="headerlink" title="执行指令"></a>执行指令</h2><p><code>:!ls</code>，可以在外部执行 Linux 指令。</p><h2 id="另存为"><a href="#另存为" class="headerlink" title="另存为"></a>另存为</h2><p><code>:w a.cc</code>，将本文件另存为。</p><h2 id="高亮标记"><a href="#高亮标记" class="headerlink" title="高亮标记"></a>高亮标记</h2><p><code>#</code>，可以全局的标记这个单词。</p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><ul><li>删除一个字符，<code>x</code></li><li>删除一行，<code>dd</code></li></ul><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><ul><li><code>u</code>，undo</li></ul><h2 id="选中"><a href="#选中" class="headerlink" title="选中"></a>选中</h2><ul><li><p>按住<code>v</code>，然后移动光标</p></li><li><p><code>][</code>，选中一段，大括号内的一段，或者整个函数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">函数体跳转： </span><br><span class="line">[[</span><br><span class="line">]]</span><br><span class="line">[]</span><br><span class="line">][</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h2><ul><li><p>复制 yank</p><p>选中，然后按<code>y</code></p></li><li><p>粘贴 paste</p><p>按<code>p</code></p></li></ul><p>注意：使用<code>x</code>或者<code>dd</code>后，也可以进行粘贴。</p><h2 id="进入插入模式"><a href="#进入插入模式" class="headerlink" title="进入插入模式"></a>进入插入模式</h2><ul><li><code>shift + a</code>或<code>A</code>，调到本行末尾并进入插入模式。</li><li><code>shift + i</code>或<code>I</code>，调到本行行首并进入插入模式。</li><li><code>i</code>，光标当前位置前进入插入模式。</li><li><code>a</code>，光标位置后进入插入模式。</li><li><code>o</code>，创建新的一行（在光标的下一行），并进入插入模式。</li><li><code>shift + O</code>或<code>O</code>，创建新的一行(在光标的上面一行)，并进入插入模式。</li></ul><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><ul><li><code>/Hello</code>，查找<strong>Hello</strong>。</li><li><code>n</code>，下一个。</li><li><code>N</code>或<code>shift n</code>，上一个。</li></ul><h2 id="分割模式"><a href="#分割模式" class="headerlink" title="分割模式"></a>分割模式</h2><ul><li><code>:split HelloVim.cc</code>，行。</li><li><code>:vsplit HelloVim.cc</code>，列。</li><li><code>ctrl + ww</code>，切换。</li></ul><h2 id="批量注释"><a href="#批量注释" class="headerlink" title="批量注释"></a>批量注释</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注释</span></span><br><span class="line">首先光标放在行首</span><br><span class="line">ctrl + v 进入视图模式</span><br><span class="line">向下移动光标</span><br><span class="line">shift + I 进入插入模式</span><br><span class="line">输入 //</span><br><span class="line">按 ESC 保存即可</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">取消注释</span></span><br><span class="line">ctrl + v</span><br><span class="line">选中注释 //</span><br><span class="line">移动光标</span><br><span class="line">按 x</span><br><span class="line">esc</span><br><span class="line">保存即可</span><br></pre></td></tr></table></figure><hr><blockquote><p>更多学习资料：</p><ul><li><a href="https://linux.cn/article-10589-1.html">Vim 可视化模式入门</a></li><li><a href="https://linux.cn/article-10752-1.html">Vim 入门：基础</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sftp常用命令</title>
      <link href="/2019/06/11/sftp%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/06/11/sftp%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>ftp、sftp命令。感觉这个有些慢，还是filezilla啥的好用，不过还是记下来吧，万一需要用呢，✧(≖ ◡ ≖✿)嘿嘿。</p><span id="more"></span><blockquote><p>sftp是Secure FileTransferProtocol的缩写，安全文件传送协议。可以为传输文件提供一种安全的加密方法。sftp与 ftp有着几乎一样的语法和功能。SFTP为 SSH的一部分，是一种传输档案至Blogger伺服器的安全方式。其实在SSH软件包中，已经包含了一个叫作SFTP(Secure File TransferProtocol)的安全文件传输子系统，SFTP本身没有单独的守护进程，它必须使用sshd守护进程（端口号默认是22）来完成相应的连接操作，所以从某种意义上来说，SFTP并不像一个服务器程序，而更像是一个客户端程序。SFTP同样是使用加密传输认证信息和传输的数据，所以，使用SFTP是非常安全的。但是，由于这种传输方式使用了加密/解密技术，所以传输效率比普通的FTP要低得多，如果您对网络安全性要求更高时，可以使用SFTP代替FTP。</p></blockquote><ol><li><p>连接服务器：<code>sftp user@ip</code></p></li><li><p>帮助文档：<code>help</code></p></li><li><p>查看当前路径：<code>pwd查看服务器目录</code> <code>lpwd查看本地目录</code></p></li><li><p>列出当前文件夹下内容：<code>ls查看服务器上当前文件夹内容</code> <code>lls查看本地当前文件夹内容</code></p></li><li><p>下载文件：<code>get b.txt</code></p></li><li><p>上传文件夹：<code>put -r Blog/.</code> 同样的下载文件夹也是加<code>-r</code></p><p><img src="https://i.loli.net/2019/06/11/5cff5d9be04d422232.png" alt="刷刷刷"></p></li><li><p>执行命令：<code>!command 如：!rm a.txt</code> 相当于在本机执行删除操作</p><p>(刚开始的时候给搞反了，请不要rm -rf，我亏了。。。。)</p></li><li><p>退出：<code>quit / bye / exit</code></p></li></ol><hr><blockquote><p>Linux中ftp的常用命令：<a href="https://www.cnblogs.com/feiquan/p/9236768.html">https://www.cnblogs.com/feiquan/p/9236768.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> sftp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程的优先级</title>
      <link href="/2019/06/11/%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/"/>
      <url>/2019/06/11/%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<p>prprpr~~~ nice boy~ 笔记不是谷歌的pr权重~不是SEO，是Linux进程的优先级。</p><p>抢占式调度，谁先抢上谁先被”宠幸”。优先级”priority”。</p><span id="more"></span><p><strong>UID：</strong>代表执行者的身份<br><strong>PID：</strong>进程的pid(我叫啥)<br><strong>PPID：</strong>父进程的pid(我爸叫啥)<br><strong>PRI：</strong>进程优先级<br><strong>NI：</strong>nice值，优先级的修正值</p><p><img src="https://i.loli.net/2019/06/11/5cff31869391391528.png" alt="ps -l"></p><p>在 Linux 系统中，所有活跃进程都有一个优先级以及 nice 值。有比点优先级进程有更高优先级的进程一般会获得更多的 CPU 时间。有 root 权限的用户可以修改进程的优先级。(你想让谁先被宠幸呢)</p><h2 id="PRI"><a href="#PRI" class="headerlink" title="PRI"></a>PRI</h2><p>PRI 越小优先级越高，但这并不意味着它就最先被 CPU 宠幸，宠幸你还得听太监(NI)在皇上耳边说几句。</p><p>最终的决定是<code>PRI+NI</code>。</p><h2 id="NI"><a href="#NI" class="headerlink" title="NI"></a>NI</h2><p>取值范围是-20至19，一共40个级别。这个值越小，表示进程”优先级”越高，而值越大“优先级”越低。优先级设置方式是nice和renice命令。nice值虽然不是priority，但是它确实可以影响进程的优先级。</p><h3 id="nice"><a href="#nice" class="headerlink" title="nice"></a><code>nice</code></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nice -n 10 bash</span><br></pre></td></tr></table></figure><p>默认情况下，进程的优先级应该是从父进程继承来的，这个值一般是0。可以通过nice命令直接查看到当前shell的nice值。我的这个是从zsh shell打开的，exit出去看看zsh 的nice值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[parallels@centos-7 vimExercise]$ nice</span><br><span class="line">0</span><br><span class="line">[parallels@centos-7 vimExercise]$ exit</span><br><span class="line">exit</span><br><span class="line">➜  ~ nice</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="renice"><a href="#renice" class="headerlink" title="renice"></a><code>renice</code></h3><p>使用renice命令可以对一个正在运行的进程进行nice值的调整。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">renice +8  PID</span><br><span class="line">renice +8  PID</span><br></pre></td></tr></table></figure><hr><blockquote><p><a href="https://linux.cn/article-7325-1.html">深入 Linux 的进程优先级</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程的地址空间</title>
      <link href="/2019/06/11/%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/"/>
      <url>/2019/06/11/%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<p>fork 后，父子进程的在内存中是怎样的？测试环境centos7 x64</p><span id="more"></span><p>写一个测试程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> g_ch = <span class="string">&#x27;G&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">pid_t</span> ret = fork();</span><br><span class="line">  <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// child process</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child pid=%d, g_ch=%c, &amp;g_ch=%p\n&quot;</span>, getpid(), g_ch, &amp;g_ch);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// father process</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;father pid=%d, g_ch=%c, &amp;g_ch=%p\n&quot;</span>, getpid(), g_ch, &amp;g_ch);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">    perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[parallels@centos-7 vimExercise]$ ./forkAddressTest </span><br><span class="line">father pid=6431, g_ch=G, &amp;g_ch=0x601054</span><br><span class="line">child pid=6432, g_ch=G, &amp;g_ch=0x601054</span><br><span class="line">[parallels@centos-7 vimExercise]$ </span><br></pre></td></tr></table></figure><p>一毛一样，子进程把父进程fork了一份，就像从别人的GitHub仓库fork 下来一份。再试试修改下这个子进程中的变量……</p><p><img src="https://i.loli.net/2019/06/11/5cff158d5b43350984.png" alt="一毛一样"></p><p>修改后的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// child process</span></span><br><span class="line">  g_ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;child pid=%d, g_ch=%c, &amp;g_ch=%p\n&quot;</span>, getpid(), g_ch, &amp;g_ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[parallels@centos-7 vimExercise]$ ./forkAddressTest </span><br><span class="line">father pid=9357, g_ch=G, &amp;g_ch=0x601054</span><br><span class="line">child pid=9358, g_ch=A, &amp;g_ch=0x601054</span><br></pre></td></tr></table></figure><p>地址是一样的，但是变量内容不一样……诶？这个盒子里可以放下这两个东西吗？我觉得不行，这一个东西就把盒子占满了，另一个再放进去要么覆盖，要么就放不进去(除非可以压缩，手动滑稽)。</p><p>查阅资料：这个是映射出去的虚拟地址不是物理地址。两个不是同一个盒子，盒子里装的也是不同的东西。在C/C++ 程序中输出的地址全部都是虚拟地址，物理地址由OS统一管理。OS负责把虚拟地址转换成虚拟地址。</p><p>每次都需要物理地址和虚拟地址之间的转换，靠软件来实现转换逻辑效率是比较低的，在《计算机组成原理》和《微型计算机原理》这两门课中老师反复提到了地址之间的转换，是通过一种叫MMU的硬件设备负责地址之间的转换，硬件实现效率高。</p><blockquote><p>内存管理模块负责控制进程如何访问物理内存资源。通过硬件内存管理系统（MMU）管理进程虚拟内存和机器物理内存之间的映射。每一个进程都有自己独立的虚拟内存空间，所以两个进程可能有相同的虚拟地址，但是它们实际上在不同的物理内存区域运行。MMU 提供内存保护，让两个进程的物理内存空间不互相干扰。内存管理模块还支持交换——将暂时不用的内存页换出到磁盘上的交换分区，这种技术让进程的虚拟地址空间大于物理内存的大小。虚拟地址空间的大小由机器字长决定。——<a href="https://linux.cn/article-6711-1.html">Linux 概念架构的理解</a></p><p>在一个多任务操作系统中的每个进程都运行在它自己的内存“沙箱”中。这个沙箱是一个虚拟地址空间virtual address space，在 32 位的模式中它总共有 4GB 的内存地址块。这些虚拟地址是通过内核页表page table映射到物理地址的，并且这些虚拟地址是由操作系统内核来维护，进而被进程所消费的。每个进程都有它自己的一组页表，但是这里有点玄机。一旦虚拟地址被启用，这些虚拟地址将被应用到这台电脑上的<em>所有软件</em>，<em>包括内核本身</em>。因此，一部分虚拟地址空间必须保留给内核使用。——<a href="https://manybutfinite.com/post/anatomy-of-a-program-in-memory/">Anatomy of a Program in Memory</a><br><img src="https://i.loli.net/2019/06/11/5cff1b6537ac939277.png" alt="Kernel/User Memory Split"></p></blockquote><p>画个图我就理解了，自己也画个滑稽。</p><p><img src="https://i.loli.net/2019/06/11/5cff219e0601c90086.png" alt="自己画的滑稽"></p><hr><p>几个小时后的补充：这里再附上另外一张图，上图中稍微有一些错误，我搞清楚再总结一下。</p><p><img src="https://i.loli.net/2019/06/11/5cff78c117a0258488.png"></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我终于可以连上校园网啦</title>
      <link href="/2019/06/10/%E6%88%91%E7%BB%88%E4%BA%8E%E5%8F%AF%E4%BB%A5%E8%BF%9E%E4%B8%8A%E6%A0%A1%E5%9B%AD%E7%BD%91%E5%95%A6/"/>
      <url>/2019/06/10/%E6%88%91%E7%BB%88%E4%BA%8E%E5%8F%AF%E4%BB%A5%E8%BF%9E%E4%B8%8A%E6%A0%A1%E5%9B%AD%E7%BD%91%E5%95%A6/</url>
      
        <content type="html"><![CDATA[<p>刚刚去学长宿舍拷贝了几个软件又学到了哈哈哈。<a href="http://47.106.200.88/">@学长</a></p><p>拷贝来的这个软件可以查看电脑的详细状态，还可以调整风扇转速~虽然我已经为散热买了涡轮增压散热器……</p><p>我连不上校园网，学长传给我一个py文件，改一改运行下就好了。</p><p>✧(≖ ◡ ≖✿)嘿嘿，后面有这个py的代码。</p><p><img src="https://i.loli.net/2019/06/10/5cfe6df5bb1c249086.png"></p><span id="more"></span><p><img src="https://i.loli.net/2019/06/10/5cfe6f716b11989328.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=UTF-8</span></span><br><span class="line"><span class="comment">#test version </span></span><br><span class="line"><span class="comment">#Licensed under the GPL</span></span><br><span class="line"><span class="comment">#thx all authors before</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket, struct, time,sys,urllib2,random,re,uuid</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line"></span><br><span class="line"><span class="comment">#config</span></span><br><span class="line">server = <span class="string">&#x27;192.168.254.35&#x27;</span> <span class="comment"># 学校服务器</span></span><br><span class="line">username=<span class="string">&#x27;41709310119&#x27;</span> <span class="comment"># 学号</span></span><br><span class="line">password=<span class="string">&#x27;00000&#x27;</span> <span class="comment"># 密码</span></span><br><span class="line">CONTROLCHECKSTATUS = <span class="string">&#x27;\x20&#x27;</span></span><br><span class="line">ADAPTERNUM = <span class="string">&#x27;\x03&#x27;</span></span><br><span class="line">host_ip = <span class="string">&#x27;10.2.20.152&#x27;</span></span><br><span class="line">IPDOG = <span class="string">&#x27;\x01&#x27;</span></span><br><span class="line">host_name = <span class="string">&#x27;DRCOMFUCKER&#x27;</span></span><br><span class="line">PRIMARY_DNS = <span class="string">&#x27;218.30.19.40&#x27;</span></span><br><span class="line">dhcp_server = <span class="string">&#x27;202.200.200.1&#x27;</span></span><br><span class="line">AUTH_VERSION = <span class="string">&#x27;\x22\x00&#x27;</span></span><br><span class="line">mac = <span class="number">0x20689df3d066</span></span><br><span class="line">host_os = <span class="string">&#x27;WINDIAOS&#x27;</span></span><br><span class="line">KEEP_ALIVE_VERSION = <span class="string">&#x27;\xdc\x02&#x27;</span></span><br><span class="line"><span class="comment">#config_end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">try_socket</span>():</span><br><span class="line"><span class="comment">#sometimes cannot get the port</span></span><br><span class="line"><span class="keyword">global</span> s,salt</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">s.bind((<span class="string">&quot;0.0.0.0&quot;</span>, <span class="number">61440</span>))</span><br><span class="line">s.settimeout(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">i=<span class="number">0</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;&gt;Error!&lt;&quot;</span></span><br><span class="line"><span class="built_in">print</span><span class="string">&quot;&gt;Cannot get the right port,this programm  may cannot auth right&lt;&quot;</span></span><br><span class="line"><span class="built_in">print</span><span class="string">&quot;&gt;Wait for 5 seconds&lt;&quot;</span></span><br><span class="line">time.sleep(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">SALT= <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UNLIMITED_RETRY = <span class="literal">True</span></span><br><span class="line">EXCEPTION = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">version</span>():</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;=====================================================================&quot;</span> </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;DrCOM Auth Router for 3.5+&quot;</span> </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Version Apr.6.d&quot;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;with keep-alive1&amp;keep-alive2&quot;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;=====================================================================&quot;</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">challenge</span>(<span class="params">svr,ran</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">      t = struct.pack(<span class="string">&quot;&lt;H&quot;</span>, <span class="built_in">int</span>(ran)%(<span class="number">0xFFFF</span>))</span><br><span class="line">      s.sendto(<span class="string">&quot;\x01\x02&quot;</span>+t+<span class="string">&quot;\x09&quot;</span>+<span class="string">&quot;\x00&quot;</span>*<span class="number">15</span>, (svr, <span class="number">61440</span>))</span><br><span class="line">      <span class="keyword">try</span>:</span><br><span class="line">        data, address = s.recvfrom(<span class="number">1024</span>)</span><br><span class="line">      <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[challenge] timeout, retrying...&#x27;</span>)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">      <span class="keyword">if</span> address == (svr, <span class="number">61440</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> data[<span class="number">0</span>] != <span class="string">&#x27;\x02&#x27;</span>:</span><br><span class="line">      <span class="keyword">raise</span> ChallengeException</span><br><span class="line">    <span class="keyword">return</span> data[<span class="number">4</span>:<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">md5sum</span>(<span class="params">s</span>):</span><br><span class="line">    m = md5()</span><br><span class="line">    m.update(s)</span><br><span class="line">    <span class="keyword">return</span> m.digest()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump</span>(<span class="params">n</span>):</span><br><span class="line">    s = <span class="string">&#x27;%x&#x27;</span> % n</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) &amp; <span class="number">1</span>:</span><br><span class="line">        s = <span class="string">&#x27;0&#x27;</span> + s</span><br><span class="line">    <span class="keyword">return</span> s.decode(<span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ror</span>(<span class="params">md5, pwd</span>):</span><br><span class="line">    ret = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(pwd)):</span><br><span class="line">        x = <span class="built_in">ord</span>(md5[i]) ^ <span class="built_in">ord</span>(pwd[i])</span><br><span class="line">        ret += <span class="built_in">chr</span>(((x&lt;&lt;<span class="number">3</span>)&amp;<span class="number">0xFF</span>) + (x&gt;&gt;<span class="number">5</span>))</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">keep_alive_package_builder</span>(<span class="params">number,random,tail,<span class="built_in">type</span>=<span class="number">1</span>,first=<span class="literal">False</span></span>):</span><br><span class="line">    data = <span class="string">&#x27;\x07&#x27;</span>+ <span class="built_in">chr</span>(number) + <span class="string">&#x27;\x28\x00\x0b&#x27;</span> + <span class="built_in">chr</span>(<span class="built_in">type</span>)</span><br><span class="line">    <span class="keyword">if</span> first :</span><br><span class="line">      data += <span class="string">&#x27;\x0f\x27&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      data += KEEP_ALIVE_VERSION</span><br><span class="line">    data += <span class="string">&#x27;\x2f\x12&#x27;</span> + <span class="string">&#x27;\x00&#x27;</span> * <span class="number">6</span></span><br><span class="line">    data += tail</span><br><span class="line">    data += <span class="string">&#x27;\x00&#x27;</span> * <span class="number">4</span></span><br><span class="line">    <span class="comment">#data += struct.pack(&quot;!H&quot;,0xdc02)</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span> == <span class="number">3</span>:</span><br><span class="line">      foo = <span class="string">&#x27;&#x27;</span>.join([<span class="built_in">chr</span>(<span class="built_in">int</span>(i)) <span class="keyword">for</span> i <span class="keyword">in</span> host_ip.split(<span class="string">&#x27;.&#x27;</span>)]) <span class="comment"># host_ip</span></span><br><span class="line"><span class="comment">#use double keep in main to keep online .Ice</span></span><br><span class="line">      crc = <span class="string">&#x27;\x00&#x27;</span> * <span class="number">4</span></span><br><span class="line">      <span class="comment">#data += struct.pack(&quot;!I&quot;,crc) + foo + &#x27;\x00&#x27; * 8</span></span><br><span class="line">      data += crc + foo + <span class="string">&#x27;\x00&#x27;</span> * <span class="number">8</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="comment">#packet type = 1</span></span><br><span class="line">      data += <span class="string">&#x27;\x00&#x27;</span> * <span class="number">16</span></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">packet_CRC</span>(<span class="params">s</span>):</span><br><span class="line">    ret = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> re.findall(<span class="string">&#x27;..&#x27;</span>, s):</span><br><span class="line">        ret ^= struct.unpack(<span class="string">&#x27;&gt;h&#x27;</span>, i)[<span class="number">0</span>]</span><br><span class="line">        ret &amp;= <span class="number">0xFFFF</span></span><br><span class="line">    ret = ret * <span class="number">0x2c7</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">keep_alive2</span>(<span class="params">*args</span>):</span><br><span class="line">    tail = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    packet = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    svr = server</span><br><span class="line">    ran = random.randint(<span class="number">0</span>,<span class="number">0xFFFF</span>)</span><br><span class="line">    ran += random.randint(<span class="number">1</span>,<span class="number">10</span>)   </span><br><span class="line">    </span><br><span class="line">    packet = keep_alive_package_builder(<span class="number">0</span>,dump(ran),<span class="string">&#x27;\x00&#x27;</span>*<span class="number">4</span>,<span class="number">1</span>,<span class="literal">True</span>)</span><br><span class="line">    <span class="comment">#packet = keep_alive_package_builder(0,dump(ran),dump(ran)+&#x27;\x22\x06&#x27;,1,True)</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;[keep-alive2] send1&#x27;</span><span class="comment">#packet.encode(&#x27;hex&#x27;)</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        s.sendto(packet, (svr, <span class="number">61440</span>))</span><br><span class="line">        data, address = s.recvfrom(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> data.startswith(<span class="string">&#x27;\x07&#x27;</span>):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">            <span class="comment">#print &#x27;[keep-alive2] recv/unexpected&#x27;,data.encode(&#x27;hex&#x27;)</span></span><br><span class="line">    <span class="comment">#print &#x27;[keep-alive2] recv1&#x27;,data.encode(&#x27;hex&#x27;)</span></span><br><span class="line">    </span><br><span class="line">    ran += random.randint(<span class="number">1</span>,<span class="number">10</span>)   </span><br><span class="line">    packet = keep_alive_package_builder(<span class="number">1</span>,dump(ran),<span class="string">&#x27;\x00&#x27;</span>*<span class="number">4</span>,<span class="number">1</span>,<span class="literal">False</span>)</span><br><span class="line">    <span class="comment">#print &#x27;[keep-alive2] send2&#x27;,packet.encode(&#x27;hex&#x27;)</span></span><br><span class="line">    s.sendto(packet, (svr, <span class="number">61440</span>))</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data, address = s.recvfrom(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> data[<span class="number">0</span>] == <span class="string">&#x27;\x07&#x27;</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="comment">#print &#x27;[keep-alive2] recv2&#x27;,data.encode(&#x27;hex&#x27;)</span></span><br><span class="line">    tail = data[<span class="number">16</span>:<span class="number">20</span>]</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    ran += random.randint(<span class="number">1</span>,<span class="number">10</span>)   </span><br><span class="line">    packet = keep_alive_package_builder(<span class="number">2</span>,dump(ran),tail,<span class="number">3</span>,<span class="literal">False</span>)</span><br><span class="line">    <span class="comment">#print &#x27;[keep-alive2] send3&#x27;,packet.encode(&#x27;hex&#x27;)</span></span><br><span class="line">    s.sendto(packet, (svr, <span class="number">61440</span>))</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data, address = s.recvfrom(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> data[<span class="number">0</span>] == <span class="string">&#x27;\x07&#x27;</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="comment">#print &#x27;[keep-alive2] recv3&#x27;,data.encode(&#x27;hex&#x27;)</span></span><br><span class="line">    tail = data[<span class="number">16</span>:<span class="number">20</span>]</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;[keep-alive] keep-alive loop was in daemon.&quot;</span></span><br><span class="line">    i = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">      <span class="keyword">try</span>:</span><br><span class="line">keep_alive1(SALT,package_tail,password,server)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;[keep-alive2] send&#x27;</span></span><br><span class="line">ran += random.randint(<span class="number">1</span>,<span class="number">10</span>)   </span><br><span class="line">packet = keep_alive_package_builder(i,dump(ran),tail,<span class="number">1</span>,<span class="literal">False</span>)</span><br><span class="line"><span class="comment">#print(&#x27;DE<span class="doctag">BUG:</span> keep_alive2,packet 4\n&#x27;,packet.encode(&#x27;hex&#x27;))</span></span><br><span class="line"><span class="comment">#print &#x27;[keep_alive2] send&#x27;,str(i),packet.encode(&#x27;hex&#x27;)</span></span><br><span class="line">s.sendto(packet, (svr, <span class="number">61440</span>))</span><br><span class="line">data, address = s.recvfrom(<span class="number">1024</span>)</span><br><span class="line"><span class="comment">#print &#x27;[keep_alive2] recv&#x27;,data.encode(&#x27;hex&#x27;)</span></span><br><span class="line">tail = data[<span class="number">16</span>:<span class="number">20</span>]</span><br><span class="line"><span class="comment">#print(&#x27;DE<span class="doctag">BUG:</span> keep_alive2,packet 4 return\n&#x27;,data.encode(&#x27;hex&#x27;))</span></span><br><span class="line">        </span><br><span class="line">ran += random.randint(<span class="number">1</span>,<span class="number">10</span>)   </span><br><span class="line">packet = keep_alive_package_builder(i+<span class="number">1</span>,dump(ran),tail,<span class="number">3</span>,<span class="literal">False</span>)</span><br><span class="line"><span class="comment">#print(&#x27;DE<span class="doctag">BUG:</span> keep_alive2,packet 5\n&#x27;,packet.encode(&#x27;hex&#x27;))</span></span><br><span class="line">s.sendto(packet, (svr, <span class="number">61440</span>))</span><br><span class="line"><span class="comment">#print(&#x27;[keep_alive2] send&#x27;,str(i+1),packet.encode(&#x27;hex&#x27;))</span></span><br><span class="line">data, address = s.recvfrom(<span class="number">1024</span>)</span><br><span class="line"><span class="comment">#print(&#x27;[keep_alive2] recv&#x27;,data.encode(&#x27;hex&#x27;))</span></span><br><span class="line">tail = data[<span class="number">16</span>:<span class="number">20</span>]</span><br><span class="line"><span class="comment">#print(&#x27;DE<span class="doctag">BUG:</span> keep_alive2,packet 5 return\n&#x27;,data.encode(&#x27;hex&#x27;))</span></span><br><span class="line">i = (i+<span class="number">2</span>) % <span class="number">0xFF</span></span><br><span class="line">time.sleep(<span class="number">20</span>)</span><br><span class="line">      <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">checksum</span>(<span class="params">s</span>):</span><br><span class="line">    ret = <span class="number">1234</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> re.findall(<span class="string">&#x27;....&#x27;</span>, s):</span><br><span class="line">        ret ^= <span class="built_in">int</span>(i[::-<span class="number">1</span>].encode(<span class="string">&#x27;hex&#x27;</span>), <span class="number">16</span>)</span><br><span class="line">    ret = (<span class="number">1968</span> * ret) &amp; <span class="number">0xffffffff</span></span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">&#x27;&lt;I&#x27;</span>, ret)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mkpkt</span>(<span class="params">salt, usr, pwd, mac</span>):</span><br><span class="line">    data = <span class="string">&#x27;\x03\x01\x00&#x27;</span>+<span class="built_in">chr</span>(<span class="built_in">len</span>(usr)+<span class="number">20</span>)</span><br><span class="line">    data += md5sum(<span class="string">&#x27;\x03\x01&#x27;</span>+salt+pwd)</span><br><span class="line">    data += usr.ljust(<span class="number">36</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    data += CONTROLCHECKSTATUS</span><br><span class="line">    data += ADAPTERNUM</span><br><span class="line">    data += dump(<span class="built_in">int</span>(data[<span class="number">4</span>:<span class="number">10</span>].encode(<span class="string">&#x27;hex&#x27;</span>),<span class="number">16</span>)^mac).rjust(<span class="number">6</span>,<span class="string">&#x27;\x00&#x27;</span>) <span class="comment">#mac xor md51</span></span><br><span class="line">    data += md5sum(<span class="string">&quot;\x01&quot;</span> + pwd + salt + <span class="string">&#x27;\x00&#x27;</span>*<span class="number">4</span>) <span class="comment">#md52</span></span><br><span class="line">    data += <span class="string">&#x27;\x01&#x27;</span> <span class="comment">#NIC count</span></span><br><span class="line">    data += hexip <span class="comment">#your ip address1 </span></span><br><span class="line">    data += <span class="string">&#x27;\00&#x27;</span>*<span class="number">4</span> <span class="comment">#your ipaddress 2</span></span><br><span class="line">    data += <span class="string">&#x27;\00&#x27;</span>*<span class="number">4</span> <span class="comment">#your ipaddress 3</span></span><br><span class="line">    data += <span class="string">&#x27;\00&#x27;</span>*<span class="number">4</span> <span class="comment">#your ipaddress 4</span></span><br><span class="line">    data += md5sum(data + <span class="string">&#x27;\x14\x00\x07\x0b&#x27;</span>)[:<span class="number">8</span>] <span class="comment">#md53</span></span><br><span class="line">    data +=IPDOG</span><br><span class="line">    data += <span class="string">&#x27;\x00&#x27;</span>*<span class="number">4</span> <span class="comment">#delimeter</span></span><br><span class="line">    data += host_name.ljust(<span class="number">32</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    data += <span class="string">&#x27;\x72\x72\x72\x72&#x27;</span> <span class="comment">#primary dns: 114.114.114.114</span></span><br><span class="line">    data += <span class="string">&#x27;\x0a\xff\x00\xc5&#x27;</span> <span class="comment">#DHCP server</span></span><br><span class="line">    data += <span class="string">&#x27;\x08\x08\x08\x08&#x27;</span> <span class="comment">#secondary dns:8.8.8.8</span></span><br><span class="line">    data += <span class="string">&#x27;\x00&#x27;</span> * <span class="number">8</span> <span class="comment">#delimeter</span></span><br><span class="line">    data += <span class="string">&#x27;\x94\x00\x00\x00&#x27;</span> <span class="comment"># unknow</span></span><br><span class="line">    data += <span class="string">&#x27;\x05\x00\x00\x00&#x27;</span> <span class="comment">#os major</span></span><br><span class="line">    data += <span class="string">&#x27;\x01\x00\x00\x00&#x27;</span> <span class="comment"># os minor</span></span><br><span class="line">    data += <span class="string">&#x27;\x28\x0a\x00\x00&#x27;</span> <span class="comment"># OS build</span></span><br><span class="line">    data += <span class="string">&#x27;\x02\x00\x00\x00&#x27;</span> <span class="comment">#os unknown</span></span><br><span class="line">    data += host_os.ljust(<span class="number">32</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    data += <span class="string">&#x27;\x00&#x27;</span> * <span class="number">96</span></span><br><span class="line">    <span class="comment">#data += &#x27;\x01&#x27; + host_os.ljust(128, &#x27;\x00&#x27;)</span></span><br><span class="line">    <span class="comment">#data += &#x27;\x0a\x00\x00&#x27;+chr(len(pwd)) # \0x0a represents version of client, algorithm: DRCOM_VER + 100</span></span><br><span class="line">    <span class="comment">#data += ror(md5sum(&#x27;\x03\x01&#x27;+salt+pwd), pwd)</span></span><br><span class="line">    data += AUTH_VERSION</span><br><span class="line">    data += <span class="string">&#x27;\x02\x0c&#x27;</span></span><br><span class="line">    data += checksum(data+<span class="string">&#x27;\x01\x26\x07\x11\x00\x00&#x27;</span>+dump(mac))</span><br><span class="line">    data += <span class="string">&#x27;\x00\x00&#x27;</span> <span class="comment">#delimeter</span></span><br><span class="line">    data += dump(mac)</span><br><span class="line">    data += <span class="string">&#x27;\x00&#x27;</span> <span class="comment"># auto logout / default: False</span></span><br><span class="line">    data += <span class="string">&#x27;\x00&#x27;</span> <span class="comment"># broadcast mode / default : False</span></span><br><span class="line">    data += <span class="string">&#x27;\xc2\x66&#x27;</span> <span class="comment">#unknown</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">usr, pwd, svr</span>):</span><br><span class="line">    <span class="keyword">global</span> SALT</span><br><span class="line"> </span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        salt = challenge(svr,time.time()+random.randint(<span class="number">0xF</span>,<span class="number">0xFF</span>))</span><br><span class="line">        SALT = salt</span><br><span class="line">        packet = mkpkt(salt, usr, pwd, mac)</span><br><span class="line">        <span class="comment">#print(&#x27;[login] send&#x27;,packet.encode(&#x27;hex&#x27;))</span></span><br><span class="line">        s.sendto(packet, (svr, <span class="number">61440</span>))</span><br><span class="line">        data, address = s.recvfrom(<span class="number">1024</span>)</span><br><span class="line">        <span class="comment">#print(&#x27;[login] recv&#x27;,data.encode(&#x27;hex&#x27;))</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[login] packet sent.&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> address == (svr, <span class="number">61440</span>):</span><br><span class="line">            <span class="keyword">if</span> data[<span class="number">0</span>] == <span class="string">&#x27;\x04&#x27;</span>:</span><br><span class="line">              <span class="built_in">print</span>(<span class="string">&#x27;[login] login in&#x27;</span>)</span><br><span class="line">              <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">              <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> i &gt;= <span class="number">5</span> <span class="keyword">and</span> UNLIMITED_RETRY == <span class="literal">False</span> :</span><br><span class="line">              <span class="built_in">print</span>(<span class="string">&#x27;[login] exception occured.&#x27;</span>)</span><br><span class="line">              sys.exit(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">              <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;[login] login Success&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> data[<span class="number">23</span>:<span class="number">39</span>]</span><br><span class="line">    <span class="comment">#return data[-22:-6]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">keep_alive1</span>(<span class="params">salt,tail,pwd,svr</span>):</span><br><span class="line">    foo = struct.pack(<span class="string">&#x27;!H&#x27;</span>,<span class="built_in">int</span>(time.time())%<span class="number">0xFFFF</span>)</span><br><span class="line">    data = <span class="string">&#x27;\xff&#x27;</span> + md5sum(<span class="string">&#x27;\x03\x01&#x27;</span>+salt+pwd) + <span class="string">&#x27;\x00\x00\x00&#x27;</span></span><br><span class="line">    data += tail</span><br><span class="line">    data += foo + <span class="string">&#x27;\x00\x00\x00\x00&#x27;</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;[keep_alive1] send&#x27;</span><span class="comment">#data.encode(&#x27;hex&#x27;))</span></span><br><span class="line"></span><br><span class="line">    s.sendto(data, (svr, <span class="number">61440</span>))</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data, address = s.recvfrom(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> data[<span class="number">0</span>] == <span class="string">&#x27;\x07&#x27;</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&#x27;[keep-alive1]recv/not expected&#x27;</span><span class="comment">#data.encode(&#x27;hex&#x27;)</span></span><br><span class="line">    <span class="comment">#print(&#x27;[keep-alive1] recv&#x27;,data.encode(&#x27;hex&#x27;))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">empty_socket_buffer</span>():</span><br><span class="line"><span class="comment">#empty buffer</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;starting to empty socket buffer&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            data, address = s.recvfrom(<span class="number">1024</span>)</span><br><span class="line">            <span class="comment">#print &#x27;recived sth unexcepted&#x27;,data.encode(&#x27;hex&#x27;)</span></span><br><span class="line">            <span class="keyword">if</span> s == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="comment"># get exception means it has done.</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;exception in empty_socket_buffer&#x27;</span>)</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;emptyed&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_online</span>():</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">check_online = urllib2.urlopen(<span class="string">&#x27;http://www.baidu.com&#x27;</span>)</span><br><span class="line">foo=check_online.read()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Network line Err,check the line...Hit the return&quot;</span></span><br><span class="line">raw_input()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;10.1.1.10&#x27;</span> <span class="keyword">in</span> foo:</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Not Online,try to auth&quot;</span></span><br><span class="line">raw_input()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Already online,Hit the return&quot;</span></span><br><span class="line">raw_input()</span><br><span class="line">sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line"><span class="keyword">global</span> hexip,host_ip</span><br><span class="line"><span class="comment">#host_ip=socket.gethostbyname(socket.gethostname())</span></span><br><span class="line">hexip=socket.inet_aton(host_ip)</span><br><span class="line">dhcp_server = <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line"><span class="comment">#mac = 0xE0DB55BAE012 </span></span><br><span class="line"><span class="comment">#it is a mac in programme and it may crush with other users so I use randMAC to avoid it</span></span><br><span class="line">loginpart()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loginpart</span>():</span><br><span class="line"><span class="keyword">global</span> package_tail</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">package_tail = login(username, password, server)</span><br><span class="line"><span class="keyword">except</span> loginException:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="comment">#print(&#x27;package_tail&#x27;,package_tail.encode(&#x27;hex&#x27;))</span></span><br><span class="line">keeppart()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">keeppart</span>():</span><br><span class="line"><span class="comment">#empty_socket_buffer()</span></span><br><span class="line">keep_alive1(SALT,package_tail,password,server)</span><br><span class="line">keep_alive2(SALT,package_tail,password,server)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">try_socket()</span><br><span class="line">version()</span><br><span class="line"><span class="comment">#get_conf()</span></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序的地址空间</title>
      <link href="/2019/06/10/%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/"/>
      <url>/2019/06/10/%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<p>在《算法设计与分析》这门课里学了递归，但老师只是提了一嘴”递归不能太深，否则会栈溢出”。那得多深才溢出啊？为啥会溢出？得找找资料看看了。下面是我的一些笔记，程序地址空间、进程地址空间……</p><p>测试环境centos7 x64。</p><span id="more"></span><h2 id="程序地址空间"><a href="#程序地址空间" class="headerlink" title="程序地址空间"></a>程序地址空间</h2><p>根据书上、网上的资料画个图，右图来源linux.cn。</p><p><img src="https://i.loli.net/2019/06/10/5cfe3f7aa98a142592.png"></p><blockquote><p>在x86体系结构中分段机制是必选的，而分页机制则可由具体的操作系统而选择，Linux通过让段的基地址为0而巧妙的绕过了基地址。因此，对于Linux来说，虚地址和线性地址是一致的。在32位的平台上，线性地址的大小为固定的4GB。并且，由于采用了保护机制，Linux内核将这4GB分为两部分，虚地址较高的1GB（0xC0000000到0xFFFFFFFF）为共享的内核空间；而较低的3GB（0x00000000到0xBFFFFFFF）为每个进程的用户空间。由于每个进程都不能直接访问内核空间，而是通过系统调用间接进入内核，因此，所有的进程都共享内核空间。而每个进程都拥有各自的用户空间，各个进程之间不能互相访问彼此的用户空间。因此，对于每一个具体的进程而言，都拥有4GB的虚拟地址空间。——<a href="https://baike.baidu.com/item/%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/1423980?fr=aladdin">百度百科</a></p></blockquote><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>看到上图中(linux.cn的那张图)，说栈有8MB，注意是e.g，linux下使用ulimit 命令可以查看系统的很多上限值。</p><p>那就来看看啵，<code>ulimit -a</code>，列出看看。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[parallels@centos-7 vimExercise]$ ulimit -a</span><br><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 7218</span><br><span class="line">max locked memory       (kbytes, -l) 64</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 1024</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 8192 # 栈</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 4096</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br><span class="line">[parallels@centos-7 vimExercise]$ </span><br></pre></td></tr></table></figure><p>他说我现在虚拟机的stack size是8912kb，也就是8MB。那试试咯，试试就试试。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span> a[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">  (<span class="type">void</span>) a;</span><br><span class="line">  cnt++;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d MB.\n&quot;</span>, cnt);</span><br><span class="line">  func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">  func();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[parallels@centos-7 vimExercise]$ ./stackSizeTest </span><br><span class="line">1 MB.</span><br><span class="line">2 MB.</span><br><span class="line">3 MB.</span><br><span class="line">4 MB.</span><br><span class="line">5 MB.</span><br><span class="line">6 MB.</span><br><span class="line">7 MB.</span><br><span class="line">Segmentation fault (core dumped)</span><br><span class="line">[parallels@centos-7 vimExercise]$ </span><br></pre></td></tr></table></figure><p>是的，到了7MB再不能申请1MB大小的栈空间了，因为函数栈帧以及一些别的变量占去了一部分。</p><p>然后我用<code>ulimit -s 2048</code>，修改栈的限制为2048kb，试试，不出所料，1MB。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[parallels@centos-7 vimExercise]$ ./stackSizeTest </span><br><span class="line">1 MB.</span><br><span class="line">Segmentation fault (core dumped)</span><br><span class="line">[parallels@centos-7 vimExercise]$ </span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/06/10/5cfe422267f0891102.png"></p><p>哈哈，以后你再说栈溢出我就改成unlimited。</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>好吧，刚才改ulimit 发现改不回来了哈哈哈，它提示我不允许的操作。。。。额。。。。吓尿了，赶紧sudo，然后提示没有这条命令？？？？</p><p><img src="https://i.loli.net/2019/06/10/5cfe45b6a8b0231776.png"></p><p>好吧，百度ing……试了煤球用。抱着试一试的心态，先su，然后ulimit，我靠成了就。</p><p>百度的过程中学到了，这个值不能指定的太大，否则当并发运行的线程数多时，系统的内存会被众多thread耗尽。</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>大大大，很大。能申请多少取决于电脑内存，测试的时候我电脑16GB，申请10GB没啥毛病（没别的占用的情况下，一般系统有你申请他就给你了）。</p><p>那么写代码的时候是多多在栈上弄好，还是堆上？</p><blockquote><p>如果是小对象，并且需要频繁创建和销毁，在栈上更好。在栈上分配内存更加高效(修改esp寄存器)。<br>如果是大对象必须在堆上分配。<br>如果是很大的对象，又要频繁使用，那就上内存池吧。</p></blockquote><hr><blockquote><p>剖析内存中的程序之秘 <a href="https://linux.cn/article-9255-1.html?pr">https://linux.cn/article-9255-1.html?pr</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 内存分布 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>main函数的参数</title>
      <link href="/2019/06/10/main%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/"/>
      <url>/2019/06/10/main%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>大一时候学校有个学习分享会，有一个学长问了一句：”C你们应该都学完了，那你们知道main函数有多少个参数吗？那些参数有什么用？”</p><p>刚才在计组课间看linux.cn 上有一篇文章叫<a href="https://linux.cn/article-10949-1.html">《如何写好 C main 函数》</a>，让我再次想起学长所问，虽然知道main 函数是有参数的，只知道有两个，没有深究。</p><span id="more"></span><h2 id="三个参数"><a href="#三个参数" class="headerlink" title="三个参数"></a>三个参数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[], <span class="type">char</span> *env[])</span> &#123;</span><br><span class="line">  (<span class="type">void</span>)argc, (<span class="type">void</span>)argv, (<span class="type">void</span>)env;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用void 就是让我的vim 不要有讨厌的黄色高亮警告。哈哈。如果我没有第四行那句，就会有”讨厌”的警告。</p><p><img src="https://i.loli.net/2019/06/10/5cfe1520d820412428.png"></p><h2 id="argc和argv"><a href="#argc和argv" class="headerlink" title="argc和argv"></a>argc和argv</h2><p>在B站看刘意老师讲 Java 的时候，他有提到过 Java 的 main 函数的那个<code>String[] args</code>是在 Java 刚出来的时候没有 Scanner 类，所以通过这种方式来获取输入的参数。</p><p>在 C 中这两个参数就是获取命令行传入的参数的，比如在用<code>ls -al</code>的时候，后面的就作为参数传给了<code>ls</code>程序。</p><ul><li><code>argc</code>参数个数参数向量的个数</li><li><code>argv</code>参数向量字符指针数组</li></ul><p>写个程序来试试。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[], <span class="type">char</span> *env[])</span> &#123;</span><br><span class="line">  </span><br><span class="line">  (<span class="type">void</span>)env;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;argv[%d] : %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><p><img src="https://i.loli.net/2019/06/10/5cfe178de4a7269535.png"></p><p><img src="https://i.loli.net/2019/06/10/5cfe189c5864015863.png"></p><p>当然在Windows下也是同样的，下面的图片来源于CSDN博客：</p><p><img src="https://img-blog.csdn.net/20180508154304227?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODY2NDM3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p><h2 id="env"><a href="#env" class="headerlink" title="env"></a>env</h2><p>env 是用来获取环境变量的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[], <span class="type">char</span> *env[])</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// (void)env;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// int i = 0;</span></span><br><span class="line">  <span class="comment">// for (i = 0; i &lt; argc; i++) &#123;</span></span><br><span class="line">  <span class="comment">//   printf(&quot;argv[%d] : %s\n&quot;, i, argv[i]);</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  </span><br><span class="line">  (<span class="type">void</span>)argc, (<span class="type">void</span>)argv;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; env[i] != <span class="literal">NULL</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d : %s\n&quot;</span>, i, env[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://i.loli.net/2019/06/10/5cfe1a37c0d3241610.png"></p><h3 id="补充通过第三方变量获取环境变量"><a href="#补充通过第三方变量获取环境变量" class="headerlink" title="补充通过第三方变量获取环境变量"></a>补充通过第三方变量获取环境变量</h3><blockquote><p>libc中定义的全局变量environ指向环境变量表,environ没有包含在任何头文件中,所以在使用时 要用extern声明。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[], <span class="type">char</span> *env[])</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// (void)env;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// int i = 0;</span></span><br><span class="line">  <span class="comment">// for (i = 0; i &lt; argc; i++) &#123;</span></span><br><span class="line">  <span class="comment">//   printf(&quot;argv[%d] : %s\n&quot;, i, argv[i]);</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  </span><br><span class="line">  (<span class="type">void</span>)argc, (<span class="type">void</span>)argv;</span><br><span class="line">  <span class="comment">// int i = 0;</span></span><br><span class="line">  <span class="comment">// for (i = 0; env[i] != NULL; i++) &#123;</span></span><br><span class="line">  <span class="comment">//   printf(&quot;%d : %s\n&quot;, i, env[i]);</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">extern</span> <span class="type">char</span>** environ;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; environ[i] != <span class="literal">NULL</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d : %s\n&quot;</span>, i, environ[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的输出和上面是一样的。</p><p><img src="https://i.loli.net/2019/06/10/5cfe1b008712499387.png"></p><hr>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程状态</title>
      <link href="/2019/06/09/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81/"/>
      <url>/2019/06/09/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81/</url>
      
        <content type="html"><![CDATA[<p>在上一篇笔记的最后写到了<a href="https://ahoj.cc/2019/06/cjwoj0yar0042zwun75ca61mh/">孤儿进程</a>，这篇笔记总结一下进程都有哪些状态。</p><span id="more"></span><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位图</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> task_state_array[] = &#123;</span><br><span class="line"><span class="string">&quot;R (running)&quot;</span>, <span class="comment">/* 0 */</span></span><br><span class="line"><span class="string">&quot;S (sleeping)&quot;</span>, <span class="comment">/* 1 */</span></span><br><span class="line"><span class="string">&quot;D (disk sleep)&quot;</span>, <span class="comment">/* 2 */</span> </span><br><span class="line">  <span class="string">&quot;T (stopped)&quot;</span>, <span class="comment">/* 4 */</span></span><br><span class="line">  <span class="string">&quot;t (tracing stop)&quot;</span>, <span class="comment">/* 8 */</span></span><br><span class="line">  <span class="string">&quot;X (dead)&quot;</span>, <span class="comment">/* 16 */</span></span><br><span class="line"><span class="string">&quot;Z (zombie)&quot;</span>, <span class="comment">/* 32 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>R：</strong>运行状态，表示进程在运行中<em>或者</em>在运行队列里(当备胎)。</p><p><strong>S：</strong>睡眠状态，暂时还轮不到我，我先睡一会。</p><p><strong>D：</strong>磁盘休眠状态，有的时候也叫不可中断休眠状态，一般在密集的I/O操作时出现。程序在临终遗言(吐core dump)的时候会出现此状态。</p><p><strong>T：</strong>停止状态，可以通过ctrl + z放在后台，这个时候进程就是T状态了，fg再回来。(可以通过发送 SIGSTOP 信号给进程来停止进程。这个被暂停的进程可以通过发送 SIGCONT 信号让进程继续运行。)</p><p><strong>t：</strong>跟踪状态，GDB attach~~~</p><p><strong>X：</strong>一般看不到，只是一个返回状态。</p><p><strong>Z：</strong>僵尸进程。</p><h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><h3 id="成因"><a href="#成因" class="headerlink" title="成因"></a>成因</h3><p>简单来说就是子进程结束后父进程没有回收子进程的资源导致。</p><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">pid_t</span> ret = fork();</span><br><span class="line">  <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// father process</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// child process</span></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt &lt; <span class="number">5</span>) &#123;</span><br><span class="line">      cnt ++;</span><br><span class="line">      sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sleep(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/06/09/5cfcb3576d59c89171.png"></p><h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h3><p>Z状态一直不退出，PCB一直都要维护。内存泄漏。那一个父进程创建了很多子进程，就是不回收那不是太浪费了啊。我们要勤俭节约……扯哪里了。</p><h3 id="避免"><a href="#避免" class="headerlink" title="避免"></a>避免</h3><p>进程等待，父进程回收子进程的资源。</p><h2 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h2><h3 id="成因-1"><a href="#成因-1" class="headerlink" title="成因"></a>成因</h3><p>父进程先退出，子进程还在执行，子进程就会被 1 号进程收养，子进程的相关资源也由 1 号进程进行释放。</p><p>init 进程是一个统称，就和PCB 是统称一样，Linux 上的PCB叫task_struct。在centos 7上init进程叫systemd。</p><blockquote><p><strong>孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上</strong>，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。</p></blockquote><h3 id="模拟-1"><a href="#模拟-1" class="headerlink" title="模拟"></a>模拟</h3><p>之前fork 总结里。</p><h3 id="危害-1"><a href="#危害-1" class="headerlink" title="危害"></a>危害</h3><p>木有。</p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tack_struct</title>
      <link href="/2019/06/09/tack-struct/"/>
      <url>/2019/06/09/tack-struct/</url>
      
        <content type="html"><![CDATA[<p>PCB：process control block，里面放着进程的描述信息。在Linux 中的PCB 是task_struct。</p><span id="more"></span><h2 id="task-struct-的内容"><a href="#task-struct-的内容" class="headerlink" title="task_struct 的内容"></a>task_struct 的内容</h2><p><strong>PID：</strong>描述进程的唯一标识符，用来区分进程。(身份证号)</p><p><strong>status：</strong>任务状态、退出代码（<code>echo $?</code>）、退出信号灯。(一个人现在的状态)</p><p><strong>内存指针：</strong>包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针。(家庭地址)</p><p><strong>优先级：</strong>相对于其他进程的优先级。(家长是不是当官的)<br><em>使用top 命令有一列叫做PR，这个PR就是进程的优先级，在Linux下这个数字越小优先级越高。NI（nice）表示优先级的修正值，最终系统认定的优先级是PR + NI，通过指令可以修改nice值，但是因为CPU在进程之间切换非常快，一般也看不出什么</em></p><p><strong>程序计数器：</strong>程序中即将被执行的下一条指令的地址。(任务清单)</p><p><strong>上下文数据：</strong>在CPU 切换进程的时候会把当前寄存器中的数据保存起来，下次切换回这个线程的时候的一些数据就不会丢失，这个就是上下文。(保存上下文、恢复上下文)</p><p><strong>I/O信息：</strong>包括显示的I/O请求，分配给进程的I/O设备和被进程使用的文件列表。</p><p><strong>记账信息：</strong>皇上要雨露均沾呗~~</p><h2 id="组织进程"><a href="#组织进程" class="headerlink" title="组织进程"></a>组织进程</h2><p>进程在Linux 里是以链表的形式组织的，每一个节点应该都有一个task_struct。</p><p>一般除了top、ps等命令可以查看进程外，进程的信息还会记录在文件中，在<code>/proc</code>。</p><hr><blockquote><p>笔记参考：<br><a href="https://www.cnblogs.com/tongyan2/p/5544887.html">https://www.cnblogs.com/tongyan2/p/5544887.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 进程 </tag>
            
            <tag> PCB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fork</title>
      <link href="/2019/06/09/fork/"/>
      <url>/2019/06/09/fork/</url>
      
        <content type="html"><![CDATA[<p>是fork 不是 f**k。好吧，这个fork 翻译过来是”分叉”，在GitHub 那里可以fork 一份别人的仓库到自己的名下。就是开了个分叉，然后可以再自己fork 的这份仓库里进行操作，操作完了以后可以发起pull request 到原有的地方。</p><p>很形象啊有木有。在Linux 系统下可以通过fork (系统调用)来创建子进程，子进程会从fork 起继续向下执行代码。</p><p><img src="https://i.loli.net/2019/06/09/5cfc9561ceddf17183.png" alt="图片来源：我们团队仓库的network"></p><span id="more"></span><p>一调用fork，就有了两个进程，当前进程创建出一个子进程，两个进程都继续从fork 这行继续往下走。</p><ol><li><p>子进程的fork 返回值是<strong>0</strong></p></li><li><p>父进程fork 返回子进程的<strong>pid</strong>。</p></li><li><p>如果fork 返回值小于0，说明创建进程失败。</p><p>创建失败的原因：</p><ol><li><p>内存不够</p></li><li><p>内核参数限制（进程太多达到上限）ulimit -a查看</p><p><img src="https://i.loli.net/2019/06/09/5cfc99f188cd286366.png"></p></li><li><p>平台不支持</p></li><li><p>信号打断</p></li></ol></li></ol><p>好了，现在知道了这个写代码验证一下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">pid_t</span> ret = fork();</span><br><span class="line">  <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// father process</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;father process said: my pid=%d, and my father&#x27;s pid=%d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// child process</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child process said: my pid=%d, and my father&#x27;s pid=%d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sleep(<span class="number">1</span>); <span class="comment">// 注意这里的sleep</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个代码的16行，我不写sleep 和写了的输出结果是有区别的：</p><p><img src="https://i.loli.net/2019/06/09/5cfc9b92a9ae515722.png"></p><p>第一个红色框起来的是不写sleep：<br>爸爸：我叫23798，我的爸爸叫3766<br>儿子：我叫23799，我的爸爸叫1<br>为什么他爸生出来的儿子不认亲爸呢？这就是<strong>孤儿进程</strong>，爸爸把儿子创造出来后没多久就抛下儿子了，儿子被叫1号进程的人收养，所以这个儿子说我爸是1不是23798。</p><p>第二个红色框的是写了sleep的。</p><h2 id="fork-的详细解释"><a href="#fork-的详细解释" class="headerlink" title="fork 的详细解释"></a>fork 的详细解释</h2><p>fork 会以父进程为模板，创建一个子进程。</p><ol><li><p>会把父进程的 <strong>PCB</strong> 稍加修改，成为子进程的 PCB。</p></li><li><p>会把父进程的虚拟<strong>地址空间</strong>拷贝一份，作为子进程的地址空间。</p><p>堆和栈都会拷贝一份，注意这里是写时拷贝(偷懒？效率？)</p><p>父子进程会共用一份代码，各自有一份数据(代码有的时候也会被拷贝，比如做外挂的时候应该会😼)</p></li><li><p>fork 分别在父子进程中返回</p><p>父进程返回子进程的pid，子进程返0，在fork后继续执行。</p></li><li><p>父子进程的执行顺序并不是 if 判断返回值来的，这个是由调度器来弄。</p></li></ol><p><img src="https://i.loli.net/2019/06/11/5cff7f7d8ab0b99947.png" alt="fork过程"></p><p><strong>通常，父子代码共享，父子再不写入时，数据也是共享的，当任意一方试图写入，便以写时拷贝的方式各自一份副本。</strong></p><p><img src="https://i.loli.net/2019/06/11/5cff80ed47c2539119.png" alt="图片来源于网络，稍改"></p><hr><blockquote><p>笔记参考：<br><a href="http://www.maiziedu.com/wiki/process/fork/">http://www.maiziedu.com/wiki/process/fork/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 进程 </tag>
            
            <tag> 孤儿进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>环境变量</title>
      <link href="/2019/06/09/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
      <url>/2019/06/09/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>话说上一回……我配置了环境变量用<code>code .</code>打开vscode，好吧后来我发现只有当时生效，但是重启terminal 后就又不能了，得重新执行<code>source ~/.bash_profile</code>，才能再用<code>code</code>命令。</p><p>这是为什么呢？(蔡明腔)好吧不搞清这里不行了，直接翻开鸟哥私房菜……打开了linux.cn……</p><p><img src="https://i.loli.net/2019/06/09/5cfc5f187c8e029777.png"></p><span id="more"></span><h2 id="查看环境变量"><a href="#查看环境变量" class="headerlink" title="查看环境变量"></a>查看环境变量</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[parallels@centos-7 ~]$ echo $PATH</span><br><span class="line">/usr/local/bin:/usr/bin:/home/parallels/bin:/usr/local/sbin:/usr/sbin</span><br></pre></td></tr></table></figure><p>每两个目录之间使用冒号 <code>:</code> 分隔。</p><h2 id="修改环境变量"><a href="#修改环境变量" class="headerlink" title="修改环境变量"></a>修改环境变量</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="variable">$HOME</span> 是当前用户的家目录，可以使用 <span class="built_in">echo</span> <span class="variable">$HOME</span> 查看</span></span><br><span class="line">PATH=$PATH:$HOME/bin</span><br></pre></td></tr></table></figure><p><em><strong>上面这个操作只会在当前的 shell 生效，当前的 shell 一旦关闭，环境变量的值就又恢复原状了。</strong></em></p><p>如果要让变更对当前用户持续生效，就不能在 shell 中直接执行上面的命令，而是应该将变更操作写在每次启动 shell 时都会运行的文件当中。</p><p>之前配置vim 有一个vimrc ，配置环境变量有.bashrc 。<em>Linux 里面是 .bashrc 而 Mac 是 .bash_profile。</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[parallels@centos-7 ~]$ ls -al</span><br><span class="line">total 43000</span><br><span class="line">drwx------. 21 parallels parallels     4096 Jun  9 09:15 .</span><br><span class="line">drwxr-xr-x.  3 root      root            23 Aug 10  2017 ..</span><br><span class="line">-rw-------.  1 parallels parallels     9038 Jun  6 10:46 .bash_history</span><br><span class="line">-rw-r--r--.  1 parallels parallels       18 Aug  3  2016 .bash_logout</span><br><span class="line">-rw-r--r--.  1 parallels parallels      193 Aug  3  2016 .bash_profile</span><br><span class="line">-rw-r--r--.  1 parallels parallels      445 May 26 18:00 .bashrc # 就是它了 #</span><br><span class="line">drwx------. 15 parallels parallels     4096 Jun  7 12:47 .cache</span><br><span class="line">drwxr-xr-x.  3 parallels parallels       46 May  8 20:13 .cgdb</span><br><span class="line">drwxr-xr-x. 19 parallels parallels     4096 Jun  9 09:14 .config</span><br><span class="line">lrwxrwxrwx.  1 parallels parallels       54 May  1 20:48 .cquery -&gt; /home/parallels/.VimForCpp/cquery/config/cquery.config</span><br><span class="line">drwxr-xr-x.  2 parallels parallels       72 Jun  7 12:47 Desktop</span><br><span class="line">-rw-------.  1 parallels parallels       16 Aug 10  2017 .esd_auth</span><br><span class="line">-rw-r--r--.  1 parallels parallels 43854935 Jun  7 00:29 game-0.0.1-SNAPSHOT.jar</span><br><span class="line">-rw-r--r--.  1 parallels parallels    26101 Jun  7 00:26 game.sql</span><br></pre></td></tr></table></figure><h3 id="更改-bashrc-让环境变量更持久"><a href="#更改-bashrc-让环境变量更持久" class="headerlink" title="更改.bashrc 让环境变量更持久"></a>更改.bashrc 让环境变量更持久</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim .bashrc</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">shift</span> + g 调到文件末尾，o 跳到下一行并进入插入状态</span></span><br><span class="line">export PATH=$PATH:$HOME/bin</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">esc : wq</span></span><br><span class="line">source .bashrc # 刷新一下才能生效(或者重启)</span><br></pre></td></tr></table></figure><p>vim多多练习呀，感觉好好用。</p><h2 id="环境变量的加载顺序"><a href="#环境变量的加载顺序" class="headerlink" title="环境变量的加载顺序"></a>环境变量的加载顺序</h2><p><strong>Mac：</strong></p><p>/etc/profile /etc/paths ~/.bash_profile ~/.bash_login ~/.profile ~/.bashrc</p><p><strong>Linux：</strong></p><blockquote><p><a href="https://www.cnblogs.com/python2687806834/p/9848139.html">https://www.cnblogs.com/python2687806834/p/9848139.html</a></p><p>当你进入系统的时候，Linux 就会为你读入系统的环境变量，Linux 中有很多记载环境变量的文件，它们被系统读入是按照一定的顺序的。</p><ol><li>/etc/profile </li></ol><p>此文件为系统的环境变量，它为每个用户设置环境信息，当用户第一次登录时，该文件被执行。并从/etc/profile.d 目录的配置文件中搜集shell 的设置。这个文件，是任何用户登陆操作系统以后都会读取的文件（如果用户的shell 是csh 、tcsh 、zsh ，则不会读取此文件），用于获取系统的环境变量，只在登陆的时候读取一次。 (假设用户使用的是BASH )</p><ol start="2"><li>/etc/bashrc </li></ol><p>在执行完/etc/profile 内容之后，如果用户的SHELL 运行的是bash ，那么接着就会执行此文件。另外，当每次一个新的bash shell 被打开时, 该文件被读取。每个使用bash 的用户在登陆以后执行完/etc/profile 中内容以后都会执行此文件，在新开一个bash 的时候也会执行此文件。因此，如果你想让每个使用bash 的用户每新开一个bash 和每次登陆都执行某些操作，或者给他们定义一些新的环境变量，就可以在这个里面设置。</p><ol start="3"><li>~/.bash_profile </li></ol><p>每个用户都可使用该文件输入专用于自己使用的shell 信息。当用户登录时，该文件仅仅执行一次，默认情况下，它设置一些环境变量，执行用户的.bashrc 文件。单个用户此文件的修改只会影响到他以后的每一次登陆系统。因此，可以在这里设置单个用户的特殊的环境变量或者特殊的操作，那么它在每次登陆的时候都会去获取这些新的环境变量或者做某些特殊的操作，但是仅仅在登陆时。</p><ol start="4"><li>~/.bashrc </li></ol><p>该文件包含专用于单个人的bash shell 的bash 信息，当登录时以及每次打开一个新的shell 时, 该该文件被读取。单个用户此文件的修改会影响到他以后的每一次登陆系统和每一次新开一个bash 。因此，可以在这里设置单个用户的特殊的环境变量或者特殊的操作，那么每次它新登陆系统或者新开一个bash ，都会去获取相应的特殊的环境变量和特殊操作。 </p><ol start="5"><li>~/.bash_logout </li></ol><p>当每次退出系统( 退出bash shell) 时, 执行该文件。</p><p>用户登录后加载profile和bashrc的流程如下: </p><p>1)/etc/profile——–&gt;/etc/profile.d/*.sh </p><p>2)$HOME/.bash_profile——–&gt;$HOME/.bashrc———-&gt;/etc/bashrc </p><p>bash首先执行/etc/profile脚本,/etc/profile脚本先依次执行/etc/profile.d/*.sh </p><p>随后bash会执行用户主目录下的.bash_profile脚本,.bash_profile脚本会执行用户主目录下的.bashrc脚本, </p><p>而.bashrc脚本会执行/etc/bashrc脚本 </p><p>至此,所有的环境变量和初始化设定都已经加载完成.</p><p>bash随后调用terminfo和inputrc，完成终端属性和键盘映射的设定. </p></blockquote><hr><p>笔记就先到这里，下来我试试能不能让我不再每次启动terminal 都刷新才可以用<code>code .</code>。</p><p>好了，现在阔以啦。</p><p><img src="https://i.loli.net/2019/06/09/5cfc69668295592145.png"></p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决electron打包应用程序下载慢</title>
      <link href="/2019/06/06/%E8%A7%A3%E5%86%B3electron%E6%89%93%E5%8C%85%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8B%E8%BD%BD%E6%85%A2/"/>
      <url>/2019/06/06/%E8%A7%A3%E5%86%B3electron%E6%89%93%E5%8C%85%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8B%E8%BD%BD%E6%85%A2/</url>
      
        <content type="html"><![CDATA[<p>慢！</p><p>额，npm 下载就是慢，还是源的问题。</p><p>在命令前加一句就行，使用cnpm 源。</p><span id="more"></span><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ELECTRON_MIRROR=https://npm.taobao.org/mirrors/electron/ electron-packager ./ 测试 --icon=logo128.icns --platform=win32 --arch=x64</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一个瓜瓜错误</title>
      <link href="/2019/06/04/%E8%AE%B0%E4%B8%80%E4%B8%AA%E7%93%9C%E7%93%9C%E9%94%99%E8%AF%AF/"/>
      <url>/2019/06/04/%E8%AE%B0%E4%B8%80%E4%B8%AA%E7%93%9C%E7%93%9C%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<p>【1】好吧好气哦。在写前端项目的时候，随便命名了一个let 叫test。然后用webstorm 右键rename，一不小心把webpack里的test 也改了，然后用npm run dev 一直报一个错，说找不到那个东西，就好生气啊。当时急坏了，怎么会崩了呢！？</p><p>【2】然后百度了一下，因为比较着急也没找到有效的解决方法。(可能是太着急了，没细看，应该有啵)，好吧，版本回退一下，OK，可以编译和测试了。但是我又双叕用了那个rename 重命名了一下。。。又崩了。心态也崩了。</p><p>【终】想的不写了。去食堂买了杯西瓜汁，然后吃饭，吃的过程中一想，诶我靠那不是配置文件也被改了吧？我回来一看！果然是！哈哈哈，冷静冷静。</p><p><img src="https://i.loli.net/2019/06/04/5cf62bf99b3a956018.png"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Electron-打包</title>
      <link href="/2019/06/04/Electron-%E6%89%93%E5%8C%85/"/>
      <url>/2019/06/04/Electron-%E6%89%93%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>Electron 真是挺方便，此次项目它将我的 vue.js 的项目打包了起来。<br>认真看官方手册，学习一手资料。学到了学到了。:)</p><span id="more"></span><h2 id="安装-Electron"><a href="#安装-Electron" class="headerlink" title="安装 Electron"></a>安装 Electron</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm i electron -g<span class="comment"># 全局安装 electron</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm i electron-packager -g <span class="comment"># 安装打包工具</span></span></span><br></pre></td></tr></table></figure><p>使用 cnpm 或 yarn 可能会快一些，😁。</p><h2 id="下载-Demo"><a href="#下载-Demo" class="headerlink" title="下载 Demo"></a>下载 Demo</h2><p>electron的simple demo中是一个基本的electron目录结构，下载下来后将自己编译好的放进去即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/electron/electron-quick-start</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> electron-quick-start</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install &amp;&amp; npm start</span></span><br></pre></td></tr></table></figure><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><h3 id="打包-OSX-App"><a href="#打包-OSX-App" class="headerlink" title="打包 OSX App"></a>打包 OSX App</h3><p>在mac下打包自己系统用的app不用装别的环境了，上面两个就OK咯。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">electron-packager ./ i-Class --icon=logo.icns</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./ 是项目目录</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">i-Class 是打包好后的 app 名</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--icon 是 app 的logo，不加这个默认生成的app使用的是 electron 的logo。</span></span><br></pre></td></tr></table></figure><p>mac 图标格式为 <code>.icns</code> ，打包 Windows 应用程序图表格式应为 .ico。</p><h3 id="打包-Windows-App"><a href="#打包-Windows-App" class="headerlink" title="打包 Windows App"></a>打包 Windows App</h3><p>刚开始在 pd 虚拟机中跑 Windows 10 来打包，但是虚拟机对于文档权限总是有各种各样的问题，最后看了官方手册后……以后还是看使用说明再开始上手吧，嘿嘿。</p><p>在 mac 下是可以编译 Windows 下的应用程序的，需要下载个 wine。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">brew install wine</span></span><br></pre></td></tr></table></figure><p>然后执行打包命令，他将会自动下载对应平台的打包工具。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">electron-packager ./ i-Class --platform=win32 --<span class="built_in">arch</span>=x64 --icon=logo128.ico</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--platform=win32</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">平台：darwin, linux, mas, win32</span></span><br></pre></td></tr></table></figure><p>当然，总是输入这一大堆命令会有些麻烦，配置下 package.json：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">      &quot;name&quot;: &quot;zzh&quot;,</span><br><span class="line">      &quot;version&quot;: &quot;0.0.1&quot;,</span><br><span class="line">      &quot;description&quot;: &quot;a simple application&quot;,</span><br><span class="line">      &quot;main&quot;: &quot;main.js&quot;,</span><br><span class="line">      &quot;scripts&quot;: </span><br><span class="line">      &#123;</span><br><span class="line">        &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">        &quot;start&quot;: &quot;electron .&quot;,</span><br><span class="line">        &quot;package&quot;: &quot;electron-packager . HelloWorld --win --out ../HelloWorldApp --arch=x64 --version=1.0.0 --electron-version=1.4.13&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;author&quot;: &quot;zzh&quot;,</span><br><span class="line">      &quot;license&quot;: &quot;ISC&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="出错解决"><a href="#出错解决" class="headerlink" title="出错解决"></a>出错解决</h2><p><img src="https://i.loli.net/2019/06/04/5cf5bf486fad822129.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unable to determine electron version.  Please specify an Electron version.</span><br></pre></td></tr></table></figure><p>用 electron-package –help 查看，确实有一个属性是 –electron-version，然后加上对应的版本即可。</p><p><img src="https://i.loli.net/2019/06/04/5cf5bf967f6b359628.png"></p><hr><blockquote><p>参考：<br><a href="https://github.com/electron-userland/electron-packager">electron-packager官方文档</a><br><a href="http://get.ftqq.com/7870.get">用Electron开发桌面应用</a><br><a href="https://segmentfault.com/a/1190000005744529">用 Electron 打造跨平台前端 App</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Electron </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Electron </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacOS中使用命令code打开vscode</title>
      <link href="/2019/06/02/MacOS%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4code%E6%89%93%E5%BC%80vscode/"/>
      <url>/2019/06/02/MacOS%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4code%E6%89%93%E5%BC%80vscode/</url>
      
        <content type="html"><![CDATA[<p>之前网上看一些老师的课程，他们直接在cmd 或terminal 输入<code>code .</code>用vscode 打开了当前目录，感觉挺方便的，虽然知道那就是配置下环境变量，但是对环境变量又不怎么熟悉。只知道配置环境变量就可以……在学Java的时候也就是照着操作，并不明白每一步什么意思。</p><p>百度都有呐，今天认真看了几遍linux.cn 上前辈的文章，理解了一些。试着做一下。</p><p>感谢linux.cn 上的大佬和翻译大佬文章的大佬，我也要加入到翻译菌中。😝</p><p><img src="https://i.loli.net/2019/06/02/5cf3844d28dd563695.png"></p><span id="more"></span><p>嗯，开始吧。</p><ol><li><p>显示vscode的包内容找找他的可执行文件在哪里</p><p>哦吼，看到了electron，明白了，应该在Resource下。双击看看，哦吼打开liao，就是他了。</p><p><img src="https://i.loli.net/2019/06/02/5cf38603eff7f15498.png"></p></li><li><p>把这个东西拖到terminal 里复制下路径。</p><p><img src="https://i.loli.net/2019/06/02/5cf3869ec7a9941165.png"></p></li><li><p>打开用户下的<code>.bash_profile</code>，后面加一句</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=/Applications/Visual\ Studio\ Code.app/Contents/Resources/app/bin:$PATH</span><br></pre></td></tr></table></figure></li><li><p>刷新下，让这个新修改的配置文件生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source .bash_profile</span><br></pre></td></tr></table></figure></li><li><p>enjoy~</p></li></ol><hr><blockquote><p>相关资料：<br><a href="https://linux.cn/article-10374-1.html">https://linux.cn/article-10374-1.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 小技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 小技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Notes-make and makefile</title>
      <link href="/2019/06/02/Notes-make-and-makefile/"/>
      <url>/2019/06/02/Notes-make-and-makefile/</url>
      
        <content type="html"><![CDATA[<p>工程管理工具：解决大型项目中的模块之间的依赖问题。</p><p>Makefile，是一个大概40 年前的技术，实际开发中不会手写Makefile，会用一些比如CMake 之类的工具来生成。</p><p>这个笔记只是简单地使用。</p><span id="more"></span><h2 id="上手"><a href="#上手" class="headerlink" title="上手"></a>上手</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 格式</span></span><br><span class="line"><span class="section">目标:依赖</span></span><br><span class="line">  命令</span><br><span class="line"><span class="comment"># 栗子 Makefile/makefile</span></span><br><span class="line"><span class="section">test:test.c</span></span><br><span class="line">gcc test.c -g -o test</span><br></pre></td></tr></table></figure><p>终端输入<code>make</code>后的大体执行流程：</p><ol><li>现在当前目录下查找 Makefile/makefile 文件</li><li>找到要生成的目标(决定是否要真的生成，这是依赖文件和目标文件的acm时间来决定的)</li><li>检查依赖的文件是否都存在</li><li>执行命令</li></ol><blockquote><p>如果Makefile 中包含了多个目标，直接敲make 默认生成第一个目标。</p></blockquote><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean # 声明clean 为一个伪目标</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f test</span><br><span class="line"><span class="comment"># make clean</span></span><br></pre></td></tr></table></figure><blockquote><p>clean 这样的目标，知识为了执行一个动作，而不是为了生成文件，如果此时在目录中碰巧有一个叫clean 的文件，就会影响到动作的执行。所以要加<code>.PHONY:clean</code> 来声明clean 为一个为目标。</p></blockquote><h2 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h2><p>CMake：开原世界中广泛使用。<br>Blaze(火焰刀)：谷歌推出的，比较重量级。</p><hr>]]></content>
      
      
      <categories>
          
          <category> make </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Notes </tag>
            
            <tag> 工程管理工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Notes-gcc/g++</title>
      <link href="/2019/05/31/Notes-gcc-g++/"/>
      <url>/2019/05/31/Notes-gcc-g++/</url>
      
        <content type="html"><![CDATA[<p>在 Linux 上使用 gcc/g++ 编译 C/Cpp 程序。</p><span id="more"></span><h2 id="源文件到可执行程序"><a href="#源文件到可执行程序" class="headerlink" title="源文件到可执行程序"></a>源文件到可执行程序</h2><ol><li><p>预处理</p><p>展开头文件/宏替换/去掉注释/条件编译，生成<code>.i</code>文件。</p></li><li><p>编译</p><p>检查语法，生成汇编文件<code>.s</code>。</p></li><li><p>汇编</p><p>汇编代码转换机器码，生成<code>.o</code>文件。</p></li><li><p>链接</p><p>将上一步生成的以及一些依赖的库链接起来生成可执行程序。</p></li></ol><h2 id="使用-gcc-编译"><a href="#使用-gcc-编译" class="headerlink" title="使用 gcc 编译"></a>使用 gcc 编译</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc Test.c --save-temps -o Test # 可保留C程序编译过程中产生的临时文件</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/05/31/5cf0a2fd5430f49389.png"></p><h3 id="step-by-step"><a href="#step-by-step" class="headerlink" title="step by step"></a>step by step</h3><ol><li><p>预处理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc –E Test.c –o Test.i</span><br></pre></td></tr></table></figure></li><li><p>编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc –S Test.i –o Test.s</span><br></pre></td></tr></table></figure></li><li><p>汇编</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc –c Test.s –o Test.o</span><br></pre></td></tr></table></figure></li><li><p>链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc Test.o –o Test</span><br></pre></td></tr></table></figure></li></ol><h3 id="一些参数"><a href="#一些参数" class="headerlink" title="一些参数"></a>一些参数</h3><h4 id="g"><a href="#g" class="headerlink" title="-g"></a><code>-g</code></h4><p>编译时候保留调试信息，如果要使用 gdb 调试程序，必须保留调试信息。</p><h4 id="O"><a href="#O" class="headerlink" title="-O"></a><code>-O</code></h4><p>优化级别，<code>-O0</code> 到 <code>-O3</code>，代表4 个不同的优化级别。</p><p>一般业界公认的是O2，O3比较激进，-O1为缺省值。如果为了调试，最好用 O0。</p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> gcc/g++ </tag>
            
            <tag> C/Cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-yum的使用</title>
      <link href="/2019/05/29/Linux-yum%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/05/29/Linux-yum%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>包管理器是很方便啊，在node里有npm、cnpm、yarn等，要啥install啥子。</p><p>通过 Linux 的包管理器可以很方便的下载并安装 Linux 下的一些软件。比如 Centos 中的 yum，Ubuntu 中的 apt-get。</p><p>以前用都没怎么了解过，今天！我就要拿小本本记下来！</p><span id="more"></span><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><blockquote><p>大多数包系统都是围绕包文件的集合构建的。包文件通常是一个存档文件，它包含已编译的二进制文件和软件的其他资源，以及安装脚本。包文件同时也包含有价值的元数据，包括它们的依赖项，以及安装和运行它们所需的其他包的列表。 ——<a href="https://linux.cn/article-8782-1.html?pr">前辈的文章</a></p></blockquote><p>虽然包管理系统的功能和优点大致相同，但打包格式和工具却因平台而异：<br><img src="https://raw.githubusercontent.com/ahojcn/blog-img/master/img20190529151017.png"></p><p><em>图片来源：Linux.cn</em></p><h2 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h2><blockquote><p>yum(Yellow dog Updater, Modified)主要用在Fedora，RedHat，Centos等发行版上。</p></blockquote><h3 id="列出安装包"><a href="#列出安装包" class="headerlink" title="列出安装包"></a>列出安装包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ yum list | grep lrzsz # rzsz工具用于windows机器和远端的Linux机器通过XShell传输文件.拖拽即可</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行结果，列出了yum源里相关的包</span></span><br><span class="line">lrzsz.x86_64                           0.12.20-36.el7                  @anaconda</span><br><span class="line">➜  ~ </span><br></pre></td></tr></table></figure><p>软件包名称（lrzsz）</p><p>主版本号.次版本号.源程序发行号-软件包的发行号.主机平台(</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ yum list | grep lrzsz</span><br><span class="line"># 执行结果，列出了yum源里相关的包</span><br><span class="line">lrzsz.x86_64                           0.12.20-36.el7                  @anaconda</span><br><span class="line">➜  ~ </span><br></pre></td></tr></table></figure><p>软件包名称.cpu架构（lrzsz.x86_64）</p><p>主版本号.次版本号.源程序发行号-软件包的发行号.主机平台（0.12.20-36.el7）</p><ul><li>“el7” 表示操作系统发行版的版本，”el7” 表示的是 centos7/redhat7，”el6” 表示 centos6/redhat6。</li></ul><p>软件源（@anaconda）</p><h3 id="搜索软件包"><a href="#搜索软件包" class="headerlink" title="搜索软件包"></a>搜索软件包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum search httpd</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ahojcn/blog-img/master/img20190529153014.png"></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install lrzsz</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果不想让弹出询问 y/N 的对话，可以使用</span></span><br><span class="line">sudo yum install -y lrzsz</span><br></pre></td></tr></table></figure><p>安装软件时由于需要向系统目录中写入内容, 一般需要 sudo 或者切到 root 账户下才能完成。<br>yum安装软件只能一个装完了再装另一个，正在yum安装一个软件的过程中,，如果再尝试用yum安装另外一个软件，yum会报错。</p><h4 id="如果有一个本地的软件包"><a href="#如果有一个本地的软件包" class="headerlink" title="如果有一个本地的软件包"></a>如果有一个本地的软件包</h4><blockquote><p>假如你有一个rpm软件包但是没有它所依赖的软件包，你不知道到哪去得到它所依赖的软件包。你仍然可以通过yum安装这个rpm软件包，并从软件仓库里得到它所依赖的软件包。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum localinstall /opt/httpd-devel-2.2.15-29.el6_4.x86_64.rpm</span><br></pre></td></tr></table></figure><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum list installed # 列出所有已经安装了的软件</span><br><span class="line"></span><br><span class="line">sudo yum remove lrzsz</span><br></pre></td></tr></table></figure><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum update httpd # 更新一个已存在的软件包</span><br><span class="line">yum update # 更新服务器上所有的软件包</span><br></pre></td></tr></table></figure><h3 id="下载但不安装"><a href="#下载但不安装" class="headerlink" title="下载但不安装"></a>下载但不安装</h3><p>下载一个插件让yum只下载rpm软件包而不安装。插件名字叫downloadonly，可以通过yum安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install yum-downloadonly</span><br></pre></td></tr></table></figure><p>现在就可以从软件仓库里只下载软件包而不安装了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install httpd-devel -downloadonly</span><br></pre></td></tr></table></figure><p>默认情况下软件包会被下载到/var/cache/yum/目录，但是可以添加额外选项将其下载到指定位置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install httpd-devel -downloadonly -downloaddir=/home</span><br></pre></td></tr></table></figure><hr><blockquote><ul><li><a href="https://linux.cn/article-8782-1.html?pr">Linux 包管理基础：apt、yum、dnf 和 pkg</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 包管理器 </tag>
            
            <tag> yam </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-权限</title>
      <link href="/2019/05/29/Linux-%E6%9D%83%E9%99%90/"/>
      <url>/2019/05/29/Linux-%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<p><em>在 Linux 中，root 用户是不在访问权限限制之内的。</em></p><span id="more"></span><h2 id="文件类型和访问权限"><a href="#文件类型和访问权限" class="headerlink" title="文件类型和访问权限"></a>文件类型和访问权限</h2><p><img src="https://raw.githubusercontent.com/ahojcn/blog-img/master/imgwiki-linux%E6%9D%83%E9%99%90-1.png"></p><ol start="0"><li>文件类型<ul><li>d：文件夹</li><li>-：普通文件</li><li>l：软链接(类似于快捷方式)</li><li>b：块设备文件(硬盘、光驱等)</li><li>p：管道文件</li><li>c：字符设备文件(例如屏幕等串口设备)</li><li>s：套接字文件</li></ul></li><li>文件所有者的权限</li><li>文件所属用户组的权限</li><li>其他用户权限</li><li>连接数</li><li>所属用户</li><li>所属用户组</li><li>大小</li><li>最新修改日期</li><li>文件/文件夹名</li></ol><h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><p>r 能够查看文件内容<br>w 能够修改文件内容<br>x 能够运行程序</p><p><img src="https://img.linux.net.cn/data/attachment/album/201606/14/140251cb2zzeuqofbs7t7e.png"></p><p><em>注：上图来源<a href="https://linux.cn/article-7460-1.html">Linux.cn</a></em></p><h3 id="目录权限"><a href="#目录权限" class="headerlink" title="目录权限"></a>目录权限</h3><p>r 能够查看目录中的文件/目录<br>w 能够修改目录中的内容(新增/删除)<br>x 能够进入目录中</p><p>注意一点：只要用户拥有了目录的 w 权限，不管用户是否具有目录的 r 权限都可以删除文件，为了解决这个问题，Linux使用粘滞位，给目录添加粘滞位即可。<a href="#%E7%B2%98%E6%BB%9E%E4%BD%8D">粘滞位</a></p><h2 id="更改访问权限"><a href="#更改访问权限" class="headerlink" title="更改访问权限"></a>更改访问权限</h2><p>有权编辑文件才可以更改文件的权限。</p><h3 id="使用等效数字设置权限"><a href="#使用等效数字设置权限" class="headerlink" title="使用等效数字设置权限"></a>使用等效数字设置权限</h3><ul><li>读 — 4</li><li>写 — 2</li><li>执行— 1</li></ul><p><strong>注意：</strong>数值代替不是一个一个替换的，应该是加起来得到的。例如给所属者读和写，<code>4+2=6</code>，给所属用户组读和写，<code>4+2=6</code>，给其他用户权限为读<code>4</code>，则应该设置的权限等效数字为：<code>664</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 664 fileName</span><br></pre></td></tr></table></figure><h3 id="使用字符设置权限"><a href="#使用字符设置权限" class="headerlink" title="使用字符设置权限"></a>使用字符设置权限</h3><p>u 代表文件拥有者(user)，g 文件拥有者所属组(group)，o 其他用户(other)，a 所有(all)。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给文件所属者增加x权限</span></span><br><span class="line">chmod u+x fileName</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给文件所属者和所属组同时增加 x 权限</span></span><br><span class="line">chmod ug+x fileName</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除其他用户的 x 权限</span></span><br><span class="line">chmod o-x fileName</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给所有人删除 x 权限</span></span><br><span class="line">chmod a-x fileName</span><br></pre></td></tr></table></figure><h3 id="递归更改目录下文件的权限"><a href="#递归更改目录下文件的权限" class="headerlink" title="递归更改目录下文件的权限"></a>递归更改目录下文件的权限</h3><p>参数 -R 递归。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R g-w Dir</span><br></pre></td></tr></table></figure><hr><blockquote><p>更多学习资料：<br><a href="https://linux.cn/article-7460-1.html">初识 Linux 文件权限</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue-[vue-router] Named Route &#39;index&#39; has a default child route.</title>
      <link href="/2019/05/28/Vue-vue-router-Named-Route-index-has-a-default-child-route/"/>
      <url>/2019/05/28/Vue-vue-router-Named-Route-index-has-a-default-child-route/</url>
      
        <content type="html"><![CDATA[<p>Vue-router 警告：已经有一个默认的child route了。。。。的解决方法。</p><p>[vue-router] Named Route ‘index’ has a default child route. When navigating to this named route (:to=”{name: ‘index’”), the default child route will not be rendered. Remove the name from this route and use the name of the default child route for named links instead.</p><span id="more"></span><p><img src="https://raw.githubusercontent.com/ahojcn/blog-img/master/img20190528161203.png"></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>去掉父路由中的name属性即可。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小技巧-搜索语法</title>
      <link href="/2019/05/28/%E5%B0%8F%E6%8A%80%E5%B7%A7-%E6%90%9C%E7%B4%A2%E8%AF%AD%E6%B3%95/"/>
      <url>/2019/05/28/%E5%B0%8F%E6%8A%80%E5%B7%A7-%E6%90%9C%E7%B4%A2%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>昨天在查资料的时候，发现一个很好的网站，我想只搜这个网站中的信息，这就用到了一些搜索语法。</p><p>我记得这些搜索语法还是在初中的时候学的，当时特喜欢”黑客”，学了一些基本的计算机使用方法，学了不理解的sql注入挂小马上大马等，现在对于”黑客”一词也有了新的理解（使用技术解决生活中的一些实际问题），额额扯远了哈哈。回到正题。</p><span id="more"></span><p>使用下面的语法可以限定搜索范围为linux.cn，举一反三吧~哈哈</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:linux.cn less</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ahojcn/blog-img/master/img20190528100725.png"></p><p>也可以用这种方法查看自己的GitHub博客被搜索引擎收录了啵</p><p><img src="https://raw.githubusercontent.com/ahojcn/blog-img/master/img20190528101100.png"></p><hr><blockquote><p>更多的搜索语法百度咯~<br><a href="https://blog.csdn.net/u013589137/article/details/82758762">google搜索语法</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 小技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-基础命令</title>
      <link href="/2019/05/28/Linux-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/05/28/Linux-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>多多练习。。。</p><span id="more"></span><h2 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h2><p>查看文件的属性状态信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  File: ‘game.sql’</span><br><span class="line">  Size: 5188            Blocks: 16         IO Block: 4096   regular file</span><br><span class="line">Device: fd01h/64769d    Inode: 158837      Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 1970-01-01 08:00:00.000000000 +0800</span><br><span class="line">Modify: 2019-05-25 21:18:36.000000000 +0800</span><br><span class="line">Change: 2019-05-25 21:21:36.685591248 +0800</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure><h3 id="时间属性"><a href="#时间属性" class="headerlink" title="时间属性"></a>时间属性</h3><p><strong>Access</strong> time：最后<strong>访问</strong>时间，查看文件的内容时，这个时间会改变，使用cat命令查看文件时，可以看出Access time已经变了。</p><p><strong>Modify</strong> time：最后<strong>修改</strong>时间，修改文件内容，文件的修改时间会改变，访问时间和状态改变时间也发生变化。</p><p><strong>Change</strong> time：状态<strong>改变</strong>时间,修改文件内容，移动文件，或者改变文件属性（权限）等，文件的change time会发生改变。</p><h2 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h2><p>创建空文件，或者改变文件/文件夹的时间戳属性。</p><h3 id="创建空文件"><a href="#创建空文件" class="headerlink" title="创建空文件"></a>创建空文件</h3><p>创建一个或多个文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">touch a.txt</span><br><span class="line">touch b.txt c.txt</span><br><span class="line">touch a-&#123;1..20&#125;.txt # 创建了20个名为 a-1.txt 到 a-20.txt 的空文件</span><br></pre></td></tr></table></figure><h3 id="修改时间"><a href="#修改时间" class="headerlink" title="修改时间"></a>修改时间</h3><ul><li><p>修改access时间</p><ul><li><p>修改文件访问时间：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将当前时间设置为该文件或目录的访问和修改时间。</span></span><br><span class="line">touch -a a.txt #没有a.txt会创建一个</span><br><span class="line">touch -c a.txt #有a.txt就修改access时间，没有也不会创建</span><br></pre></td></tr></table></figure></li><li><p>修改目录访问时间：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将当前时间设置为该文件或目录的访问和修改时间。</span></span><br><span class="line">touch -m /root/</span><br></pre></td></tr></table></figure></li></ul></li><li><p>更改modify时间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch -m devops.txt # 修改文件modify时间</span><br><span class="line">touch -m /dir/ # 修改目录modify时间</span><br></pre></td></tr></table></figure></li></ul><h3 id="将access和modify时间设置为特定的日期和时间"><a href="#将access和modify时间设置为特定的日期和时间" class="headerlink" title="将access和modify时间设置为特定的日期和时间"></a>将access和modify时间设置为特定的日期和时间</h3><h4 id="日期和时间格式"><a href="#日期和时间格式" class="headerlink" title="日期和时间格式"></a>日期和时间格式</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;CCYY&#125;MMDDhhmm.ss</span><br></pre></td></tr></table></figure><ul><li><code>CC</code> – 年份的前两位数字</li><li><code>YY</code> – 年份的后两位数字</li><li><code>MM</code> – 月份 (01-12)</li><li><code>DD</code> – 天 (01-31)</li><li><code>hh</code> – 小时 (00-23)</li><li><code>mm</code> – 分钟 (00-59)</li></ul><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">touch -c -t 202510191820 a.txt # -c 选项没有也不创建新文件</span><br><span class="line"></span><br><span class="line">touch -c -d &quot;2010-02-07 20:15:12.000000000 +0530&quot; b.txt</span><br></pre></td></tr></table></figure><h3 id="使用参考文件设置时间戳（-r）"><a href="#使用参考文件设置时间戳（-r）" class="headerlink" title="使用参考文件设置时间戳（-r）"></a>使用参考文件设置时间戳（-r）</h3><p>在 <code>touch</code> 命令中，我们可以使用参考文件来设置文件或目录的时间戳。假设我想在 <code>devops.txt</code> 文件上设置与文件 <code>sysadm-20.txt</code> 文件相同的时间戳，<code>touch</code> 命令中使用 <code>-r</code> 选项可以轻松实现。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch -r &#123;参考文件&#125; 真正文件</span><br></pre></td></tr></table></figure><h3 id="在符号链接文件上更改访问和修改时间"><a href="#在符号链接文件上更改访问和修改时间" class="headerlink" title="在符号链接文件上更改访问和修改时间"></a>在符号链接文件上更改访问和修改时间</h3><p>默认情况下，每当我们尝试使用 <code>touch</code> 命令更改符号链接文件的时间戳时，它只会更改原始文件的时间戳。如果你想更改符号链接文件的时间戳，则可以使用 <code>touch</code> 命令中的 <code>-h</code> 选项来实现。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch -h &#123;符号链接文件&#125;</span><br></pre></td></tr></table></figure><h2 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h2><p>make directory。</p><p>参数：-p 可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后，系统将自动建立<br>好那些尚不存在的目录,即一次可以建立多个目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir –p test/test1 # 递归建立多个目录</span><br></pre></td></tr></table></figure><h2 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h2><p>删除<strong>空</strong>目录。</p><p>参数：-p 当子目录被删除后如果父目录也变成空目录的话，就连带父目录一起删除。</p><h2 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h2><p><code>rm -r -i dirname</code>这条命令在删除文件夹的时候，会对每个文件询问是否要删除。</p><p>参数：<br>-r 删除目录及其下面的所有目录/文件<br>-i 删除线询问<br>-f 即使文件权限只读(写保护)，也直接删除</p><h2 id="man"><a href="#man" class="headerlink" title="man"></a>man</h2><p>真男人手册！哈哈哈</p><p>Man 帮助页通过数字标识符来分成不同类型的内容：<code> man man</code></p><ol><li>一般用户命令</li><li>系统调用命令（如open、write之类的）</li><li>库函数(如printf、scanf之类的)</li><li>特殊的文件和驱动程序</li><li>文件格式(比如passwd，就会说明这个文件中各个字段的含义)</li><li>游戏和屏保(由各个游戏自己定义)</li><li>杂项(比如environ这种全局变量在这里就有说明)</li><li>系统管理命令和守护进程(这些命令只能由root使用，如ifconfig)</li></ol><h2 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h2><p>copy。</p><h3 id="文件-gt-文件"><a href="#文件-gt-文件" class="headerlink" title="文件 -&gt; 文件"></a>文件 -&gt; 文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp sourcefile destfile</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当然，拷贝文件到目录也可以这么做</span></span><br></pre></td></tr></table></figure><h3 id="同时拷贝多个文件-gt-文件夹"><a href="#同时拷贝多个文件-gt-文件夹" class="headerlink" title="同时拷贝多个文件 -&gt; 文件夹"></a>同时拷贝多个文件 -&gt; 文件夹</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp file_1.txt file_2.txt file_3.txt /home/ahoj/test</span><br></pre></td></tr></table></figure><h3 id="文件夹-gt-文件夹"><a href="#文件夹-gt-文件夹" class="headerlink" title="文件夹 -&gt; 文件夹"></a>文件夹 -&gt; 文件夹</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp -r srcDir /dest/dir/ # -r 参数，全称 “recursive”</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-r或-R 选项表明递归操作。无论该目录是否为空目录，这个选项都是必要的。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">需要注意的一件事，你需要移除在目录名尾部的斜杠。否则你会收到类似的错误信息<span class="built_in">cp</span>: omitting directory‘srcDir/’</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果想获取更多的反馈，就使用 -v 参数让执行结果更详细。</span></span><br></pre></td></tr></table></figure><h3 id="只拷贝新文件"><a href="#只拷贝新文件" class="headerlink" title="只拷贝新文件"></a>只拷贝新文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp -r -u -v srcDir /dest/dir</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-r 是“递归”， -u 是“更新”，-v 是“详细”</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">也可以这么连用 -ruv。</span></span><br></pre></td></tr></table></figure><h3 id="创建文件的硬链接，而不是拷贝它们"><a href="#创建文件的硬链接，而不是拷贝它们" class="headerlink" title="创建文件的硬链接，而不是拷贝它们"></a>创建文件的硬链接，而不是拷贝它们</h3><p>创建“快捷方式”或者链接到文件，而不是拷贝它们。要做到这一点，可以使用 -l 选项。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -l file_4.txt /home/aaa/office</span><br></pre></td></tr></table></figure><h3 id="创建文件的符号链接"><a href="#创建文件的符号链接" class="headerlink" title="创建文件的符号链接"></a>创建文件的符号链接</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -s /home/pungki/Documents/file_6.txt file_6.txt</span><br></pre></td></tr></table></figure><h3 id="交互模式"><a href="#交互模式" class="headerlink" title="交互模式"></a>交互模式</h3><p>-i 选项，拷贝前会问你。</p><h3 id="强制拷贝"><a href="#强制拷贝" class="headerlink" title="强制拷贝"></a>强制拷贝</h3><p>用了 -f 选项会强制进行拷贝操作。如果目标文件不能打开，可以用 -f 试试。</p><h2 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h2><p>move，move!</p><h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv srcFile /root/Desktop/</span><br><span class="line">mv *.txt /root/Desktop/</span><br><span class="line">mv 1.txt 2.bat 3.sh /root/Desktop/</span><br></pre></td></tr></table></figure><h3 id="移动目录"><a href="#移动目录" class="headerlink" title="移动目录"></a>移动目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv srcDir/ /root/destDir/</span><br></pre></td></tr></table></figure><h3 id="重命名文件或目录"><a href="#重命名文件或目录" class="headerlink" title="重命名文件或目录"></a>重命名文件或目录</h3><p>move 到相同的文件夹下即可。</p><h3 id="更多参数"><a href="#更多参数" class="headerlink" title="更多参数"></a>更多参数</h3><ul><li>-v 打印详细信息</li><li>-i 移动前问你</li><li>-u 只在源文件比目标文件新时才执行更新</li><li>-n 不会允许覆盖任何已存在的文件</li><li>-b 复制时创建备份(避免如果移动错了文件而目标文件已经被新的文件覆盖了)</li><li>-f 无条件覆盖已经存在的文件</li></ul><h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h2><h3 id="输出行号"><a href="#输出行号" class="headerlink" title="输出行号"></a>输出行号</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-n 对所有输出都有行号</span></span><br><span class="line">➜  C cat -n test.c</span><br><span class="line">     1#include &lt;stdio.h&gt;</span><br><span class="line">     2</span><br><span class="line">     3int main(int argc, char const *argv[])</span><br><span class="line">     4&#123;</span><br><span class="line">     5    int a = 10;</span><br><span class="line">     6    printf(&quot;hello vscode\n&quot;);</span><br><span class="line">     7    return 0;</span><br><span class="line">     8&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-b 对非空行输出行号</span></span><br><span class="line">➜  C cat -b test.c </span><br><span class="line">     1#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">     2int main(int argc, char const *argv[])</span><br><span class="line">     3&#123;</span><br><span class="line">     4    int a = 10;</span><br><span class="line">     5    printf(&quot;hello vscode\n&quot;);</span><br><span class="line">     6    return 0;</span><br><span class="line">     7&#125;</span><br></pre></td></tr></table></figure><h3 id="不输出多行空行"><a href="#不输出多行空行" class="headerlink" title="不输出多行空行"></a>不输出多行空行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -s test.cpp # 不输出多行空行</span><br></pre></td></tr></table></figure><h2 id="more"><a href="#more" class="headerlink" title="more"></a>more</h2><p>-n 对输出的所有行编号<br>q 退出more</p><blockquote><p><code>more</code> 是一个老式的、基础的终端分页阅读器，它可以用于打开指定的文件并进行交互式阅读。如果文件的内容太长，在一屏以内无法完整显示，就会逐页显示文件内容。使用回车键或者空格键可以滚动浏览文件的内容，但有一个限制，就是只能够单向滚动。也就是说只能按顺序往下翻页，而不能进行回看。</p></blockquote><p>在有些系统里more是可以按b向前看的，有些more不可以配合管道，有些more阔以。在我的电脑上就都阔以。</p><h2 id="less"><a href="#less" class="headerlink" title="less"></a>less</h2><p>less 可以打开一个比较大的文件，less 打开大文件效率很高，尤其是几个 G 的文件。<br>less 打开文件的时候，只把一小部分数据加载到内存中，而其他编辑器都是直接把整个文件都加载。（延时加载/懒加载）</p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><ul><li><p>向下搜索</p><p>输入斜杠（/）之后接着输入需要搜索的内容，按 n 键可以跳转到下一个匹配的字符串，如果需要跳转到上一个匹配的字符串，可以按 N 键。</p></li><li><p>向上搜索</p><p>输入问号（?）之后接着输入需要搜索的内容。</p></li><li><p>-i 忽略搜索时的大小写</p></li><li><p>-N 显示每行的行号</p></li></ul><h3 id="用默认编辑器打开"><a href="#用默认编辑器打开" class="headerlink" title="用默认编辑器打开"></a>用默认编辑器打开</h3><p>按 <code>v</code> 键，就会将正在阅读的文件在默认编辑器（我的是用vim打开）中打开，然后就可以对文件进行各种编辑操作了。</p><h2 id="head"><a href="#head" class="headerlink" title="head"></a>head</h2><p>-n&lt;行数&gt; 显示的行数</p><h2 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h2><p>-f 循环读取<br>-n&lt;行数&gt; 显示行数</p><h2 id="date"><a href="#date" class="headerlink" title="date"></a>date</h2><p><strong>注意哟：</strong></p><p>时间：注意闰秒的问题，最好还是用有符号数来表示，因为要涉及到时间的运算。</p><p>C 语言中有一组这样的数字：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">include &lt;stdint.h&gt;</span><br><span class="line"></span><br><span class="line">int8_t</span><br><span class="line">int16_t</span><br><span class="line">int32_t</span><br><span class="line">int64_t / uint64_t</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ date +%F</span><br><span class="line">2019-05-28</span><br><span class="line">➜  ~ date</span><br><span class="line">2019年 5月28日 星期二 09时32分57秒 CST</span><br><span class="line">➜  ~ </span><br></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>%H : 小时(00..23)<br>%M : 分钟(00..59)<br>%S : 秒(00..61)<br>%X : 相当于 %H:%M:%S %d : 日 (01..31)<br>%m : 月份 (01..12)<br>%Y : 完整年份 (0000..9999) %F : 相当于 %Y-%m-%d</p><h3 id="设置时间"><a href="#设置时间" class="headerlink" title="设置时间"></a>设置时间</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">date -s # 设置当前时间，只有root权限才能设置，其他只能查看。</span><br><span class="line">date -s 20080523 # 设置成20080523，这样会把具体时间设置成空00:00:00 date -s 01:01:01 //设置具体时间，不会对日期做更改</span><br><span class="line">date -s “01:01:01 2008-05-23′′ # 这样可以设置全部时间</span><br><span class="line">date -s “01:01:01 20080523′′ # 这样可以设置全部时间</span><br><span class="line">date -s “2008-05-23 01:01:01′′ # 这样可以设置全部时间</span><br><span class="line">date -s “20080523 01:01:01′′ # 这样可以设置全部时间</span><br></pre></td></tr></table></figure><h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><p>时间-&gt;时间戳：date +%s </p><p>时间戳-&gt;时间：date -d@1508749502 </p><blockquote><p>Unix时间戳(英文为Unix epoch, Unix time, POSIX time 或 Unix timestamp)是从1970年1月1日(UTC/GMT的<br>午夜)开始所经过的秒数，不考虑闰秒。</p></blockquote><h2 id="cal"><a href="#cal" class="headerlink" title="cal"></a>cal</h2><p>日历。</p><p>-3 显示系统前一个月，当前月，下一个月的月历<br>-j 显示在当年中的第几天(一年日期按天算，从1月1号算起，默认显示当前月在一年中的天数)<br>-y 显示当前年份的日历</p><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>常用选项：-name</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -name 1.txt &gt; ~/result.txt</span><br></pre></td></tr></table></figure><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>在文件中搜索字符串，将找到的行打印出来。</p><p>语法：<code>grep [选项] 搜寻字符串 文件</code></p><p>我常用：<code>ps aux | grep test</code></p><p>-i :忽略大小写的不同，所以大小写视为相同<br>-n :顺便输出行号<br>-v :反向选择，亦即显示出没有 ‘搜寻字符串’ 内容的那一行</p><h2 id="zip-amp-unzip"><a href="#zip-amp-unzip" class="headerlink" title="zip &amp; unzip"></a>zip &amp; unzip</h2><p>将目录或文件压缩成zip格式。</p><p>选项：-r 递归处理，将指定目录下的所有文件和子目录一并处理。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将test2目录压缩:zip test2.zip test2/* 解压到tmp目录:unzip test2.zip -d /tmp</span><br></pre></td></tr></table></figure><h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><p><a href="https://linux.cn/article-6679-1.html">tar 命令使用介绍</a></p><p>参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-c :建立一个压缩文件的参数指令(create 的意思);</span><br><span class="line">-x :解开一个压缩文件的参数指令!</span><br><span class="line">-t :查看 tarfile 里面的文件!</span><br><span class="line">-z :是否同时具有 gzip 的属性?亦即是否需要用 gzip 压缩?</span><br><span class="line">-j :是否同时具有 bzip2 的属性?亦即是否需要用 bzip2 压缩?</span><br><span class="line">-v :压缩的过程中显示文件!这个常用，但不建议用在背景执行过程! -f :使用档名，请留意，在 f 之后要立即接档名喔!不要再加参数!</span><br><span class="line">-C : 解压到指定目录</span><br></pre></td></tr></table></figure><h2 id="bc"><a href="#bc" class="headerlink" title="bc"></a>bc</h2><p>bc命令可以很方便的进行浮点运算。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ bc</span><br><span class="line">bc 1.06</span><br><span class="line">Copyright 1991-1994, 1997, 1998, 2000 Free Software Foundation, Inc.</span><br><span class="line">This is free software with ABSOLUTELY NO WARRANTY.</span><br><span class="line">For details type `warranty&#x27;. </span><br><span class="line">1.1 + 2.2</span><br><span class="line">3.3</span><br></pre></td></tr></table></figure><h2 id="uname"><a href="#uname" class="headerlink" title="uname"></a>uname</h2><p>uname用来获取电脑和操作系统的相关信息。name可显示linux主机所用的操作系统的版本、硬件的名称等基本信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ uname -r</span><br><span class="line">18.6.0</span><br><span class="line">➜  ~ uname   </span><br><span class="line">Darwin</span><br><span class="line">➜  ~ uname -a</span><br><span class="line">Darwin ahoj-MBP.local 18.6.0 Darwin Kernel Version 18.6.0: Thu Apr 25 23:16:27 PDT 2019; root:xnu-4903.261.4~2/RELEASE_X86_64 x86_64</span><br><span class="line">➜  ~ </span><br></pre></td></tr></table></figure><hr><blockquote><p>更多学习资料：<br><a href="https://linux.cn/article-9597-1.html">在 Linux 下 9 个有用的 touch 命令示例</a><br><a href="https://www.ibm.com/developerworks/cn/aix/library/au-badunixhabits.html">UNIX 高手的 10 个习惯</a><br><a href="https://linux.cn/article-8722-1.html">教你如何比谷歌搜索更快速有效地利用 man</a><br><a href="https://linux.cn/article-8766-1.html">cp 命令两个高效的用法</a><br><a href="https://linux.cn/article-2687-1.html?pr">Linux cp 命令的15个示例 - 创建文件和目录的副本</a><br><a href="https://linux.cn/article-6679-1.html">tar 命令使用介绍</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端-使用Nginx代理解决跨域请求问题</title>
      <link href="/2019/05/26/%E5%89%8D%E7%AB%AF-%E4%BD%BF%E7%94%A8Nginx%E4%BB%A3%E7%90%86%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E9%97%AE%E9%A2%98/"/>
      <url>/2019/05/26/%E5%89%8D%E7%AB%AF-%E4%BD%BF%E7%94%A8Nginx%E4%BB%A3%E7%90%86%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>写一个活动用的小页面，结果遇到跨域问题，之前遇到跨域都是学长在后端设置个头解决掉，这次学长有事情，让我用nginx先试试解决。</p><span id="more"></span><h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 nginx</span></span><br><span class="line">brew install nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动</span></span><br><span class="line">sudo nginx# nginx就安装好了，可以在浏览器访问了，默认端口为8080</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新启动</span></span><br><span class="line">sudo nginx -s reload</span><br></pre></td></tr></table></figure><h3 id="nginx-配置文件"><a href="#nginx-配置文件" class="headerlink" title="nginx 配置文件"></a>nginx 配置文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><h2 id="配置-nginx-解决跨域问题"><a href="#配置-nginx-解决跨域问题" class="headerlink" title="配置 nginx 解决跨域问题"></a>配置 nginx 解决跨域问题</h2><p><img src="https://raw.githubusercontent.com/ahojcn/blog-img/master/img20190526204339.png"></p><hr><blockquote><p>记录在此，记录让希望不失望，以便日后检索回忆。</p><p>参考：<br><a href="https://www.cnblogs.com/tandaxia/p/8810648.html">Mac安装nginx配置过程</a><br><a href="https://segmentfault.com/a/1190000015597029">不要再问我跨域的问题了</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue-打包静态资源路径不正确</title>
      <link href="/2019/05/16/Vue-%E6%89%93%E5%8C%85%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%B7%AF%E5%BE%84%E4%B8%8D%E6%AD%A3%E7%A1%AE/"/>
      <url>/2019/05/16/Vue-%E6%89%93%E5%8C%85%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%B7%AF%E5%BE%84%E4%B8%8D%E6%AD%A3%E7%A1%AE/</url>
      
        <content type="html"><![CDATA[<p>Vue项目build后放在服务器的根目录下可以正常看，但是放在别的目录就不能正常显示了。console显示的是找不到那些css、js文件。看了下路径发现是根路径，在webpack中修改下配置就好。</p><span id="more"></span><h3 id="css、js路径不对"><a href="#css、js路径不对" class="headerlink" title="css、js路径不对"></a>css、js路径不对</h3><p>config/index.js，将其中的assetsPublicPath值改为<code>./</code></p><p><img src="https://raw.githubusercontent.com/ahojcn/blog-img/master/img20190516205351.png"></p><h3 id="找不到css中引用的图片资源"><a href="#找不到css中引用的图片资源" class="headerlink" title="找不到css中引用的图片资源"></a>找不到css中引用的图片资源</h3><p>在build/utils.js中添加下面这句</p><p><img src="https://raw.githubusercontent.com/ahojcn/blog-img/master/img20190516205234.png"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-GDB调试</title>
      <link href="/2019/05/05/Linux-GDB%E8%B0%83%E8%AF%95/"/>
      <url>/2019/05/05/Linux-GDB%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>GDB（GNU Debugger）是UNIX及UNIX-like下的强大调试工具，可以调试ada, c, c++, asm, minimal, d, fortran, objective-c, go, java,pascal等语言。</p><p>笔记：微信公众号，编程珠玑。</p><span id="more"></span><h2 id="哪些程序可以被调试"><a href="#哪些程序可以被调试" class="headerlink" title="哪些程序可以被调试"></a>哪些程序可以被调试</h2><p>对于C程序来说，需要在编译时加上-g参数，保留调试信息，否则不能使用GDB进行调试。<br>但如果不是自己编译的程序，并不知道是否带有-g参数，如何判断一个文件是否带有调试信息呢？</p><h3 id="gdb-file-name"><a href="#gdb-file-name" class="headerlink" title="gdb file_name"></a>gdb file_name</h3><ul><li><p>不能调试。</p><p><img src="https://raw.githubusercontent.com/ahojcn/blog-img/master/imgwiki-Linux-GDB-1.png" alt="Linux-GDB-1"></p></li><li><p>可以调试</p><p><img src="https://raw.githubusercontent.com/ahojcn/blog-img/master/imgwiki-Linux-GDB-2.png"></p></li></ul><h3 id="2-readelf-查看段信息"><a href="#2-readelf-查看段信息" class="headerlink" title="2. readelf 查看段信息"></a>2. readelf 查看段信息</h3><ul><li><p>不能调试</p><p><img src="https://raw.githubusercontent.com/ahojcn/blog-img/master/imgwiki-Linux-GDB-3.png"></p></li><li><p>可以调试</p><p><img src="https://raw.githubusercontent.com/ahojcn/blog-img/master/imgwiki-Linux-GDB-4.png"></p></li></ul><h2 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h2><h3 id="调试无参程序"><a href="#调试无参程序" class="headerlink" title="调试无参程序"></a>调试无参程序</h3><ol><li><code>gdb file_name</code> </li><li> <code>run(简写r)</code> 运行。</li></ol><h3 id="调试带参程序"><a href="#调试带参程序" class="headerlink" title="调试带参程序"></a>调试带参程序</h3><ol><li><code>gdb file_name</code></li><li><code>run 参数</code></li></ol><p>或者</p><ol><li><code>gdb file_name</code></li><li><code>set args 参数</code></li><li><code>run</code>或<code>r</code></li></ol><p><img src="https://raw.githubusercontent.com/ahojcn/blog-img/master/imgwiki-Linux-GDB-7.png"></p><p><img src="https://raw.githubusercontent.com/ahojcn/blog-img/master/imgwiki-Linux-GDB-6.png"></p><p>list（可简写为l），它可以将源码列出来。</p><h2 id="调试-core-文件"><a href="#调试-core-文件" class="headerlink" title="调试 core 文件"></a>调试 core 文件</h2><p>当程序core dump时，可能会产生core文件，它能够很大程序帮助我们定位问题。前提是系统没有限制core文件的产生。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -a# 查看</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ahojcn/blog-img/master/img20190505191513.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">core file size          (blocks, -c) 0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果结果是0，即便程序core dump了也不会有core文件留下。</span></span><br></pre></td></tr></table></figure><p><strong>取消系统限制：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ulimit -c unlimied # 取消限制core文件大小。</span><br><span class="line">ulimit -c 10       # 设置最大大小，单位为块，一块默认为512字节</span><br></pre></td></tr></table></figure><p><strong>调试 core dump 文件：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb 程序文件名 core文件名</span><br></pre></td></tr></table></figure><h2 id="调试已运行程序"><a href="#调试已运行程序" class="headerlink" title="调试已运行程序"></a>调试已运行程序</h2><p>使用ps命令找到进程id</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep 进程名</span><br></pre></td></tr></table></figure><h3 id="attach方式"><a href="#attach方式" class="headerlink" title="attach方式"></a>attach方式</h3><p>假设获取到进程id为20829，则用下面的方式调试进程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb</span><br><span class="line">(gdb) attach 20829</span><br></pre></td></tr></table></figure><p>如果有下面的错误提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Could not attach to process.  If your uid matches the uid of the target</span><br><span class="line">process, check the setting of /proc/sys/kernel/yama/ptrace_scope, or try</span><br><span class="line">again as the root user.  For more details, see /etc/sysctl.d/10-ptrace.conf</span><br><span class="line">ptrace: Operation not permitted.</span><br></pre></td></tr></table></figure><p>解决方法，切换到root用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/sysctl.d/10-ptrace.conf</span></span><br><span class="line">kernel.yama.ptrace_scope = 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改为</span></span><br><span class="line">kernel.yama.ptrace_scope = 0</span><br></pre></td></tr></table></figure><h3 id="直接调试相关id进程"><a href="#直接调试相关id进程" class="headerlink" title="直接调试相关id进程"></a>直接调试相关id进程</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb program pid</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">or</span></span><br><span class="line">gdb hello --pid 20829</span><br></pre></td></tr></table></figure><h4 id="已运行程序没有调试信息"><a href="#已运行程序没有调试信息" class="headerlink" title="已运行程序没有调试信息"></a>已运行程序没有调试信息</h4><p>为了节省磁盘空间，已经运行的程序通常没有调试信息。但如果又不能停止当前程序重新启动调试，那怎么办呢？还有办法，那就是同样的代码，再编译出一个带调试信息的版本。然后使用和前面提到的方式操作。对于attach方式，在attach之前，使用file命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb</span></span><br><span class="line">(gdb) file hello</span><br><span class="line">Reading symbols from hello...done.</span><br><span class="line">(gdb)attach 20829</span><br></pre></td></tr></table></figure><hr><h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><h3 id="查看断点"><a href="#查看断点" class="headerlink" title="查看断点"></a>查看断点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info breakpoints</span><br></pre></td></tr></table></figure><h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><ol><li><p>根据行号设置断点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b 9  #break 可简写为b</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者</span></span><br><span class="line">b test.c:9</span><br></pre></td></tr></table></figure></li><li><p>根据函数名设置断点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b fun_name</span><br></pre></td></tr></table></figure></li><li><p>根据条件设置断点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">break test.c:23 if b==0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当在b等于0时，程序将会在第23行断住。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">condition有着类似的作用，假设上面的断点号为1</span></span><br><span class="line">condition 1 b==0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">b等于0时，产生断点1。</span></span><br></pre></td></tr></table></figure></li><li><p>根据规则设置断点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rbreak printNum*</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对所有调用printNum函数都设置断点</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下面是对所有函数设置断点</span></span><br><span class="line">rbreak . </span><br><span class="line">rbreak test.c:. # 对test.c中的所有函数设置断点</span><br><span class="line">rbreak test.c:^print # 对以print开头的函数设置断点</span><br></pre></td></tr></table></figure></li><li><p>设置临时断点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tbreak test.c:l0  # 在第10行设置临时断点</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">某处的断点只想生效一次，那么可以设置临时断点，这样断点后面就不复存在了</span></span><br></pre></td></tr></table></figure></li><li><p>跳过多次设置断点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ignore next 30 hits</span></span><br><span class="line">ignore 1 30</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1是要忽略的断点号，可以通过前面的方式查找到，30是需要跳过的次数。这样设置之后，会跳过前面30次。</span></span><br></pre></td></tr></table></figure></li><li><p>根据表达式值变化产生断点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">有时候我们需要观察某个值或表达式，知道它什么时候发生变化了，这个时候我们可以借助watch命令。</span></span><br><span class="line">watch a</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这个时候，让程序继续运行，如果a的值发生变化，则会打印相关内容</span></span><br><span class="line">Hardware watchpoint 2: a</span><br><span class="line">Old value = 12</span><br><span class="line">New value = 11</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">但是这里要特别注意的是，程序必须运行起来，否则会出现：</span></span><br><span class="line">No symbol &quot;a&quot; in current context.</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">因为程序没有运行，当前上下文也就没有相关变量信息。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rwatch和awatch同样可以设置观察点，前者是当变量值被读时断住，后者是被读或者被改写时断住。</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="禁用断点"><a href="#禁用断点" class="headerlink" title="禁用断点"></a>禁用断点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">disable  # 禁用所有断点</span><br><span class="line">disable bnum # 禁用标号为bnum的断点</span><br><span class="line">enable  # 启用所有断点</span><br><span class="line">enable bnum # 启用标号为bnum的断点</span><br><span class="line">enable delete bnum  # 启动标号为bnum的断点，并且在此之后删除该断点</span><br></pre></td></tr></table></figure><h3 id="清除断点"><a href="#清除断点" class="headerlink" title="清除断点"></a>清除断点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">clear   # 删除当前行所有breakpoints</span><br><span class="line">clear function  # 删除函数名为function处的断点</span><br><span class="line">clear filename:function # 删除文件filename中函数function处的断点</span><br><span class="line">clear lineNum # 删除行号为lineNum处的断点</span><br><span class="line">clear f:lename：lineNum # 删除文件filename中行号为lineNum处的断点</span><br><span class="line">delete  # 删除所有breakpoints,watchpoints和catchpoints</span><br><span class="line">delete bnum # 删除断点号为bnum的断点</span><br></pre></td></tr></table></figure><hr><h2 id="查看变量"><a href="#查看变量" class="headerlink" title="查看变量"></a>查看变量</h2><h3 id="打印基本类型变量，数组，字符数组"><a href="#打印基本类型变量，数组，字符数组" class="headerlink" title="打印基本类型变量，数组，字符数组"></a>打印基本类型变量，数组，字符数组</h3><p><code>print（可简写为p）</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p a</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = 10</span></span><br><span class="line">(gdb) p b</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2 = &#123;1, 2, 3, 5&#125;</span></span><br><span class="line">(gdb) p c</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">3 = <span class="string">&quot;hello,gdb&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">有时候，多个函数或者多个文件会有同一个变量名，这个时候可以在前面加上文件名或者函数名来区分：</span></span><br><span class="line">(gdb) p &#x27;testGdb.h&#x27;::a</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = 11</span></span><br><span class="line">(gdb) p &#x27;main&#x27;::b</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2 = &#123;1, 2, 3, 5&#125;</span></span><br></pre></td></tr></table></figure><h3 id="打印指针指向内容"><a href="#打印指针指向内容" class="headerlink" title="打印指针指向内容"></a>打印指针指向内容</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p d</span><br><span class="line">1 = (int *) 0x602010</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印指针指向的内容</span></span><br><span class="line">(gdb) p *d</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2 = 0</span></span><br><span class="line">(gdb) p *d@10</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">3 = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用*只能打印第一个值，如果要打印多个值，后面跟上@并加上要打印的长度。或者@后面跟上变量值</span></span><br><span class="line">(gdb) p *d@a</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2 = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">a的值为10，并且是作为整型指针数据长度，因此后面可以直接跟着a，也可以打印出所有内容。</span></span><br></pre></td></tr></table></figure><p><strong>$</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">$可表示上一个变量，而假设此时有一个链表linkNode，它有next成员代表下一个节点，则可使用下面方式不断打印链表内容：</span></span><br><span class="line">(gdb) p *linkNode</span><br><span class="line">(这里显示linkNode节点内容)</span><br><span class="line">(gdb) p *$.next</span><br><span class="line">(这里显示linkNode节点下一个节点的内容)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果想要查看前面数组的内容，你可以将下标一个一个累加，还可以定义一个类似UNIX环境变量，例如：</span></span><br><span class="line">(gdb) set $index=0</span><br><span class="line">(gdb) p b[$index++]</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">11 = 1</span></span><br><span class="line">(gdb) p b[$index++]</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">12 = 2</span></span><br><span class="line">(gdb) p b[$index++]</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">13 = 3</span></span><br></pre></td></tr></table></figure><h3 id="按照特定格式打印变量"><a href="#按照特定格式打印变量" class="headerlink" title="按照特定格式打印变量"></a>按照特定格式打印变量</h3><ul><li>x 按十六进制格式显示变量。</li><li>d 按十进制格式显示变量。</li><li>u 按十六进制格式显示无符号整型。</li><li>o 按八进制格式显示变量。</li><li>t 按二进制格式显示变量。</li><li>a 按十六进制格式显示变量。</li><li>c 按字符格式显示变量。</li><li>f 按浮点数格式显示变量。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p c</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">18 = <span class="string">&quot;hello,shouwang&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看它的十六进制格式打印</span></span><br><span class="line">(gdb) p/x c</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">19 = &#123;0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x73, 0x68, 0x6f, 0x75, 0x77, 0x61, 0x6e, 0x67, 0x0&#125;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果想用这种方式查看浮点数的二进制格式是怎样的是不行的，因为直接打印它首先会被转换成整型，因此最终会得到8</span></span><br><span class="line">(gdb) p e</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = 8.5</span></span><br><span class="line">(gdb) p/t e</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2 = 1000</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">那么就需要另外一种查看方式了。</span></span><br></pre></td></tr></table></figure><h3 id="查看内存内容"><a href="#查看内存内容" class="headerlink" title="查看内存内容"></a>查看内存内容</h3><p>examine(简写为x)可以用来查看内存地址中的值。语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x/[n][f][u] addr</span><br></pre></td></tr></table></figure><ul><li>n 表示要显示的内存单元数，默认值为1</li><li>f 表示要打印的格式，前面已经提到了格式控制字符</li><li>u 要打印的单元长度</li><li>addr 内存地址</li></ul><p>单元类型常见有如下：</p><ul><li>b 字节</li><li>h 半字，即双字节</li><li>w 字，即四字节</li><li>g 八字节</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把<span class="built_in">float</span>变量e按照二进制方式打印，并且打印单位是一字节：</span></span><br><span class="line">(gdb) x/4tb &amp;e</span><br><span class="line">0x7fffffffdbd4:    00000000    00000000    00001000    01000001</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">看到，变量e的四个字节都以二进制的方式打印出来了。</span></span><br></pre></td></tr></table></figure><h3 id="自动显示变量内容"><a href="#自动显示变量内容" class="headerlink" title="自动显示变量内容"></a>自动显示变量内容</h3><p>假设希望程序断住时，就显示某个变量的值，可以使用display命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) display e</span><br><span class="line">1: e = 8.5</span><br></pre></td></tr></table></figure><p>那么每次程序断住时，就会打印e的值。要查看哪些变量被设置了display，可以使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb)info display</span><br><span class="line">Auto-display expressions now in effect:</span><br><span class="line">Num Enb Expression</span><br><span class="line">1:   y  b</span><br><span class="line">2:   y  e</span><br></pre></td></tr></table></figure><p>想要清除可以使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">delete display num # num为前面变量前的编号,不带num时清除所有。</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者</span></span><br><span class="line">disable display num</span><br></pre></td></tr></table></figure><h3 id="查看寄存器内容"><a href="#查看寄存器内容" class="headerlink" title="查看寄存器内容"></a>查看寄存器内容</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb)info registers</span><br><span class="line">rax            0x0    0</span><br><span class="line">rbx            0x0    0</span><br><span class="line">rcx            0x7ffff7dd1b00    140737351850752</span><br><span class="line">rdx            0x0    0</span><br><span class="line">rsi            0x7ffff7dd1b30    140737351850800</span><br><span class="line">rdi            0xffffffff    4294967295</span><br><span class="line">rbp            0x7fffffffdc10    0x7fffffffdc10</span><br></pre></td></tr></table></figure><hr><h2 id="单步调试"><a href="#单步调试" class="headerlink" title="单步调试"></a>单步调试</h2><h3 id="单步执行-next"><a href="#单步执行-next" class="headerlink" title="单步执行-next"></a>单步执行-next</h3><p>不会进入到函数内部。</p><p>next命令（可简写为n）用于在程序断住后，继续执行下一条语句，假设已经启动调试，并在第12行停住，如果要继续执行，则使用n执行下一条语句，如果后面跟上数字num，则表示执行该命令num次，就达到继续执行n行的效果了。</p><h3 id="单步进入-step"><a href="#单步进入-step" class="headerlink" title="单步进入-step"></a>单步进入-step</h3><p>跟踪函数内部的情况，可以使用step命令（可简写为s），它可以单步跟踪到函数内部，但前提是该函数有调试信息并且有源码信息。</p><p>s命令会尝试进入函数，但是如果没有该函数源码，需要跳过该函数执行，可使用finish命令，继续后面的执行。如果没有函数调用，s的作用与n的作用并无差别，仅仅是继续执行下一行。它后面也可以跟数字，表明要执行的次数。</p><p>当然它还有一个选项，用来设置当遇到没有调试信息的函数，s命令是否跳过该函数，而执行后面的。默认情况下，它是会跳过的，即step-mode值是off：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) show step-mode </span><br><span class="line">Mode of the step operation is off.</span><br><span class="line">(gdb) set step-mode on</span><br><span class="line">(gdb) set step-mode off</span><br></pre></td></tr></table></figure><p><strong>还有一个与step相关的命令是stepi（可简写为si），它与step不同的是，每次执行一条机器指令：</strong></p><h3 id="继续执行到下一个断点-continue"><a href="#继续执行到下一个断点-continue" class="headerlink" title="继续执行到下一个断点-continue"></a>继续执行到下一个断点-continue</h3><p>我们可能打了多处断点，或者断点打在循环内，这个时候，想跳过这个断点，甚至跳过多次断点继续执行该怎么做呢？可以使用continue命令（可简写为c）或者fg，它会继续执行程序，直到再次遇到断点处。</p><h3 id="继续运行到指定位置-until"><a href="#继续运行到指定位置-until" class="headerlink" title="继续运行到指定位置-until"></a>继续运行到指定位置-until</h3><p>假如我们在25行停住了，现在想要运行到29行停住，就可以使用until命令（可简写为u）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb gdbStep</span></span><br><span class="line">(gdb)b 25</span><br><span class="line">(gdb)run</span><br><span class="line">(gdb) u 29</span><br><span class="line">it will calc a + b</span><br><span class="line">3 + 7 = 10</span><br><span class="line">main () at gdbStep.c:29</span><br><span class="line">29        count(c);</span><br></pre></td></tr></table></figure><h3 id="跳过执行–skip"><a href="#跳过执行–skip" class="headerlink" title="跳过执行–skip"></a>跳过执行–skip</h3><p>skip可以在step时跳过一些不想关注的函数或者某个文件的代码:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb gdbStep</span></span><br><span class="line">(gdb) b 27</span><br><span class="line">Breakpoint 1 at 0x4005e4: file gdbStep.c, line 27.</span><br><span class="line">(gdb) skip function add    #step时跳过add函数</span><br><span class="line">Function add will be skipped when stepping.</span><br><span class="line">(gdb) info skip   #查看step情况</span><br><span class="line">Num     Type           Enb What</span><br><span class="line">1       function       y   add</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /home/hyb/workspaces/gdb/gdbStep </span><br><span class="line">it will calc a + b</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at gdbStep.c:27</span><br><span class="line">27        int c = add(a,b);</span><br><span class="line">(gdb) s</span><br><span class="line">28        printf(&quot;%d + %d = %d\n&quot;,a,b,c);</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>可以看到，再使用skip之后，使用step将不会进入add函数。<br>step也后面也可以跟文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb)skip file gdbStep.c</span><br></pre></td></tr></table></figure><p>其他相关命令：</p><ul><li>skip delete [num] 删除skip</li><li>skip enable [num] 使能skip</li><li>skip disable [num] 去使能skip</li></ul><p>其中num是前面通过info skip看到的num值，上面可以带或不带该值，如果不带num，则针对所有skip，如果带上了，则只针对某一个skip。</p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nao机器人-学习资料</title>
      <link href="/2019/04/23/Nao%E6%9C%BA%E5%99%A8%E4%BA%BA-%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
      <url>/2019/04/23/Nao%E6%9C%BA%E5%99%A8%E4%BA%BA-%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/</url>
      
        <content type="html"><![CDATA[<p>在这里整理了一些关于Nao机器人的学习资料。</p><span id="more"></span><p><a href="http://www.naoqi.net/">Naoqi之家<a href="http://www.naoqi.net/">http://www.naoqi.net/</a></a></p><p><a href="http://doc.aldebaran.com/2-5/naoqi/index.html">NaoAPIs<a href="http://doc.aldebaran.com/2-5/naoqi/index.html">http://doc.aldebaran.com/2-5/naoqi/index.html</a></a></p><p><a href="https://cxx0822.github.io/">cxx的博客<a href="https://cxx0822.github.io/">https://cxx0822.github.io</a></a></p><p><a href="https://github.com/ZhouJiaHuan">ZhouJiaHuan的GitHub<a href="https://github.com/ZhouJiaHuan">https://github.com/ZhouJiaHuan</a></a></p><p><a href="https://blog.csdn.net/zz683693/article/category/6966040">zz683693<a href="https://blog.csdn.net/zz683693/article/category/6966040">https://blog.csdn.net/zz683693/article/category/6966040</a></a></p><p><a href="http://www.pudn.com/Download/item/id/3283143.html">Nao机器人接力赛<a href="http://www.pudn.com/Download/item/id/3283143.html">http://www.pudn.com/Download/item/id/3283143.html</a></a></p><h2 id="BHuman"><a href="#BHuman" class="headerlink" title="BHuman"></a>BHuman</h2><p><a href="https://blog.csdn.net/qq_34062822/article/category/7666151">大神博客1<a href="https://blog.csdn.net/qq_34062822/article/category/7666151">https://blog.csdn.net/qq_34062822/article/category/7666151</a></a></p><p><a href="https://blog.csdn.net/weixin_42895991/article/category/8542835">大神博客2<a href="https://blog.csdn.net/weixin_42895991/article/category/8542835">https://blog.csdn.net/weixin_42895991/article/category/8542835</a></a></p><p><a href="https://blog.csdn.net/liuying_1001/article/category/836993">liuying_1001的博客<a href="https://blog.csdn.net/liuying_1001/article/category/836993">https://blog.csdn.net/liuying_1001/article/category/836993</a></a></p><p><a href="https://sisterchen.github.io/">sisterchen的博客<a href="https://sisterchen.github.io/">https://sisterchen.github.io/</a></a></p><hr>]]></content>
      
      
      <categories>
          
          <category> Nao机器人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nao机器人 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Database-Linux下MySQL停止和重启</title>
      <link href="/2019/04/23/Database-Linux%E4%B8%8BMySQL%E5%81%9C%E6%AD%A2%E5%92%8C%E9%87%8D%E5%90%AF/"/>
      <url>/2019/04/23/Database-Linux%E4%B8%8BMySQL%E5%81%9C%E6%AD%A2%E5%92%8C%E9%87%8D%E5%90%AF/</url>
      
        <content type="html"><![CDATA[<p>嘿嘿，转载别人的文章，因为常用到，怕忘了。</p><span id="more"></span><p>一、启动方式<br>1、使用linux命令service 启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysqld start</span><br></pre></td></tr></table></figure><p>2、使用 mysqld 脚本启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/inint.d/mysqld start</span><br></pre></td></tr></table></figure><p>3、使用 safe_mysqld 启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">safe_mysqld&amp;</span><br></pre></td></tr></table></figure><p>二、停止<br>1、使用 service 启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysqld stop</span><br></pre></td></tr></table></figure><p>2、使用 mysqld 脚本启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/inint.d/mysqld stop</span><br></pre></td></tr></table></figure><p>3、 mysqladmin shutdown</p><p>三、重启<br>1、使用 service 启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysqld restart</span><br></pre></td></tr></table></figure><p>2、使用 mysqld 脚本启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/inint.d/mysqld restart</span><br></pre></td></tr></table></figure><p><strong>PS：</strong>查看mysql端口是否已经使用，使用<code>netstat -anp </code>命令查看服务器端口使用情况。</p><hr>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Nao机器人】BHuman之SimRobot</title>
      <link href="/2019/04/21/Nao%E6%9C%BA%E5%99%A8%E4%BA%BA-BHuman%E4%B9%8BSimRobot/"/>
      <url>/2019/04/21/Nao%E6%9C%BA%E5%99%A8%E4%BA%BA-BHuman%E4%B9%8BSimRobot/</url>
      
        <content type="html"><![CDATA[<p>SimRobot 用来校准和模拟机器人在比赛中的行为。但是需要注意的一点是，SimRobot 中模拟的场景是不真实的。更具体的我再去看看官方文档。<br><code>BHumanCodeRelease-coderelease2017/Build/Linux/SimRobot/Release</code>。</p><span id="more"></span><p><img src="https://i.loli.net/2019/04/21/5cbb548e481cc.png"></p><p><img src="https://i.loli.net/2019/04/21/5cbb47064276f.png" alt="SimRobot-1"></p><h2 id="基本的东西"><a href="#基本的东西" class="headerlink" title="基本的东西"></a>基本的东西</h2><p>该软件的环境在bhuman的Config/Scenes目录下，后缀为ros2的文件。其中 RemoteRobot.ros2 是远程调试机器人时使用的环境配置，BH2016 为模拟比赛用的环境配置。</p><p><img src="https://i.loli.net/2019/04/21/5cbb51be0eed3.png"></p><p>点击菜单栏的Scene Graph按钮，可调出各种子模块。</p><p><img src="https://i.loli.net/2019/04/21/5cbb529223b0e.png" alt="SimRobot-3"></p><h2 id="ros-文件"><a href="#ros-文件" class="headerlink" title=".ros 文件"></a>.ros 文件</h2><p>.ros 文件使用 XML 语言来描述场地信息，可以对场地信息进行修改，包括增加和删除场地中的机器人，增加场地中的球的个数等等。</p><p><img src="https://i.loli.net/2019/04/21/5cbb53874aed3.png" alt="SimRobot-4"></p><h2 id="控制台命令"><a href="#控制台命令" class="headerlink" title="控制台命令"></a>控制台命令</h2><p>双击Scene Graph的Console即可调出控制台，可以查看机器人的传感器参数及各种状态。</p><p>两个常用命令：</p><h3 id="gc"><a href="#gc" class="headerlink" title="gc"></a>gc</h3><p>该指令控制仿真的游戏状态。例如输入<code>gc playing</code>后回车，可以开始比赛，双击Robocup即可看到比赛状态。</p><h3 id="vd"><a href="#vd" class="headerlink" title="vd"></a>vd</h3><p>该指令用于查看各机器人的representation等其他参数。<br>例如输入<code>vd representation:BallModel</code>可以查看机器人自己认为的球模型的各种参数。</p><p>可以调用<code>theBallModel.estimate.position.x()</code>来获得球相对于机器人的位置，可以在角文件中作为条件判断让机器人作出下一行动。</p><hr>]]></content>
      
      
      <categories>
          
          <category> Nao机器人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nao机器人 </tag>
            
            <tag> BHuman </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Nao机器人】BHuman中的类-MarkedLine</title>
      <link href="/2019/04/20/Nao%E6%9C%BA%E5%99%A8%E4%BA%BA-BHuman%E4%B8%AD%E7%9A%84MarkedLine/"/>
      <url>/2019/04/20/Nao%E6%9C%BA%E5%99%A8%E4%BA%BA-BHuman%E4%B8%AD%E7%9A%84MarkedLine/</url>
      
        <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Src/Representations/Perception/FieldFeatures/FieldMarker.h</span><br></pre></td></tr></table></figure><p>在这个文件中表示了在 bhuman 中标记线的一些方法。<br>MarkedLine(线)、MarkedIntersection(交点)、MarkedPoint(点)。<br>线的相交分为 X、L、T 型，这个很形象。其中，<code>T includes L; X includes T and L </code>。</p><p>关于线的交叉点结构在下面这个文件中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Src/Representations/Perception/FieldPercepts/FieldLineIntersections.h</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="MarkedLine"><a href="#MarkedLine" class="headerlink" title="MarkedLine"></a>MarkedLine</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">STREAMABLE</span>(MarkedLine,</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    ___________3__________</span></span><br><span class="line"><span class="comment">   |      4|______|5      |</span></span><br><span class="line"><span class="comment">   |           6          |</span></span><br><span class="line"><span class="comment">   |2                     |</span></span><br><span class="line"><span class="comment">   |                      |</span></span><br><span class="line"><span class="comment">   |___________1__________|</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="built_in">ENUM</span>(LineMarker,</span><br><span class="line">  &#123;,</span><br><span class="line">    midLine, <span class="comment">// --&gt; 1</span></span><br><span class="line">    sideLine, <span class="comment">// --&gt; 2</span></span><br><span class="line">    groundLine, <span class="comment">// --&gt; 3</span></span><br><span class="line">    sidePenaltyL, <span class="comment">// --&gt; 4</span></span><br><span class="line">    sidePenaltyR, <span class="comment">// --&gt; 5</span></span><br><span class="line">    groundPenalty, <span class="comment">// --&gt; 6</span></span><br><span class="line"></span><br><span class="line">    firstLineMarkerOther,</span><br><span class="line">    otherSideLine = firstLineMarkerOther,</span><br><span class="line">    otherGroundLine,</span><br><span class="line">    otherSidePenaltyL,</span><br><span class="line">    otherSidePenaltyR,</span><br><span class="line">    otherGroundPenalty,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="type">static</span> LineMarker <span class="built_in">mirror</span>(<span class="type">const</span> LineMarker marker);    <span class="comment">// mirror 镜子</span></span><br><span class="line">  LineMarker <span class="built_in">mirror</span>() <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">MarkedLine</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="built_in">MarkedLine</span>(<span class="type">unsigned</span> line, LineMarker marker);</span><br><span class="line">  <span class="type">void</span> <span class="built_in">draw</span>() <span class="type">const</span>,</span><br><span class="line"></span><br><span class="line">  (<span class="type">unsigned</span>) lineIndex,</span><br><span class="line">  (LineMarker)(numOfLineMarkers) marker,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">MarkedLine::MarkedLine</span><span class="params">(<span class="type">unsigned</span> line, LineMarker marker)</span> : lineIndex(line), marker(marker) &#123;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="MarkedIntersection-交点处的标记方式"><a href="#MarkedIntersection-交点处的标记方式" class="headerlink" title="MarkedIntersection 交点处的标记方式"></a>MarkedIntersection 交点处的标记方式</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">STREAMABLE</span>(MarkedIntersection,</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">           STL    STR</span></span><br><span class="line"><span class="comment">  BLL _______v______v_______ BLR</span></span><br><span class="line"><span class="comment">    |       |______|       |</span></span><br><span class="line"><span class="comment">    |    SLL        SLR    |</span></span><br><span class="line"><span class="comment">    |                      |</span></span><br><span class="line"><span class="comment">    |                      |</span></span><br><span class="line"><span class="comment">    |______________________|</span></span><br><span class="line"><span class="comment">  BT                         otherBT</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * marker name components: (S/B)(L/T)(L/R)</span></span><br><span class="line"><span class="comment">   *  (Small/Big)(L-intersection, T-intersection)(Left/Right)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="built_in">ENUM</span>(IntersectionMarker,</span><br><span class="line">  &#123;,</span><br><span class="line">    BT,</span><br><span class="line">    STL,</span><br><span class="line">    STR,</span><br><span class="line">    BLL,</span><br><span class="line">    SLL,</span><br><span class="line">    SLR,</span><br><span class="line">    BLR,</span><br><span class="line"></span><br><span class="line">    firstIntersectionMarkerOther,</span><br><span class="line">    otherBT = firstIntersectionMarkerOther,</span><br><span class="line">    otherSTL,</span><br><span class="line">    otherSTR,</span><br><span class="line">    otherBLL,</span><br><span class="line">    otherSLL,</span><br><span class="line">    otherSLR,</span><br><span class="line">    otherBLR,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="type">static</span> IntersectionMarker <span class="built_in">mirror</span>(<span class="type">const</span> IntersectionMarker&amp; marker);</span><br><span class="line">  IntersectionMarker <span class="built_in">mirror</span>() <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">MarkedIntersection</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="built_in">MarkedIntersection</span>(<span class="type">unsigned</span> intersection, IntersectionMarker marker);</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> <span class="built_in">draw</span>() <span class="type">const</span>,</span><br><span class="line"></span><br><span class="line">  (<span class="type">unsigned</span>) intersectionIndex,</span><br><span class="line">  (IntersectionMarker)(numOfIntersectionMarkers) marker,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">MarkedIntersection::MarkedIntersection</span><span class="params">(<span class="type">unsigned</span> intersection, IntersectionMarker marker)</span></span></span><br><span class="line"><span class="function">  : intersectionIndex(intersection), marker(marker) &#123;</span>&#125;;</span><br></pre></td></tr></table></figure><h2 id="MarkedPoint"><a href="#MarkedPoint" class="headerlink" title="MarkedPoint"></a>MarkedPoint</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">STREAMABLE</span>(MarkedPoint,</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">ENUM</span>(PointMarker,</span><br><span class="line">  &#123;,</span><br><span class="line">    midCircle, <span class="comment">//Circle</span></span><br><span class="line">    penaltyMark, <span class="comment">//PenaltyMark</span></span><br><span class="line">    goalPostL, <span class="comment">//left goal post   左目标门柱</span></span><br><span class="line">    goalPostR, <span class="comment">//right goal post  右目标门柱</span></span><br><span class="line"></span><br><span class="line">    firstPointMarkerOther,</span><br><span class="line">    otherpenaltyMark = firstPointMarkerOther,</span><br><span class="line">    othergoalPostL,</span><br><span class="line">    othergoalPostR,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="type">static</span> PointMarker <span class="built_in">mirror</span>(<span class="type">const</span> PointMarker&amp; marker);</span><br><span class="line">  PointMarker <span class="built_in">mirror</span>() <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">MarkedPoint</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="built_in">MarkedPoint</span>(<span class="type">const</span> Vector2f&amp; p, PointMarker marker, <span class="type">bool</span> outOfCurrentFrame = <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> <span class="built_in">draw</span>() <span class="type">const</span>,<span class="comment">//TODO</span></span><br><span class="line"></span><br><span class="line">  (Vector2f)(<span class="built_in">Vector2f</span>()) point,</span><br><span class="line">  (PointMarker)(numOfPointMarkers) marker,</span><br><span class="line">  (<span class="type">bool</span>)(<span class="literal">false</span>) outOfCurrentFrame,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">MarkedPoint::MarkedPoint</span><span class="params">(<span class="type">const</span> Vector2f&amp; p, PointMarker marker, <span class="type">bool</span> outOfCurrentFrame)</span></span></span><br><span class="line"><span class="function">  : point(p), marker(marker), outOfCurrentFrame(outOfCurrentFrame) &#123;</span>&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Nao机器人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nao机器人 </tag>
            
            <tag> BHuman </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Nao机器人】BHuman中的类-Pose2f</title>
      <link href="/2019/04/19/Nao%E6%9C%BA%E5%99%A8%E4%BA%BA-BHuman%E4%B8%AD%E7%9A%84%E7%B1%BB-Pose2f/"/>
      <url>/2019/04/19/Nao%E6%9C%BA%E5%99%A8%E4%BA%BA-BHuman%E4%B8%AD%E7%9A%84%E7%B1%BB-Pose2f/</url>
      
        <content type="html"><![CDATA[<p>Pose2f 应该是 BHuman 中的一个比较重要的工具类吧，在代码中经常用到，以前不知道是干啥的，刚才看了下，记录下来。</p><p><code>Src/Tools/Math/Pose2f.h</code></p><p><strong>TODO：</strong> 学习类 Angle、Pose3f、Vector2f(我猜是个类似于vector的容器，不过里面存的东西要仔细研究下)等。<br><strong>ADD：</strong> Pose3f 与 Pose2f 大致相同，不过使用了 Vector3f，多了一个 z 作为参数。。。<br>在 Vector2f 的变量中还可以调用 <code>angle()</code> 函数，猜想：应该这两个类中有这个方法。<br>在 Egien.h 中只看到了一些容器的声明，引入了头文件 <code>Egien/Dense</code>，看了下，应该是 naoqi 的库中带的。<br><strong>ADD：</strong> 刚才看代码的过程中发现，有下面这两句：图像中的位置 Vector2i(image)，场地中的位置 Vector2f(field)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(Vector2i)(Vector2i::<span class="built_in">Zero</span>()) positionInImage, <span class="comment">/**&lt; Position in the image. 在图像中的位置 */</span></span><br><span class="line">(Vector2f)(Vector2f::<span class="built_in">Zero</span>()) positionOnField, <span class="comment">/**&lt; Position relative to robot on the field. 在场地中的位置 */</span></span><br></pre></td></tr></table></figure><span id="more"></span><p><img src="https://wx1.sinaimg.cn/mw690/006wR0dcly1g28dqlqoqij31hc0dago6.jpg"></p><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Angle是类型，0是默认值，rotation是变量名。</span></span><br><span class="line">(Angle)(<span class="number">0</span>) rotation,<span class="comment">/** rotation 旋转/转动 */</span></span><br><span class="line"><span class="comment">// 同上，还有就是在BHuman中的流式结构体中经常看到这种的变量声明，包括以后自己添加也是要按照这样的规范来写。</span></span><br><span class="line">(Vector2f)(Vector2f::<span class="built_in">Zero</span>()) translation,<span class="comment">/** translation 转化 */</span></span><br></pre></td></tr></table></figure><hr><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数，默认</span></span><br><span class="line"><span class="built_in">Pose2f</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="comment">// 拷贝构造，默认</span></span><br><span class="line"><span class="built_in">Pose2f</span>(<span class="type">const</span> Pose2f&amp; other) = <span class="keyword">default</span>;</span><br><span class="line"><span class="comment">// 传入两个float类型的变量x，y。</span></span><br><span class="line"><span class="built_in">Pose2f</span>(<span class="type">const</span> <span class="type">float</span> x, <span class="type">const</span> <span class="type">float</span> y);</span><br><span class="line"><span class="comment">// 传入一个Vector2f对象的引用，至于这个对象是干啥的，我再看看。。。我的猜想是从这个转换到这个。。。哈哈哈</span></span><br><span class="line"><span class="built_in">Pose2f</span>(<span class="type">const</span> Vector2f&amp; translation);</span><br><span class="line"><span class="comment">// 传入一个Angle(角度)</span></span><br><span class="line"><span class="built_in">Pose2f</span>(<span class="type">const</span> Angle rotation);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Pose2f</span>(<span class="type">const</span> Angle rotation, <span class="type">const</span> Vector2f&amp; translation);</span><br><span class="line"><span class="built_in">Pose2f</span>(<span class="type">const</span> Angle rotation, <span class="type">const</span> <span class="type">float</span> x, <span class="type">const</span> <span class="type">float</span> y);</span><br><span class="line"><span class="built_in">Pose2f</span>(<span class="type">const</span> <span class="type">float</span> rot, <span class="type">const</span> <span class="type">float</span> x, <span class="type">const</span> <span class="type">float</span> y);</span><br></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">Pose2f::Pose2f</span><span class="params">(<span class="type">const</span> <span class="type">float</span> x, <span class="type">const</span> <span class="type">float</span> y)</span> :</span></span><br><span class="line"><span class="function">  translation(x, y)&#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">Pose2f::Pose2f</span><span class="params">(<span class="type">const</span> Vector2f&amp; translation)</span> :</span></span><br><span class="line"><span class="function">  translation(translation)&#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">Pose2f::Pose2f</span><span class="params">(<span class="type">const</span> Angle rotation)</span> :</span></span><br><span class="line"><span class="function">  rotation(rotation)&#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">Pose2f::Pose2f</span><span class="params">(<span class="type">const</span> Angle rotation, <span class="type">const</span> Vector2f&amp; translation)</span> :</span></span><br><span class="line"><span class="function">  rotation(rotation), translation(translation)&#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">Pose2f::Pose2f</span><span class="params">(<span class="type">const</span> Angle rotation, <span class="type">const</span> <span class="type">float</span> x, <span class="type">const</span> <span class="type">float</span> y)</span> :</span></span><br><span class="line"><span class="function">  rotation(rotation), translation(x, y)&#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">Pose2f::Pose2f</span><span class="params">(<span class="type">const</span> <span class="type">float</span> rot, <span class="type">const</span> <span class="type">float</span> x, <span class="type">const</span> <span class="type">float</span> y)</span> :</span></span><br><span class="line"><span class="function">  rotation(rot), translation(x, y)&#123;</span>&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><h3 id="声明-1"><a href="#声明-1" class="headerlink" title="声明"></a>声明</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">Pose2f&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Pose2f&amp; other) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">Vector2f <span class="keyword">operator</span>*(<span class="type">const</span> Vector2f&amp; other) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Concatenation of this pose with another. The resulting rotation is not normalized!</span></span><br><span class="line"><span class="comment"> * 这个姿势和另一个 pose 的串联。结果的旋转没有标准化!</span></span><br><span class="line"><span class="comment"> * Use operator+ / operator+= for normalized(标准化的) rotations(旋转).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Pose2f <span class="keyword">operator</span>*(<span class="type">const</span> Pose2f&amp; other) <span class="type">const</span>;</span><br><span class="line">Pose2f&amp; <span class="keyword">operator</span>*=(<span class="type">const</span> Pose2f&amp; other);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Concatenation of this pose with another pose. The resulting rotation is not normalized!</span></span><br><span class="line"><span class="comment"> * 这个姿势和另一个 pose 的连接。结果的旋转没有标准化!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Pose2f <span class="keyword">operator</span>+(<span class="type">const</span> Pose2f&amp; other) <span class="type">const</span>;</span><br><span class="line">Pose2f&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> Pose2f&amp; other);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Difference of this pose relative to another pose. So if A+B=C is the addition/concatenation, this calculates C-A=B.</span></span><br><span class="line"><span class="comment"> * 这个姿势相对于另一个 pose 的不同之处。如果A+B=C是加法/串联，这就计算出C-A=B。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param other The other pose that will be used as origin for the new pose.</span></span><br><span class="line"><span class="comment"> * @return A reference to this pose after calculating the difference.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Pose2f&amp; <span class="keyword">operator</span>-=(<span class="type">const</span> Pose2f&amp; other);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Difference of this pose relative to another pose.</span></span><br><span class="line"><span class="comment"> * 这个姿势相对于另一个 pose 的不同之处。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param other The other pose that will be used as origin for the new pose.</span></span><br><span class="line"><span class="comment"> * @return The resulting pose.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Pose2f <span class="keyword">operator</span>-(<span class="type">const</span> Pose2f&amp; other) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** unary minus */</span></span><br><span class="line">Pose2f <span class="keyword">operator</span>-() <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Comparison of another pose with this one.</span></span><br><span class="line"><span class="comment"> * 比较另一个 pose 和这个。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param other The other pose that will be compared to this one</span></span><br><span class="line"><span class="comment"> * @return Whether the two poses are equal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Pose2f&amp; other) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Comparison of another pose with this one.</span></span><br><span class="line"><span class="comment"> * 比较另一个 pose 和这个。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param other The other pose that will be compared to this one</span></span><br><span class="line"><span class="comment"> * @return Whether the two poses are unequal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Pose2f&amp; other) <span class="type">const</span>;</span><br></pre></td></tr></table></figure><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> Vector2f Pose2f::<span class="keyword">operator</span>*(<span class="type">const</span> Vector2f&amp; other) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">float</span> s = std::<span class="built_in">sin</span>(rotation);</span><br><span class="line">  <span class="type">const</span> <span class="type">float</span> c = std::<span class="built_in">cos</span>(rotation);</span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">Vector2f</span>(other.<span class="built_in">x</span>() * c - other.<span class="built_in">y</span>() * s, other.<span class="built_in">x</span>() * s + other.<span class="built_in">y</span>() * c) + translation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Pose2f Pose2f::<span class="keyword">operator</span>*(<span class="type">const</span> Pose2f&amp; other) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Pose2f</span>(*<span class="keyword">this</span>) *= other;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Pose2f&amp; Pose2f::<span class="keyword">operator</span>*=(<span class="type">const</span> Pose2f&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">  translation = *<span class="keyword">this</span> * other.translation;</span><br><span class="line">  rotation += other.rotation;</span><br><span class="line">  rotation.<span class="built_in">normalize</span>();</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Pose2f Pose2f::<span class="keyword">operator</span>+(<span class="type">const</span> Pose2f&amp; other) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Pose2f</span>(*<span class="keyword">this</span>) += other;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Pose2f&amp; Pose2f::<span class="keyword">operator</span>+=(<span class="type">const</span> Pose2f&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">  translation = *<span class="keyword">this</span> * other.translation;</span><br><span class="line">  rotation += other.rotation;</span><br><span class="line">  rotation.<span class="built_in">normalize</span>();</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Pose2f&amp; Pose2f::<span class="keyword">operator</span>-=(<span class="type">const</span> Pose2f&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">  translation -= other.translation;</span><br><span class="line">  <span class="function">Pose2f <span class="title">p</span><span class="params">(-other.rotation)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span> = p + *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Pose2f Pose2f::<span class="keyword">operator</span>-(<span class="type">const</span> Pose2f&amp; other) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Pose2f</span>(*<span class="keyword">this</span>) -= other;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Pose2f Pose2f::<span class="keyword">operator</span>-() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Pose2f</span>() - (*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> Pose2f::<span class="keyword">operator</span>==(<span class="type">const</span> Pose2f&amp; other) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">return</span> ((translation == other.translation) &amp;&amp; (rotation == other.rotation));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> Pose2f::<span class="keyword">operator</span>!=(<span class="type">const</span> Pose2f&amp; other) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> !(<span class="built_in">Pose2f</span>(*<span class="keyword">this</span>) == other);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><h3 id="声明-2"><a href="#声明-2" class="headerlink" title="声明"></a>声明</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Pose2f&amp; <span class="title">translate</span><span class="params">(<span class="type">const</span> Vector2f&amp; trans)</span></span>;</span><br><span class="line"><span class="function">Pose2f&amp; <span class="title">translate</span><span class="params">(<span class="type">const</span> <span class="type">float</span> x, <span class="type">const</span> <span class="type">float</span> y)</span></span>;</span><br><span class="line"><span class="function">Pose2f&amp; <span class="title">rotate</span><span class="params">(<span class="type">const</span> Angle&amp; rot)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Inverts this pose and returns reference to this.</span></span><br><span class="line"><span class="comment"> * 反转此pose并返回对该位姿的引用。*/</span></span><br><span class="line"><span class="function">Pose2f&amp; <span class="title">invert</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/** Calculates the inverse transformation of this pose</span></span><br><span class="line"><span class="comment"> * 计算这个位姿的逆变换*/</span></span><br><span class="line"><span class="function">Pose2f <span class="title">inverse</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Pose2f <span class="title">dotMirror</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isFinite</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The function creates a random pose.</span></span><br><span class="line"><span class="comment"> * 该函数创建一个随机的姿态。</span></span><br><span class="line"><span class="comment"> * @param x The range for x-values of the pose.</span></span><br><span class="line"><span class="comment"> * @param y The range for y-values of the pose.</span></span><br><span class="line"><span class="comment"> * @param angle The range for the rotation of the pose.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> Pose2f <span class="title">random</span><span class="params">(<span class="type">const</span> Rangef&amp; angle, <span class="type">const</span> Rangef&amp; x, <span class="type">const</span> Rangef&amp; y)</span>,</span></span><br></pre></td></tr></table></figure><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> Pose2f&amp; <span class="title">Pose2f::translate</span><span class="params">(<span class="type">const</span> Vector2f&amp; trans)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  translation = *<span class="keyword">this</span> * trans;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Pose2f&amp; <span class="title">Pose2f::translate</span><span class="params">(<span class="type">const</span> <span class="type">float</span> x, <span class="type">const</span> <span class="type">float</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  translation = *<span class="keyword">this</span> * <span class="built_in">Vector2f</span>(x, y);</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Pose2f&amp; <span class="title">Pose2f::rotate</span><span class="params">(<span class="type">const</span> Angle&amp; rot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  rotation += rot;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Pose2f&amp; <span class="title">Pose2f::invert</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  rotation = -rotation;</span><br><span class="line">  <span class="type">const</span> Vector2f trans = -translation;</span><br><span class="line">  translation = Eigen::<span class="built_in">Rotation2D</span>&lt;<span class="type">float</span>&gt;(rotation) * trans;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Pose2f <span class="title">Pose2f::inverse</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Pose2f</span>(*<span class="keyword">this</span>).<span class="built_in">invert</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Pose2f <span class="title">Pose2f::dotMirror</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Pose2f</span>(Angle::<span class="built_in">normalize</span>(rotation + pi), -translation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">Pose2f::isFinite</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">isfinite</span>(translation.<span class="built_in">x</span>()) &amp;&amp; std::<span class="built_in">isfinite</span>(translation.<span class="built_in">y</span>()) &amp;&amp; std::<span class="built_in">isfinite</span>(rotation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Pose2f <span class="title">Pose2f::random</span><span class="params">(<span class="type">const</span> Rangef&amp; angle, <span class="type">const</span> Rangef&amp; x, <span class="type">const</span> Rangef&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Pose2f</span>(Random::<span class="built_in">uniform</span>(angle.min, angle.max), <span class="built_in">Vector2f</span>(Random::<span class="built_in">uniform</span>(x.min, x.max), Random::<span class="built_in">uniform</span>(y.min, y.max)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Nao机器人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nao机器人 </tag>
            
            <tag> BHuman </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Nao机器人】Robocup场地信息</title>
      <link href="/2019/04/10/Nao%E6%9C%BA%E5%99%A8%E4%BA%BA-Robocup%E5%9C%BA%E5%9C%B0%E4%BF%A1%E6%81%AF/"/>
      <url>/2019/04/10/Nao%E6%9C%BA%E5%99%A8%E4%BA%BA-Robocup%E5%9C%BA%E5%9C%B0%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<p>Robocup SPL 赛中的场地参数 和 BHuman 中的场地参数配置文件。</p><p>BHuman 场地配置文件：<code>BHumanCodeRelease-master/Config/Locations/Default/fieldDimensions.cfg</code><br>单位 mm。</p><span id="more"></span><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1xghfw069j30rd0ddab5.jpg" alt="球场图"></p><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1xgoyr4r2j31hc0u0gob.jpg" alt="自己画的"></p><h2 id="Robocup-SLP-场地参数"><a href="#Robocup-SLP-场地参数" class="headerlink" title="Robocup SLP 场地参数"></a>Robocup SLP 场地参数</h2><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1xgme6pztj30rq0ran1e.jpg" alt="场地信息1"></p><hr><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1xgni4owhj30rl0fqjsm.jpg" alt="球门"></p><hr><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1xgocl8s4j30rb0hn77c.jpg"></p><hr><h2 id="BHuman-场地配置文件"><a href="#BHuman-场地配置文件" class="headerlink" title="BHuman 场地配置文件"></a>BHuman 场地配置文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br></pre></td><td class="code"><pre><span class="line">// This is the field configuration for the indoor SPL field 2016</span><br><span class="line">// 2016年室内SPL场地的场地配置 y是场地的宽（左为+），x是场地的长（己方为+）</span><br><span class="line"></span><br><span class="line">// xPos 对手场地边界  ok</span><br><span class="line">xPosOpponentFieldBorder = 5200;         // origin -&gt; far field boundary // 远场边界</span><br><span class="line"></span><br><span class="line">// xPos 对手的目标   ok</span><br><span class="line">xPosOpponentGoal = 5055;                // origin -&gt; middle far side of goal    // 球门的中远侧</span><br><span class="line"></span><br><span class="line">// xPos 对手的球门位置  ok</span><br><span class="line">xPosOpponentGoalPost = 4525;            // origin -&gt; middle goal post   // 中间目标后</span><br><span class="line"></span><br><span class="line">// xPos 对手的底线  ok</span><br><span class="line">xPosOpponentGroundline = 4500;          // origin -&gt; middle goal line   // 中间目标线</span><br><span class="line"></span><br><span class="line">// xPos 对手禁区    ok</span><br><span class="line">xPosOpponentPenaltyArea = 3900;         // origin -&gt; middle near penalty area line  // 罚球区中线附近</span><br><span class="line"></span><br><span class="line">// 这个是 7 米，一半就是 3500   ok</span><br><span class="line">xPosOpponentDropInLine = 3500;          // origin -&gt; far end of throw-in line   // 掷界外球线的远端</span><br><span class="line"></span><br><span class="line">// 对手点球罚球点</span><br><span class="line">xPosOpponentPenaltyMark = 3200;         // origin -&gt; middle penalty mark // 中间点球罚球点</span><br><span class="line"></span><br><span class="line">xPosPenaltyStrikerStartPosition = 2200; // 前锋首发位置</span><br><span class="line"></span><br><span class="line">xPosHalfWayLine = 0;</span><br><span class="line">xPosOwnPenaltyMark = -xPosOpponentPenaltyMark;</span><br><span class="line">xPosOwnDropInLine = -xPosOpponentDropInLine;</span><br><span class="line">xPosOwnPenaltyArea = -xPosOpponentPenaltyArea;</span><br><span class="line">xPosOwnGroundline = -xPosOpponentGroundline;</span><br><span class="line">xPosOwnGoalPost = -xPosOpponentGoalPost;</span><br><span class="line">xPosOwnGoal = -xPosOpponentGoal;</span><br><span class="line">xPosOwnFieldBorder = -xPosOpponentFieldBorder;</span><br><span class="line"></span><br><span class="line">// 左 场 边界     ok</span><br><span class="line">yPosLeftFieldBorder = 3700;             // origin -&gt; side field boundary    端领域边界</span><br><span class="line"></span><br><span class="line">// 左线         ok</span><br><span class="line">yPosLeftSideline = 3000;                // origin -&gt; middle side line   中间侧线</span><br><span class="line"></span><br><span class="line">// 这个先不管   ok</span><br><span class="line">yPosLeftDropInLine = 2600;              // origin -&gt; thow-in line   // 边线发球 线</span><br><span class="line"></span><br><span class="line">// 左 禁区 区域     ok</span><br><span class="line">yPosLeftPenaltyArea = 1100;             // origin -&gt; middle left penalty area line  禁区区线</span><br><span class="line"></span><br><span class="line">// 左边 目标</span><br><span class="line">// 1500 + 50 + 50 = 1600 / 2 = 800</span><br><span class="line">yPosLeftGoal = 800;                     // origin -&gt; middle left goal post  中左门柱</span><br><span class="line"></span><br><span class="line">yPosCenterGoal = 0;</span><br><span class="line">yPosRightGoal = -yPosLeftGoal;</span><br><span class="line">yPosRightPenaltyArea = -yPosLeftPenaltyArea;</span><br><span class="line">yPosRightDropInLine = -yPosLeftDropInLine;</span><br><span class="line">yPosRightSideline = -yPosLeftSideline;</span><br><span class="line">yPosRightFieldBorder = -yPosLeftFieldBorder;</span><br><span class="line"></span><br><span class="line">// 线宽 50mm    ok</span><br><span class="line">fieldLinesWidth = 50;</span><br><span class="line"></span><br><span class="line">// 中心圆半径 750mm ok</span><br><span class="line">centerCircleRadius = 750;</span><br><span class="line"></span><br><span class="line">// ok</span><br><span class="line">goalPostRadius = 50;    // 门柱半径</span><br><span class="line"></span><br><span class="line">// ok</span><br><span class="line">crossBarRadius = goalPostRadius;    // 横梁半径</span><br><span class="line"></span><br><span class="line">// 球门高度 ，官方手册上说 球门高度是 800   ok</span><br><span class="line">goalHeight = 900;</span><br><span class="line"></span><br><span class="line">// 点球罚球点大小   ok</span><br><span class="line">penaltyMarkSize = 100;</span><br><span class="line"></span><br><span class="line">// 地毯的边界</span><br><span class="line">carpetBorder = [</span><br><span class="line">  &#123;</span><br><span class="line">    from = &#123;x = xPosOpponentFieldBorder; y = yPosRightFieldBorder;&#125;;</span><br><span class="line">    to   = &#123;x = xPosOpponentFieldBorder; y = yPosLeftFieldBorder;&#125;;</span><br><span class="line">  &#125;,&#123;</span><br><span class="line">    from = &#123;x = xPosOpponentFieldBorder; y = yPosLeftFieldBorder;&#125;;</span><br><span class="line">    to   = &#123;x = xPosOwnFieldBorder;      y = yPosLeftFieldBorder;&#125;;</span><br><span class="line">  &#125;,&#123;</span><br><span class="line">    from = &#123;x = xPosOwnFieldBorder;      y = yPosLeftFieldBorder;&#125;;</span><br><span class="line">    to   = &#123;x = xPosOwnFieldBorder;      y = yPosRightFieldBorder;&#125;;</span><br><span class="line">  &#125;,&#123;</span><br><span class="line">    from = &#123;x = xPosOwnFieldBorder;      y = yPosRightFieldBorder;&#125;;</span><br><span class="line">    to   = &#123;x = xPosOpponentFieldBorder; y = yPosRightFieldBorder;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">// 目标 框架 线</span><br><span class="line">goalFrameLines = [</span><br><span class="line">  &#123;</span><br><span class="line">    from = &#123;x = xPosOwnGoalPost; y = yPosLeftGoal;&#125;;</span><br><span class="line">    to   = &#123;x = xPosOwnGoal; y = yPosLeftGoal;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    from = &#123;x = xPosOwnGoal; y = yPosLeftGoal;&#125;;</span><br><span class="line">    to   = &#123;x = xPosOwnGoal; y = yPosRightGoal;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    from = &#123;x = xPosOwnGoalPost; y = yPosRightGoal;&#125;;</span><br><span class="line">    to   = &#123;x = xPosOwnGoal; y = yPosRightGoal;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    from = &#123;x = xPosOpponentGoalPost; y = yPosLeftGoal;&#125;;</span><br><span class="line">    to   = &#123;x = xPosOpponentGoal; y = yPosLeftGoal;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    from = &#123;x = xPosOpponentGoal; y = yPosLeftGoal;&#125;;</span><br><span class="line">    to   = &#123;x = xPosOpponentGoal; y = yPosRightGoal;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    from = &#123;x = xPosOpponentGoalPost; y = yPosRightGoal;&#125;;</span><br><span class="line">    to   = &#123;x = xPosOpponentGoal; y = yPosRightGoal;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">// 场边界</span><br><span class="line">fieldBorder = [</span><br><span class="line">  &#123;</span><br><span class="line">    from = &#123;x = xPosOpponentGroundline; y = yPosRightSideline;&#125;;</span><br><span class="line">    to   = &#123;x = xPosOpponentGroundline; y = yPosLeftSideline;&#125;;</span><br><span class="line">  &#125;,&#123;</span><br><span class="line">    from = &#123;x = xPosOpponentGroundline; y = yPosLeftSideline;&#125;;</span><br><span class="line">    to   = &#123;x = xPosOwnGroundline;      y = yPosLeftSideline;&#125;;</span><br><span class="line">  &#125;,&#123;</span><br><span class="line">    from = &#123;x = xPosOwnGroundline;      y = yPosLeftSideline;&#125;;</span><br><span class="line">    to   = &#123;x = xPosOwnGroundline;      y = yPosRightSideline;&#125;;</span><br><span class="line">  &#125;,&#123;</span><br><span class="line">    from = &#123;x = xPosOwnGroundline;      y = yPosRightSideline;&#125;;</span><br><span class="line">    to   = &#123;x = xPosOpponentGroundline; y = yPosRightSideline;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">// 场 线</span><br><span class="line">fieldLines = [</span><br><span class="line">  // field border lines</span><br><span class="line">  &#123;</span><br><span class="line">    from = &#123;x = xPosOpponentGroundline; y = yPosRightSideline;&#125;;</span><br><span class="line">    to   = &#123;x = xPosOpponentGroundline; y = yPosLeftSideline;&#125;;</span><br><span class="line">  &#125;,&#123;</span><br><span class="line">    from = &#123;x = xPosOpponentGroundline; y = yPosLeftSideline;&#125;;</span><br><span class="line">    to   = &#123;x = xPosOwnGroundline;      y = yPosLeftSideline;&#125;;</span><br><span class="line">  &#125;,&#123;</span><br><span class="line">    from = &#123;x = xPosOwnGroundline;      y = yPosLeftSideline;&#125;;</span><br><span class="line">    to   = &#123;x = xPosOwnGroundline;      y = yPosRightSideline;&#125;;</span><br><span class="line">  &#125;,&#123;</span><br><span class="line">    from = &#123;x = xPosOwnGroundline;      y = yPosRightSideline;&#125;;</span><br><span class="line">    to   = &#123;x = xPosOpponentGroundline; y = yPosRightSideline;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">// center line</span><br><span class="line">  &#123;</span><br><span class="line">    from = &#123;x = xPosHalfWayLine; y = yPosLeftSideline;&#125;;</span><br><span class="line">    to   = &#123;x = xPosHalfWayLine; y = yPosRightSideline;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">// penalty areas</span><br><span class="line">  &#123;</span><br><span class="line">    from = &#123;x = xPosOwnGroundline;  y = yPosLeftPenaltyArea;&#125;;</span><br><span class="line">    to   = &#123;x = xPosOwnPenaltyArea; y = yPosLeftPenaltyArea;&#125;;</span><br><span class="line">  &#125;,&#123;</span><br><span class="line">    from = &#123;x = xPosOwnPenaltyArea; y = yPosLeftPenaltyArea;&#125;;</span><br><span class="line">    to   = &#123;x = xPosOwnPenaltyArea; y = yPosRightPenaltyArea;&#125;;</span><br><span class="line">  &#125;,&#123;</span><br><span class="line">    from = &#123;x = xPosOwnPenaltyArea; y = yPosRightPenaltyArea;&#125;;</span><br><span class="line">    to   = &#123;x = xPosOwnGroundline;  y = yPosRightPenaltyArea;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    from = &#123;x = xPosOpponentGroundline;  y = yPosLeftPenaltyArea;&#125;;</span><br><span class="line">    to   = &#123;x = xPosOpponentPenaltyArea; y = yPosLeftPenaltyArea;&#125;;</span><br><span class="line">  &#125;,&#123;</span><br><span class="line">    from = &#123;x = xPosOpponentPenaltyArea; y = yPosLeftPenaltyArea;&#125;;</span><br><span class="line">    to   = &#123;x = xPosOpponentPenaltyArea; y = yPosRightPenaltyArea;&#125;;</span><br><span class="line">  &#125;,&#123;</span><br><span class="line">    from = &#123;x = xPosOpponentPenaltyArea; y = yPosRightPenaltyArea;&#125;;</span><br><span class="line">    to   = &#123;x = xPosOpponentGroundline;  y = yPosRightPenaltyArea;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// penalty and center marks</span><br><span class="line">  &#123;</span><br><span class="line">    from = &#123;x = 3150; y = 0;&#125;;</span><br><span class="line">    to   = &#123;x = 3250; y = 0;&#125;;</span><br><span class="line">  &#125;,&#123;</span><br><span class="line">    from = &#123;x = xPosOpponentPenaltyMark; y = -fieldLinesWidth;&#125;;</span><br><span class="line">    to   = &#123;x = xPosOpponentPenaltyMark; y =  fieldLinesWidth;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    from = &#123;x = -3150; y = 0;&#125;;</span><br><span class="line">    to   = &#123;x = -3250; y = 0;&#125;;</span><br><span class="line">  &#125;,&#123;</span><br><span class="line">    from = &#123;x = xPosOwnPenaltyMark; y = -fieldLinesWidth;&#125;;</span><br><span class="line">    to   = &#123;x = xPosOwnPenaltyMark; y =  fieldLinesWidth;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    from = &#123;x = -fieldLinesWidth; y = 0;&#125;;</span><br><span class="line">    to   = &#123;x =  fieldLinesWidth; y = 0;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">// 中心圆</span><br><span class="line">centerCircle = &#123;</span><br><span class="line">  center = &#123;x = xPosHalfWayLine; y = 0;&#125;;</span><br><span class="line">  radius = centerCircleRadius;</span><br><span class="line">  numOfSegments = 16;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 角落</span><br><span class="line">corners = &#123;</span><br><span class="line">  xCorner = [</span><br><span class="line">    &#123;x = xPosHalfWayLine; y = centerCircleRadius;&#125;,</span><br><span class="line">    &#123;x = xPosHalfWayLine; y = -centerCircleRadius;&#125;</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  tCorner0 = [</span><br><span class="line">    &#123;x = xPosHalfWayLine; y = centerCircleRadius;&#125;,</span><br><span class="line">    &#123;x = xPosHalfWayLine; y = -centerCircleRadius;&#125;,</span><br><span class="line">    &#123;x = xPosOwnGroundline; y = yPosLeftPenaltyArea;&#125;,</span><br><span class="line">    &#123;x = xPosOwnGroundline; y = yPosRightPenaltyArea;&#125;</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  tCorner90 = [</span><br><span class="line">    &#123;x = xPosHalfWayLine; y = centerCircleRadius;&#125;,</span><br><span class="line">    &#123;x = xPosHalfWayLine; y = -centerCircleRadius;&#125;,</span><br><span class="line">    &#123;x = xPosHalfWayLine; y = yPosRightSideline;&#125;</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  tCorner180 = [</span><br><span class="line">    &#123;x = xPosHalfWayLine; y = centerCircleRadius;&#125;,</span><br><span class="line">    &#123;x = xPosHalfWayLine; y = -centerCircleRadius;&#125;,</span><br><span class="line">    &#123;x = xPosOpponentGroundline; y = yPosLeftPenaltyArea;&#125;,</span><br><span class="line">    &#123;x = xPosOpponentGroundline; y = yPosRightPenaltyArea;&#125;</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  tCorner270 = [</span><br><span class="line">    &#123;x = xPosHalfWayLine; y = centerCircleRadius;&#125;,</span><br><span class="line">    &#123;x = xPosHalfWayLine; y = -centerCircleRadius;&#125;,</span><br><span class="line">    &#123;x = xPosHalfWayLine; y = yPosLeftSideline;&#125;</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  lCorner0 = [</span><br><span class="line">    &#123;x = xPosHalfWayLine; y = centerCircleRadius;&#125;,</span><br><span class="line">    &#123;x = xPosHalfWayLine; y = -centerCircleRadius;&#125;,</span><br><span class="line">    &#123;x = xPosOwnGroundline; y = yPosLeftPenaltyArea;&#125;,</span><br><span class="line">    &#123;x = xPosOwnGroundline; y = yPosRightPenaltyArea;&#125;,</span><br><span class="line">    &#123;x = xPosHalfWayLine; y = yPosRightSideline;&#125;,</span><br><span class="line">    &#123;x = xPosOwnGroundline; y = yPosRightSideline;&#125;,</span><br><span class="line">    &#123;x = xPosOpponentPenaltyArea; y = yPosRightPenaltyArea;&#125;</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  lCorner90 = [</span><br><span class="line">    &#123;x = xPosHalfWayLine; y = centerCircleRadius;&#125;,</span><br><span class="line">    &#123;x = xPosHalfWayLine; y = -centerCircleRadius;&#125;,</span><br><span class="line">    &#123;x = xPosOpponentGroundline; y = yPosLeftPenaltyArea;&#125;,</span><br><span class="line">    &#123;x = xPosOpponentGroundline; y = yPosRightPenaltyArea;&#125;,</span><br><span class="line">    &#123;x = xPosHalfWayLine; y = yPosRightSideline;&#125;,</span><br><span class="line">    &#123;x = xPosOpponentGroundline; y = yPosRightSideline;&#125;,</span><br><span class="line">    &#123;x = xPosOwnPenaltyArea; y = yPosRightPenaltyArea;&#125;</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  lCorner180 = [</span><br><span class="line">    &#123;x = xPosHalfWayLine; y = centerCircleRadius;&#125;,</span><br><span class="line">    &#123;x = xPosHalfWayLine; y = -centerCircleRadius;&#125;,</span><br><span class="line">    &#123;x = xPosOpponentGroundline; y = yPosLeftPenaltyArea;&#125;,</span><br><span class="line">    &#123;x = xPosOpponentGroundline; y = yPosRightPenaltyArea;&#125;,</span><br><span class="line">    &#123;x = xPosHalfWayLine; y = yPosLeftSideline;&#125;,</span><br><span class="line">    &#123;x = xPosOpponentGroundline; y = yPosLeftSideline;&#125;,</span><br><span class="line">    &#123;x = xPosOwnPenaltyArea; y = yPosLeftPenaltyArea;&#125;</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  lCorner270 = [</span><br><span class="line">    &#123;x = xPosHalfWayLine; y = centerCircleRadius;&#125;,</span><br><span class="line">    &#123;x = xPosHalfWayLine; y = -centerCircleRadius;&#125;,</span><br><span class="line">    &#123;x = xPosOwnGroundline; y = yPosLeftPenaltyArea;&#125;,</span><br><span class="line">    &#123;x = xPosOwnGroundline; y = yPosRightPenaltyArea;&#125;,</span><br><span class="line">    &#123;x = xPosHalfWayLine; y = yPosLeftSideline;&#125;,</span><br><span class="line">    &#123;x = xPosOwnGroundline; y = yPosLeftSideline;&#125;,</span><br><span class="line">    &#123;x = xPosOpponentPenaltyArea; y = yPosLeftPenaltyArea;&#125;</span><br><span class="line">  ];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Nao机器人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nao机器人 </tag>
            
            <tag> BHuman </tag>
            
            <tag> Robocup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git-搭建Git服务端</title>
      <link href="/2019/04/09/Git-%E6%90%AD%E5%BB%BAGit%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
      <url>/2019/04/09/Git-%E6%90%AD%E5%BB%BAGit%E6%9C%8D%E5%8A%A1%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<p>搭建一个git本地服务端，注意区别！(Github、gitlab)</p><span id="more"></span><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.安装</span><br><span class="line">  yum install git -y</span><br><span class="line"></span><br><span class="line">2.初始化仓库</span><br><span class="line">  git init --bare xxx.git</span><br><span class="line"></span><br><span class="line">3.添加系统用户</span><br><span class="line">  useradd &lt;name&gt;</span><br><span class="line">  passwd &lt;name&gt;</span><br><span class="line"></span><br><span class="line">4.修改目录的所有者</span><br><span class="line">  chown -R &lt;name&gt;:&lt;name&gt; test.git</span><br><span class="line"></span><br><span class="line">5.clone</span><br><span class="line">  git clone 用户名@服务器:/目录/仓库.git</span><br><span class="line">  git clone blue@192.168.183.130:/git/test.git test2</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>需要启用 22 端口，还有关闭防火墙(因为是在实验室的内网环境下测试，所以直接关闭了)，一般不要随便关闭防火墙，具体的配置一下就行。</p><p><strong>关闭防火墙：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -F         #清除防火墙规则</span><br><span class="line">iptables -L         #查看</span><br></pre></td></tr></table></figure><p><strong>启用 22 端口：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">默认没有打开ssh的22端口</span><br><span class="line">解决的办法是</span><br><span class="line">sudo apt-get install openssh-server</span><br><span class="line"> </span><br><span class="line">sudo apt-get install ufw</span><br><span class="line"> </span><br><span class="line">sudo ufw enable</span><br><span class="line"> </span><br><span class="line">sudo ufw allow 22</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反思-不要再二三十岁时就开始老去</title>
      <link href="/2019/04/08/%E5%8F%8D%E6%80%9D-%E4%B8%8D%E8%A6%81%E5%86%8D%E4%BA%8C%E4%B8%89%E5%8D%81%E5%B2%81%E6%97%B6%E5%B0%B1%E5%BC%80%E5%A7%8B%E8%80%81%E5%8E%BB/"/>
      <url>/2019/04/08/%E5%8F%8D%E6%80%9D-%E4%B8%8D%E8%A6%81%E5%86%8D%E4%BA%8C%E4%B8%89%E5%8D%81%E5%B2%81%E6%97%B6%E5%B0%B1%E5%BC%80%E5%A7%8B%E8%80%81%E5%8E%BB/</url>
      
        <content type="html"><![CDATA[<p>高三时在<a href="http://fm.xinli001.com/99395836">「心理FM」</a>上听到的一篇好文，昨晚又听了一遍，非常喜欢，转载。</p><p>文：陌忘宇<br>主播：冰夏<br>心理FM：<a href="http://fm.xinli001.com/99388839">不要二三十岁就懒得去奋斗</a></p><span id="more"></span><p>村上春树说，我一直以为人是慢慢变老的，其实不是，人是一瞬间变老的。</p><p>起初看到这句话时，不以为然，总觉得自己还很年轻，刚到二十岁，“二”字开头的年龄，不用再装作大人了，因为我们本来就是成人了。感觉离“三”还有好远，十年，像天黑，长夜漫漫，忘记了来路，也看不清去处。</p><p>二十出头，可以在大学校园里漫无边际地游荡，学习充实到还可以再学，也可以在四人宿舍里没有目的地徘徊，游戏玩到后来不想再玩。可以在社团的小天地里活跃，弄得风声水起，也可以在创业的大路上乱撞，搞得有声有色。可以毫无顾忌地喝酒，大谈政治，也可以无所事事地抽烟，闲谈艺术。卧谈快要到天明才想起来明天早上还有课，休假快要到学期结束才想起来大学还有考试。有人恋爱，有人失恋，有人得意，有人失意，有人振作，有人颓废……</p><p>好像二十多岁，有很多很多的时间和空间，有很多个无聊的周末，外面有很大的空间。还有很多很多的精力，精神和力量，可以连续一周不怎么睡，周末睡上一觉就恢复过来，可以喝醉酒到吐，吐完又接着继续喝。</p><p>可是，当第二个本命年刚过，突然发现好多东西开始有些静止了，其实也不是静止，大概就像村上春树说的那样，人是一瞬间变老的。当你开始变老，那么对于外在的感知就开始不那么敏感，自然也没什么新鲜感。</p><p>以前总开玩笑说，有人叫自己叔叔，有人叫自己阿姨，写一些故作高深的文章，听一些不入大众的歌曲，看一些逆流而上的电影，但心里清楚地知道，自己还很年轻，还有很多路要走，还有很多人要见，还有很多道理要明白。</p><p>现在不同了，自己明明还是很年轻的，但心里明明有种声音，催促着自己往前不停地赶路。翻看以前的文章，发现那些早些年装作写出来的道理，现在依旧适用，只是那时候是装出来的，这个时候一一去践行。</p><p>还有什么不懂的呢？人情世故？冷暖人生？</p><p>过去的那些年，或多或少经历过生，也目睹过死，在爱情的生活里，有甜蜜，也有痛苦，在亲情的呵护下，有反叛，却开始理解，在友情的支持中，有深交，也有绝交，在职场的漩涡中，有收获，也有失去……</p><p>我们的认知开始变得越来越慢，就像罗曼·罗兰说的那样：大部分人在二三十岁上就死去了，因为过了这个年龄，他们只是自己的影子，此后的余生则是在模仿自己中度过，日复一日，更机械，更装腔作势地重复他们在有生之年的所作所为，所思所想，所爱所恨。</p><p>有好多道理也不用再从书本的字缝里扣出，无非就是这个月的房租下个月的水电，或者今年的车子明年的房子，即使没人再说，但好像都心知肚明。看了一下周围的人，大家的确都很努力，但努力也开始变得机械重复。</p><p>在深圳合租的一个同事，是做软件测试的，工作两三年，因为只隔一室，对他的情况还算比较了解。</p><p>每个月大部分时间都在加班，晚上六点下班，他大概十点左右才回来，每个月大小周，他几乎没休过。在我看来，他够努力了。</p><p>每天回来后，打开电脑，放着无关的视频，听着新闻，然后还拿着手机，在手机上刷来刷去，通常到凌晨一两点，早上七八点起来，赶去上班。</p><p>日子就这样在重复，起初我还觉得不可思议，怎么可以把生活过成这样？明明可以早些睡，为什么不呢？明明回来可以再学习，为什么不呢？</p><p>直到后来，我发现自己每天也开始日复一日地重复时，比如下了班，也无所事事地刷朋友圈，然后去写那些套路很像的文章，竟然有些不知所措。再来反观别人，人家各种压力大啊，怎么睡得着？人家工作那么累，回来就不能放松下？</p><p>但思来想去，我还是觉得这样的生活是有问题的，我们一生的剧本不应该这么写，故事的结尾早已经写好，只等着每天去直播，然后等剧情END，帷幕落下。</p><p>记得电影《少年时代》快要结束的一幕，母亲奥利维亚在儿子梅森终于高中毕业后，决定卖掉房子搬家时，梅森扔掉自己以前拍的照片，他的母亲突然一个人坐在那里哭。当梅森问母亲期待什么时，他的母亲说，我突然意识到，我的人生就这样了，恋爱结婚生孩子离婚再结婚，也的确找到了自己想要的工作，但好像前一天教孩子学会骑单车，之后就要送孩子上大学了，再往后就只剩下“我的葬礼！”了。梅森问他母亲，怎么就把人生快进了四十年？他的母亲说，我以为人生本来会有更多！</p><p>我们何尝不以为人生会有更多？可是不少人却把二三十岁过成了年老的生活，日复一日地单曲循环往复，每天上班打卡下班打卡，回家躺在沙发上刷手机看电视。大部分人在二三十岁时就已经老去，但我觉得有人可以依旧年轻，这个人可以是你，也可以是我。</p><p>就像阿乙在他最新随笔集的封面上写的那样，这个世界有一些人躺在泥泞里，看着生活把自己踩扁，而有些人拨开雾障告诉我们：人有活在云端的可能。</p><p>我想，这种云端的可能大概就是，对这个世界还感兴趣，对这个世界还有好奇心，不断地旅游和读书，旅游从外扩展生命的长度，读书从内增加生命的厚度，从而给自己的生命注入新生的活力。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 反思 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反思 </tag>
            
            <tag> 好文分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Nao机器人】Modules/BehaviorControl/BehaviorControl</title>
      <link href="/2019/04/06/Nao%E6%9C%BA%E5%99%A8%E4%BA%BA-Modules-BehaviorControl-BehaviorControl/"/>
      <url>/2019/04/06/Nao%E6%9C%BA%E5%99%A8%E4%BA%BA-Modules-BehaviorControl-BehaviorControl/</url>
      
        <content type="html"><![CDATA[<p>记录下。。。看这个目录的关系。</p><span id="more"></span><p><strong>pwd</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BHumanCodeRelease-coderelease2017/Src/Modules/BehaviorControl/BehaviorControl/</span><br></pre></td></tr></table></figure><p><strong>tree</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── BehaviorControl.cpp</span><br><span class="line">├── BehaviorControl.h</span><br><span class="line">├── Options</span><br><span class="line">│   ├── DemoOptions</span><br><span class="line">│   │   ├── Demo.h</span><br><span class="line">│   │   └── Waving.h</span><br><span class="line">│   ├── GameControl</span><br><span class="line">│   │   ├── HandleGameState.h</span><br><span class="line">│   │   ├── HandlePenaltyState.h</span><br><span class="line">│   │   ├── PlayingState.h</span><br><span class="line">│   │   └── ReadyState.h</span><br><span class="line">│   ├── HeadControl</span><br><span class="line">│   │   ├── HeadControl.h</span><br><span class="line">│   │   └── LookForward.h</span><br><span class="line">│   ├── Output</span><br><span class="line">│   │   ├── Activity.h</span><br><span class="line">│   │   ├── Annotation.h</span><br><span class="line">│   │   ├── HeadMotionRequest</span><br><span class="line">│   │   │   └── SetHeadPanTilt.h</span><br><span class="line">│   │   ├── MotionRequest</span><br><span class="line">│   │   │   ├── GetUpEngine.h</span><br><span class="line">│   │   │   ├── InWalkKick.h</span><br><span class="line">│   │   │   ├── SpecialAction.h</span><br><span class="line">│   │   │   ├── Stand.h</span><br><span class="line">│   │   │   ├── WalkAtAbsoluteSpeed.h</span><br><span class="line">│   │   │   ├── WalkAtRelativeSpeed.h</span><br><span class="line">│   │   │   └── WalkToTarget.h</span><br><span class="line">│   │   └── PlaySound.h</span><br><span class="line">│   ├── Roles</span><br><span class="line">│   │   └── Striker.h</span><br><span class="line">│   ├── Skills</span><br><span class="line">│   │   └── GetUp.h</span><br><span class="line">│   ├── Soccer.h</span><br><span class="line">│   └── Tools</span><br><span class="line">│       └── ButtonPressedAndReleased.h</span><br><span class="line">└── Options.h</span><br></pre></td></tr></table></figure><h2 id="BehaviorControl-h"><a href="#BehaviorControl-h" class="headerlink" title="BehaviorControl.h"></a>BehaviorControl.h</h2><blockquote><p>基于 c 语言的状态机行为控制模块的<strong>声明</strong>。</p></blockquote><p>从源码中可以看到，引入了 Representations 中的一些模块的头文件。</p><h2 id="BehaviorControl-cpp"><a href="#BehaviorControl-cpp" class="headerlink" title="BehaviorControl.cpp"></a>BehaviorControl.cpp</h2><blockquote><p>基于 c 语言的状态机行为控制模块的<strong>实现</strong>。</p></blockquote><h2 id="Options-h"><a href="#Options-h" class="headerlink" title="Options.h"></a>Options.h</h2><blockquote><p>所有属于当前行为的 option 文件都必须包含在这个文件中。</p></blockquote><p>在 Options 文件夹中写的东西需要在此头文件中包含。</p><hr><h2 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h2><p><strong>tree</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── DemoOptions</span><br><span class="line">│   ├── Demo.h</span><br><span class="line">│   └── Waving.h</span><br><span class="line">├── GameControl</span><br><span class="line">│   ├── HandleGameState.h</span><br><span class="line">│   ├── HandlePenaltyState.h</span><br><span class="line">│   ├── PlayingState.h</span><br><span class="line">│   └── ReadyState.h</span><br><span class="line">├── HeadControl</span><br><span class="line">│   ├── HeadControl.h</span><br><span class="line">│   └── LookForward.h</span><br><span class="line">├── Output</span><br><span class="line">│   ├── Activity.h</span><br><span class="line">│   ├── Annotation.h</span><br><span class="line">│   ├── HeadMotionRequest</span><br><span class="line">│   │   └── SetHeadPanTilt.h</span><br><span class="line">│   ├── MotionRequest</span><br><span class="line">│   │   ├── GetUpEngine.h</span><br><span class="line">│   │   ├── InWalkKick.h</span><br><span class="line">│   │   ├── SpecialAction.h</span><br><span class="line">│   │   ├── Stand.h</span><br><span class="line">│   │   ├── WalkAtAbsoluteSpeed.h</span><br><span class="line">│   │   ├── WalkAtRelativeSpeed.h</span><br><span class="line">│   │   └── WalkToTarget.h</span><br><span class="line">│   └── PlaySound.h</span><br><span class="line">├── Roles</span><br><span class="line">│   └── Striker.h</span><br><span class="line">├── Skills</span><br><span class="line">│   └── GetUp.h</span><br><span class="line">├── Soccer.h</span><br><span class="line">└── Tools</span><br><span class="line">    └── ButtonPressedAndReleased.h</span><br></pre></td></tr></table></figure><hr><h3 id="Soccer-h"><a href="#Soccer-h" class="headerlink" title="Soccer.h"></a>Soccer.h</h3><blockquote><p>root option，在机器人真正开始游戏之前控制行为。</p></blockquote><p>主函数？所有的操作从这里开始执行。</p><p>第一次按下胸口按钮：站起来。<br>第二次：惩罚状态。<br>第三次：非惩罚状态，开始踢球。<br>连续按 3 次，机器人关闭所有关节，蹲下。</p><hr><h3 id="DemoOptions"><a href="#DemoOptions" class="headerlink" title="DemoOptions"></a>DemoOptions</h3><p>提供了两个 Demo，调用 Striker() 踢球。</p><p><strong>tree</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Demo.h</span><br><span class="line">└── Waving.h</span><br></pre></td></tr></table></figure><hr><h3 id="GameControl"><a href="#GameControl" class="headerlink" title="GameControl"></a>GameControl</h3><p><strong>tree</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── HandleGameState.h</span><br><span class="line">├── HandlePenaltyState.h</span><br><span class="line">├── PlayingState.h</span><br><span class="line">└── ReadyState.h</span><br></pre></td></tr></table></figure><h4 id="HandleGameState-h"><a href="#HandleGameState-h" class="headerlink" title="HandleGameState.h"></a>HandleGameState.h</h4><blockquote><p>触发不同游戏状态的选项。<br>该选项还会调用跌倒后的getup行为，这在大多数游戏状态中都是需要的。</p></blockquote><p>从 Soccer.h 进入这里后，执行对应的 state。</p><h4 id="HandlePenaltyState-h"><a href="#HandlePenaltyState-h" class="headerlink" title="HandlePenaltyState.h"></a>HandlePenaltyState.h</h4><blockquote><p>处理惩罚状态(以及离开惩罚状态后要执行的操作)。<br>此选项比主游戏状态处理高一级，因为在大多数游戏状态中可能会出现惩罚。<br>默认情况下，机器人不受惩罚，并根据当前比赛状态踢足球。要想手动惩罚机器人，必须按下和松开胸前的按钮。</p></blockquote><h4 id="PlayingState-h"><a href="#PlayingState-h" class="headerlink" title="PlayingState.h"></a>PlayingState.h</h4><p>在这里调用了 Demo()。</p><h4 id="ReadyState-h"><a href="#ReadyState-h" class="headerlink" title="ReadyState.h"></a>ReadyState.h</h4><p>机器人准备就绪的状态，头 lookforward，并且站立。</p><hr><h3 id="HeadControl"><a href="#HeadControl" class="headerlink" title="HeadControl"></a>HeadControl</h3><p>头部控制。</p><p><strong>tree</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── HeadControl.h</span><br><span class="line">└── LookForward.h</span><br></pre></td></tr></table></figure><h4 id="HeadControl-h"><a href="#HeadControl-h" class="headerlink" title="HeadControl.h"></a>HeadControl.h</h4><blockquote><p>由 option HeadControl 执行的 head 控制模式。</p></blockquote><p>默认只有 none、off、lookforward 三种头部状态。</p><h4 id="LookForward-h"><a href="#LookForward-h" class="headerlink" title="LookForward.h"></a>LookForward.h</h4><p>头部 lookforward，调用 SetHeadPanTilt 模块。</p><hr><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Activity.h</span><br><span class="line">├── Annotation.h</span><br><span class="line">├── HeadMotionRequest</span><br><span class="line">│   └── SetHeadPanTilt.h</span><br><span class="line">├── MotionRequest</span><br><span class="line">│   ├── GetUpEngine.h</span><br><span class="line">│   ├── InWalkKick.h</span><br><span class="line">│   ├── SpecialAction.h</span><br><span class="line">│   ├── Stand.h</span><br><span class="line">│   ├── WalkAtAbsoluteSpeed.h</span><br><span class="line">│   ├── WalkAtRelativeSpeed.h</span><br><span class="line">│   └── WalkToTarget.h</span><br><span class="line">└── PlaySound.h</span><br></pre></td></tr></table></figure><h4 id="Activity-h"><a href="#Activity-h" class="headerlink" title="Activity.h"></a>Activity.h</h4><blockquote><p>通过这个开设置机器人的当前状态。</p></blockquote><p>传入一个参数，调用 BehaviorStatus 模块。</p><h4 id="Annotation-h"><a href="#Annotation-h" class="headerlink" title="Annotation.h"></a>Annotation.h</h4><p>通过这个来注释，需要一个 string 类型的参数。</p><h4 id="PlaySound-h"><a href="#PlaySound-h" class="headerlink" title="PlaySound.h"></a>PlaySound.h</h4><blockquote><p>如果在前一个循环中未调用此选项，则播放声音。</p></blockquote><p>播放音频，传入一个 string 类型的参数（音频名）。</p><h4 id="HeadMotionRequest"><a href="#HeadMotionRequest" class="headerlink" title="HeadMotionRequest"></a>HeadMotionRequest</h4><h5 id="SetHeadPanTilt-h"><a href="#SetHeadPanTilt-h" class="headerlink" title="SetHeadPanTilt.h"></a>SetHeadPanTilt.h</h5><p>用这个模块来控制机器人的头部。</p><h4 id="MotionRequest"><a href="#MotionRequest" class="headerlink" title="MotionRequest"></a>MotionRequest</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── GetUpEngine.h</span><br><span class="line">├── InWalkKick.h</span><br><span class="line">├── SpecialAction.h</span><br><span class="line">├── Stand.h</span><br><span class="line">├── WalkAtAbsoluteSpeed.h</span><br><span class="line">├── WalkAtRelativeSpeed.h</span><br><span class="line">└── WalkToTarget.h</span><br></pre></td></tr></table></figure><h5 id="GetUpEngine-h"><a href="#GetUpEngine-h" class="headerlink" title="GetUpEngine.h"></a>GetUpEngine.h</h5><blockquote><p>一个简单的站起来的引擎。</p></blockquote><h5 id="InWalkKick-h"><a href="#InWalkKick-h" class="headerlink" title="InWalkKick.h"></a>InWalkKick.h</h5><blockquote><p>边走边踢。</p></blockquote><h5 id="SpecialAction-h"><a href="#SpecialAction-h" class="headerlink" title="SpecialAction.h"></a>SpecialAction.h</h5><blockquote><p>Sets all members of the MotionRequest representation for executing a SpecialAction.</p></blockquote><h5 id="Stand-h"><a href="#Stand-h" class="headerlink" title="Stand.h"></a>Stand.h</h5><blockquote><p>Sets all members of the MotionRequest representation for simple standing.</p></blockquote><h5 id="WalkAtAbsoluteSpeed-h"><a href="#WalkAtAbsoluteSpeed-h" class="headerlink" title="WalkAtAbsoluteSpeed.h"></a>WalkAtAbsoluteSpeed.h</h5><blockquote><p>Sets all members of the MotionRequest representation for executing an absoluteSpeedMode-WalkRequest.</p><p>Walking speeds, in mm/s and radian/s.<br>           e.g.  Pose2f(0.f, 50.f, 0.f) lets move the robot forward at 50 mm/s<br>                   Pose2f(0.f, 50.f, 50.f) lets move the robot diagonal<br>                   Pose2f(0.2f, 100.f, 0.f) lets move the robot in a circle</p></blockquote><p>传入一个参数<code>(const Pose2f&amp;) speed</code>。</p><h5 id="WalkAtRelativeSpeed-h"><a href="#WalkAtRelativeSpeed-h" class="headerlink" title="WalkAtRelativeSpeed.h"></a>WalkAtRelativeSpeed.h</h5><blockquote><p>Sets all members of the MotionRequest representation for executing a relativeSpeedMode-WalkRequest.</p><p>@param speed Walking speeds, in the range [-1.f .. 1.f].<br>              e.g.  Pose2f(0.f, 1.f, 0.f) lets move the robot forward at full speed<br>                     Pose2f(0.f, 0.5f, 0.5f) lets move the robot diagonal at half of the possible speed<br>                     Pose2f(0.5f, 1.f, 0.f) lets move the robot in a circle</p></blockquote><h5 id="WalkToTarget-h"><a href="#WalkToTarget-h" class="headerlink" title="WalkToTarget.h"></a>WalkToTarget.h</h5><p>走向目标。</p><p>传入两个参数，一个速度，一个目标的位置。<br><code>(const Pose2f&amp;) speed, (const Pose2f&amp;) target</code></p><hr><h3 id="Roles"><a href="#Roles" class="headerlink" title="Roles"></a>Roles</h3><p>放角色文件的地方。</p><h4 id="Striker-h"><a href="#Striker-h" class="headerlink" title="Striker.h"></a>Striker.h</h4><p>默认的前锋 Demo。</p><hr><h3 id="Skills"><a href="#Skills" class="headerlink" title="Skills"></a>Skills</h3><p>机器人的一些技能，比如站起来。</p><h4 id="GetUp-h"><a href="#GetUp-h" class="headerlink" title="GetUp.h"></a>GetUp.h</h4><p>调用 GetUpEngine() 模块。</p><hr><h3 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h3><p>工具~~~。</p><h4 id="ButtonPressedAndReleased-h"><a href="#ButtonPressedAndReleased-h" class="headerlink" title="ButtonPressedAndReleased.h"></a>ButtonPressedAndReleased.h</h4><p>按钮按下和释放。</p><blockquote><p>该选项观察某个按钮的状态，如果按下并释放该按钮，则报告成功。<br>如果指定超时，如果状态更改耗时太长，也可以中止该 option。</p></blockquote><hr><p>OK，到这里这块就完啦。</p>]]></content>
      
      
      <categories>
          
          <category> Nao机器人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nao机器人 </tag>
            
            <tag> BHuman </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Nao机器人】机器人行为之getUp</title>
      <link href="/2019/04/05/Nao%E6%9C%BA%E5%99%A8%E4%BA%BA-%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%A1%8C%E4%B8%BA%E4%B9%8BgetUp/"/>
      <url>/2019/04/05/Nao%E6%9C%BA%E5%99%A8%E4%BA%BA-%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%A1%8C%E4%B8%BA%E4%B9%8BgetUp/</url>
      
        <content type="html"><![CDATA[<p>在赛场上机器人是很难避免跌倒的（守门员经常会扑倒挡球），在 BHuman 中带了跌倒后站起的行为，这篇文章是记录下最近对此行为运行过程的分析。</p><span id="more"></span><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1ru217cjvj318y0m8qv5.jpg" alt="守门员扑球"></p><h2 id="HandleGameState-h"><a href="#HandleGameState-h" class="headerlink" title="HandleGameState.h"></a>HandleGameState.h</h2><p>在赛场上机器人可能因为各种因素跌倒，所以跌倒的状态判断是<strong>全局的</strong>，当跌倒后，停止执行后面的动作，转去执行 getUp。可以看到，这里调用了 theFallDownState 模块，下面进到里面看看。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(theFallDownState.state == FallDownState::fallen)</span><br><span class="line">  <span class="keyword">goto</span> getUp;</span><br></pre></td></tr></table></figure><h3 id="FallDownState"><a href="#FallDownState" class="headerlink" title="FallDownState"></a>FallDownState</h3><p>FallDownState，是一个摔倒状态的结构体，里面有机器人关于跌倒的 6 个 state 和 4 个 direction。</p><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1rveodb7ej32la1makjl.jpg" alt="falldownstate"></p><p>这样上面的<code>if</code>语句中的条件就很清楚啦。在<code>HandleGameState.h</code>可以看到，这里跌落后会调到 getUp 的 state。在 getUp 中可以看到调用了<code>GetUp()</code>这个 option，下来进这个里面看看。</p><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1ru7zwj3yj32lc1mcnpd.jpg" alt="handlegamestate"></p><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1rua6fq46j32la1mab29.jpg" alt="getUp"></p><h2 id="GetUp-h"><a href="#GetUp-h" class="headerlink" title="GetUp.h"></a>GetUp.h</h2><p>在 GetUp 这个 option 中，可以看到直接<code>goto standUp</code>，在 standUp 这个状态执行站起来的动作，并且一直在判断机器人的状态，如果动作执行完毕并且机器娃儿站起来了就<code>goto stand</code>。</p><p>在 standUp 这个 state 中，在 action 中执行自己的对应动作并且伴随着判断机器人的状态，如果又摔倒了就调到上面的 <code>state(standUp)</code>。</p><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1s7qr5z9oj32lc1mce81.jpg" alt="standUP"></p><p>上图指的地方又用到了几个 Representation，下面逐一进去看看：</p><h3 id="Activity-h"><a href="#Activity-h" class="headerlink" title="Activity.h"></a>Activity.h</h3><p><code>Bhuman/BHumanCodeRelease-coderelease2017/Src/Modules/BehaviorControl/BehaviorControl/Options/Output/Activity.h</code>，看到如图的东西，那这个 BehaviorStatus 又有些什么功能呢？</p><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1s7vs9tnaj31g40retgw.jpg" alt="Activity.h"></p><h3 id="BehaviorStatus-h"><a href="#BehaviorStatus-h" class="headerlink" title="BehaviorStatus.h"></a>BehaviorStatus.h</h3><p><code>Bhuman/BHumanCodeRelease-coderelease2017/Src/Representations/BehaviorControl/BehaviorStatus.h</code>。</p><p>这个文件声明了一个结构体，其中包含关于当前行为状态的数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ENUM</span>(Activity,</span><br><span class="line">&#123;,</span><br><span class="line">  unknown,</span><br><span class="line">  blocking,   <span class="comment">// 阻塞</span></span><br><span class="line">  duel,       <span class="comment">// 决斗</span></span><br><span class="line">  dribble,    <span class="comment">// 运球</span></span><br><span class="line">  dribbleDuel,<span class="comment">// </span></span><br><span class="line">  searchForBall,  <span class="comment">// 找球</span></span><br><span class="line">  searchForBallAtRecentPosition,  <span class="comment">// 在附近的位置找球</span></span><br><span class="line">  goToBall,   <span class="comment">// 走向球</span></span><br><span class="line">  takingPosition, <span class="comment">// 取得位置</span></span><br><span class="line">  kick,   <span class="comment">// 踢球</span></span><br><span class="line">  guardGoal,  <span class="comment">// 保护目标</span></span><br><span class="line">  catchBall,  <span class="comment">// 控制住球</span></span><br><span class="line">  standAndWait,   <span class="comment">// 站住 等待</span></span><br><span class="line">  passing,    <span class="comment">// 带球？</span></span><br><span class="line">  gettingUp,  <span class="comment">// 站起来</span></span><br><span class="line">  turn,   </span><br><span class="line">  walkNextToKeeper,</span><br><span class="line">  kickoff,    <span class="comment">// 开球</span></span><br><span class="line"></span><br><span class="line">  waving,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><p>Ok，现在我们退回到 GetUp.h 中继续看。</p><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1s83yxataj30xc0hi42s.jpg"></p><hr><h3 id="HeadControlMode-h"><a href="#HeadControlMode-h" class="headerlink" title="HeadControlMode.h"></a>HeadControlMode.h</h3><p>进来可以看到，这个文件主要是一些头部的控制 mode，在上面调用了 lookForward。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">路径：Bhuman/BHumanCodeRelease-coderelease2017/Src/Modules/BehaviorControl/BehaviorControl/Options/HeadControl</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1s8au5aawj30gu0cgmz6.jpg"></p><h3 id="LookForward-h"><a href="#LookForward-h" class="headerlink" title="LookForward.h"></a>LookForward.h</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Pun intended. Looks straight ahead in a way that the Nao V4&#x27;s cameras cover the area in front of its feet as well as everything else in front of the robot.*/</span></span><br><span class="line"><span class="built_in">option</span>(LookForward, (<span class="type">float</span>)(<span class="number">0.38f</span>) tilt, (<span class="type">float</span>)(<span class="number">0.f</span>) pan)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/** Simply sets the necessary angles */</span></span><br><span class="line">  <span class="built_in">initial_state</span>(lookForward)</span><br><span class="line">  &#123;</span><br><span class="line">    action</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 参数：pan 角度 速度</span></span><br><span class="line">      <span class="built_in">SetHeadPanTilt</span>(pan, tilt, <span class="number">150</span>_deg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，到这里就基本可以了，最后一句调用了 <code>GetUpEngine()</code>，这个接口在<code>Bhuman/BHumanCodeRelease-coderelease2017/Src/Modules/MotionControl/GetUpEngine</code>下，这是一个mini的站立运动引擎，控制各个关节执行一些动作让 Nao 站起来。</p><p>到这里 GetUp.h 就做完了。</p><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>其实这篇文章我就是想记录下来如何一步一步进去，然后再出来。</p><p>在 CABSL 行为控制刚开始学习的过程中，我觉得这样的方式还是有助于对代码的理解。</p><p>OK，睡觉。</p><hr>]]></content>
      
      
      <categories>
          
          <category> Nao机器人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nao机器人 </tag>
            
            <tag> BHuman </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Nao机器人】CABSL有限状态机</title>
      <link href="/2019/04/03/Nao%E6%9C%BA%E5%99%A8%E4%BA%BA-CABSL/"/>
      <url>/2019/04/03/Nao%E6%9C%BA%E5%99%A8%E4%BA%BA-CABSL/</url>
      
        <content type="html"><![CDATA[<p>这里主要总结下最近看的关于 CABSL 的代码和资料。</p><p>行为规范语言 CABSL （有限状态机）控制机器人在比赛中的行为。B-Human 系统中执行动作选择的部分称为行为控制。</p><span id="more"></span><p>😁 下面这个图放大其实还清楚，在官方文档的 6.1 节。</p><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1pt6yuhf7j30vw17sh6h.jpg" alt="6-1"></p><h2 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h2><p>机器人比赛执行的策略文件都在<code>Modules/BehaviorControl/BehaviorControl/Options</code>下，Roles 中包含了Bhuman 源码中自带的一个Striker Demo。</p><p>Soccer.h 是 Bhuman 代码执行的根目录，Nao开机后就会执行 Soccer.h 中的代码。</p><p>在注释中触发实际足球行为的主要状态，这里调用的是<code>Modules/BehaviorControl/BehaviorControl/Options/GameControl/HandlePenaltyState.h</code>，对应的状态为：按一次胸口 Nao 站起来(upright)，两次进入惩罚模式(penalized)，三个非惩罚(notPenalized)，开始执行 Striker 的代码。</p><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1ptjrxpclj32lc1i0x6q.jpg" alt="Soccer.h"></p><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1ptrjs3zkj32lc1i0x6q.jpg" alt="HandlePenaltyState.h"></p><p>在<code>HandlePenaltyState.h</code>的最后，我们可以看到：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Play soccer! */</span></span><br><span class="line"><span class="built_in">state</span>(playing)</span><br><span class="line">&#123;</span><br><span class="line">  action</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">PlayingState</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进到 <code>PlayingState.h</code> 中：</p><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1ptv6048zj313o0us17z.jpg" alt="PlayingState.h"></p><p>好吧，终于进来了，如上面所说，最终调用到<code>Striker()</code>这个前锋Demo：</p><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1ptxc11hlj32lc1i0qv6.jpg" alt="Demo.h"></p><h2 id="CABSL"><a href="#CABSL" class="headerlink" title="CABSL"></a>CABSL</h2><blockquote><p>在 CABSL 中，使用了以下的基本元素：options(选项), states(状态), transitions(转换), actions(动作)。一个行为由一组在选项图中排列的选项组成。有一个单一的启动选项，所有其他选项都被调用;这是选项图的root。每个选项都是有限状态机，它􏰉述了一个特定的行为部分，比如机器人的技能或头部运动，或者它结合了这样的基本特征。每个选项都以它的 intital_state 开始。在一个状态中，可以执行的动作可以调用另一个选项，并执行任何 c++代码，例如修改行为控制􏰈供的 representations。此外，在每个状态内都有一项关于转换到另一个状态(在选项内)的决定。像动作一样，转换能够执行 c++代码。【译 6.1】</p></blockquote><h3 id="option"><a href="#option" class="headerlink" title="option"></a>option</h3><h4 id="common-transition"><a href="#common-transition" class="headerlink" title="common_transition"></a>common_transition</h4><p>option 可以理解为机器娃的一套动作。</p><p>在每一个 option 中 <code>common_transition</code> 是<strong>全局的（此option）</strong>不停运行的逻辑判断，优先级别最高，不论当前执行到哪一个 state，只要满足了 <code>common_transition</code> 中的条件，就会跳出，goto 到指定的另一个 option。</p><p><em>如下图中，当摄像头不 ok 他就一直 sitDown。</em></p><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1pu8o6j5hj316o0c87eq.jpg"></p><h4 id="state"><a href="#state" class="headerlink" title="state"></a>state</h4><p>state 是一种状态，只能通过 goto 进入。state 中有普通的 transition(不是必须有) 和 action。</p><p>action 是执行的一些动作，可以是某些函数或者跳到别的地方。transition 是在这个 state 中一直在判断，当满足条件就 goto 跳转。</p><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1puj34yljj31ik0hgngj.jpg" alt="state"></p><h4 id="initial-state"><a href="#initial-state" class="headerlink" title="initial_state"></a>initial_state</h4><p>initial_state 是进 option 中的初始化状态，进入 option 后自动执行 initial_state 中的行为。</p><h4 id="action-done"><a href="#action-done" class="headerlink" title="action_done"></a>action_done</h4><p>action_done 表示 state 中的 action 执行完毕在 transition 中判断 action_done 可以在 state 动作执行完后跳到别的 state 中。</p><h4 id="action-aborted"><a href="#action-aborted" class="headerlink" title="action_aborted"></a>action_aborted</h4><p>action_aborted 表示动作未执行完或者意外终止。</p><hr>]]></content>
      
      
      <categories>
          
          <category> Nao机器人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nao机器人 </tag>
            
            <tag> BHuman </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Nao机器人】BHuman项目结构</title>
      <link href="/2019/04/02/Nao%E6%9C%BA%E5%99%A8%E4%BA%BA-BHuman%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2019/04/02/Nao%E6%9C%BA%E5%99%A8%E4%BA%BA-BHuman%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>学习 bhuman 代码。</p><span id="more"></span><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1odavs8t0j31fc11ge23.jpg" alt="BHuman代码结构"></p><h2 id="Build"><a href="#Build" class="headerlink" title="Build"></a>Build</h2><p>是编译好的可执行文件，其中包括 Nao 的可执行文件和两个以来的库，分为三个版本(debug、develop、release)。</p><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1odg3ufpuj311y0l0acx.jpg" alt="Build"></p><h2 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h2><p>Config 中是一些配置文件(场地大小了、机器人走路姿态等等)。</p><p>具体的在<a href="http://ahoj.cc/2019/03/Nao%E6%9C%BA%E5%99%A8%E4%BA%BA-BHuman%E4%B8%AD%E7%9A%84Config/">http://ahoj.cc/2019/03/Nao%E6%9C%BA%E5%99%A8%E4%BA%BA-BHuman%E4%B8%AD%E7%9A%84Config/</a> <img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1odnvts9tj30lg0lewhd.jpg" alt="Config"></p><h2 id="Src"><a href="#Src" class="headerlink" title="Src"></a>Src</h2><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1odrsngwyj30jq0bemye.jpg" alt="Src"></p><p>在 Src 中包含了整个项目的源码，其中比较重要的就是 Representations 和 Modules 两个目录。</p><h3 id="Representations-和-Modules"><a href="#Representations-和-Modules" class="headerlink" title="Representations 和 Modules"></a>Representations 和 Modules</h3><p>Representations 是可调用的部分，通过其中提供的一些接口来完成机器人的一些动作。</p><p>Modules 是 Representations 的实现部分。</p><h4 id="Representations"><a href="#Representations" class="headerlink" title="Representations"></a>Representations</h4><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1odxlq7jfj30im0a6ta0.jpg" alt="Representations"></p><p>Representations 中包含 8 个模块，具体待我再研究研究。</p><h4 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h4><p>在 Modules 下的这个目录(如图)，存放我们踢球的角色文件，BHuman官方给出一个 striker 作为 Demo。</p><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1oe0h8g3qj30io0hedic.jpg" alt="Modules"></p><p><strong>Options.h</strong> 包含所有Options中的文件的路径，通过一个c++头文件将其关联在一起。</p><blockquote><p>All option files that belong to the current behavior have to be included by this file.</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1oe3ceev2j32lc1i0kjm.jpg" alt="Options.h"></p><p><strong>BehaviorControl.h</strong> 包含options文件中所调用的函数，关联调用的Representations中的文件</p><blockquote><p>Declaration of the C-based state machine behavior control module.</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1oe5o9zdwj32lc1i0x6q.jpg" alt="BehaviorControl"></p><hr><p>继续看~</p><hr>]]></content>
      
      
      <categories>
          
          <category> Nao机器人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nao机器人 </tag>
            
            <tag> BHuman </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nodejs-数据通信</title>
      <link href="/2019/04/01/JavaScript-Nodejs-%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/"/>
      <url>/2019/04/01/JavaScript-Nodejs-%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h2><p>fetch 是原生的用来替代 ajax 进行数据交互的。</p><h3 id="解析text"><a href="#解析text" class="headerlink" title="解析text"></a>解析text</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">    window.onload=function ()&#123;</span><br><span class="line">      let oBtn=document.getElementById(&#x27;btn1&#x27;);</span><br><span class="line">      oBtn.onclick=async function ()&#123;</span><br><span class="line">        //1.请求数据</span><br><span class="line">        let res=await fetch(&#x27;data/1.txt&#x27;);</span><br><span class="line">        //2.解析</span><br><span class="line">        let str=await res.text();</span><br><span class="line"></span><br><span class="line">        alert(str);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot; value=&quot;读取&quot; id=&quot;btn1&quot;&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="解析JSON"><a href="#解析JSON" class="headerlink" title="解析JSON"></a>解析JSON</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">    window.onload=function ()&#123;</span><br><span class="line">      let oBtn=document.getElementById(&#x27;btn1&#x27;);</span><br><span class="line">      oBtn.onclick=async function ()&#123;</span><br><span class="line">        //1.请求</span><br><span class="line">        let res=await fetch(&#x27;data/1.json&#x27;);</span><br><span class="line">        //2.解析</span><br><span class="line">        let json=await res.json();</span><br><span class="line"></span><br><span class="line">        console.log(json);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot; value=&quot;读取&quot; id=&quot;btn1&quot;&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="解析二进制数据blob"><a href="#解析二进制数据blob" class="headerlink" title="解析二进制数据blob"></a>解析二进制数据blob</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">    window.onload=function ()&#123;</span><br><span class="line">      let oImg=document.getElementById(&#x27;img1&#x27;);</span><br><span class="line">      let oBtn=document.getElementById(&#x27;btn1&#x27;);</span><br><span class="line">      oBtn.onclick=async function ()&#123;</span><br><span class="line">        //1.请求</span><br><span class="line">        let res=await fetch(&#x27;data/1.png&#x27;);</span><br><span class="line">        //2.解析</span><br><span class="line">        let data=await res.blob();</span><br><span class="line">        let url=URL.createObjectURL(data);// 其实这个 url 是把这个图片的二进制数据写到Chrome的临时文件去(小的内存里，大的放文件，后面删)</span><br><span class="line"></span><br><span class="line">        oImg.src=url;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot; value=&quot;读取&quot; id=&quot;btn1&quot;&gt;</span><br><span class="line">    &lt;img id=&quot;img1&quot; /&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="ajax-2-0"><a href="#ajax-2-0" class="headerlink" title="ajax 2.0"></a>ajax 2.0</h2><p>主要是 FormData 对象。(其实就是一个表单数据)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;form id=&quot;form1&quot; action=&quot;http://localhost:8080/&quot; method=&quot;post&quot;&gt;</span><br><span class="line">      用户：&lt;input type=&quot;text&quot; name=&quot;user&quot; /&gt;&lt;br&gt;</span><br><span class="line">      密码：&lt;input type=&quot;password&quot; name=&quot;pass&quot; /&gt;&lt;br&gt;</span><br><span class="line">      文件：&lt;input type=&quot;file&quot; name=&quot;f1&quot; /&gt;&lt;br&gt;</span><br><span class="line">      &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">  let oForm=document.querySelector(&#x27;#form1&#x27;);</span><br><span class="line"></span><br><span class="line">  oForm.onsubmit=function ()&#123;</span><br><span class="line">    let formdata=new FormData(oForm);</span><br><span class="line"></span><br><span class="line">    let xhr=new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">    xhr.open(oForm.method, oForm.action, true);</span><br><span class="line">    xhr.send(formdata);</span><br><span class="line"></span><br><span class="line">    xhr.onreadystatechange=function ()&#123;</span><br><span class="line">      if(xhr.readyState==4)&#123;</span><br><span class="line">        if(xhr.status==200)&#123;</span><br><span class="line">          alert(&#x27;成功&#x27;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">          alert(&#x27;失败&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return false; // 阻止表单自己的提交事件</span><br><span class="line">  &#125;;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="使用-jQuery-来处理-FormData"><a href="#使用-jQuery-来处理-FormData" class="headerlink" title="使用 jQuery 来处理 FormData"></a>使用 jQuery 来处理 FormData</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;form id=&quot;form1&quot; action=&quot;http://localhost:8080/&quot; method=&quot;post&quot;&gt;</span><br><span class="line">      用户：&lt;input type=&quot;text&quot; name=&quot;user&quot; /&gt;&lt;br&gt;</span><br><span class="line">      密码：&lt;input type=&quot;password&quot; name=&quot;pass&quot; /&gt;&lt;br&gt;</span><br><span class="line">      文件：&lt;input type=&quot;file&quot; name=&quot;f1&quot; /&gt;&lt;br&gt;</span><br><span class="line">      &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">  &lt;script src=&quot;jquery.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">  $(&#x27;#form1&#x27;).on(&#x27;submit&#x27;, function ()&#123;</span><br><span class="line">    let formdata=new FormData(this);</span><br><span class="line"></span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">      url: this.action,</span><br><span class="line">      type: this.method,</span><br><span class="line">      data: formdata,</span><br><span class="line">      processData: false,// 告诉 jQuery 不要瞎处理我的数据</span><br><span class="line">      contentType: false// 不要随便改 contentType，我传什么是什么</span><br><span class="line">    &#125;).then(res=&gt;&#123;</span><br><span class="line">      alert(&#x27;成功&#x27;);</span><br><span class="line">    &#125;, res=&gt;&#123;</span><br><span class="line">      alert(&#x27;失败&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return false; // 阻止表单自己的提交事件</span><br><span class="line">  &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="webSocket"><a href="#webSocket" class="headerlink" title="webSocket"></a>webSocket</h2><p>性能高、双向。</p><p>包：<code>socket.io</code>，简单、方便、兼容 IE5、自动解析数据。</p><h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http=<span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> io=<span class="built_in">require</span>(<span class="string">&#x27;socket.io&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.建立普通http</span></span><br><span class="line"><span class="keyword">let</span> server=http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>)=&gt;</span>&#123;&#125;);</span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.建立ws</span></span><br><span class="line"><span class="keyword">let</span> wsServer=io.<span class="title function_">listen</span>(server);</span><br><span class="line">wsServer.<span class="title function_">on</span>(<span class="string">&#x27;connection&#x27;</span>, <span class="function"><span class="params">sock</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">//sock.emit(&#x27;name&#x27;, 数据)</span></span><br><span class="line">  <span class="comment">//sock.on(&#x27;name&#x27;, function (数据)&#123;&#125;);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接收前端发过来的数据</span></span><br><span class="line">  sock.<span class="title function_">on</span>(<span class="string">&#x27;aaa&#x27;</span>, <span class="keyword">function</span> (<span class="params">a, b</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, a+b);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向前端发数据</span></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    sock.<span class="title function_">emit</span>(<span class="string">&#x27;timer&#x27;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>());</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">dir</span>=<span class="string">&quot;ltr&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://localhost:8080/socket.io/socket.io.js&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">let</span> sock=io.<span class="title function_">connect</span>(<span class="string">&#x27;ws://localhost:8080/&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    sock.<span class="title function_">emit</span>(<span class="string">&#x27;aaa&#x27;</span>, <span class="number">12</span>, <span class="number">5</span>);  <span class="comment">// 向服务器发数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">let</span> on = sock.<span class="title function_">on</span>(<span class="string">&#x27;timer&#x27;</span>, <span class="function"><span class="params">time</span>=&gt;</span>&#123;  <span class="comment">// 接收服务器发的数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(time);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nodejs-ajax跨域</title>
      <link href="/2019/03/31/JavaScript-Nodejs-ajax%E8%B7%A8%E5%9F%9F/"/>
      <url>/2019/03/31/JavaScript-Nodejs-ajax%E8%B7%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http=<span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> allowOrigin=&#123;</span><br><span class="line">  <span class="string">&#x27;http://localhost&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&#x27;http://aaa.com&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&#x27;https://aaa.com&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123;origin&#125;=req.<span class="property">headers</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(allowOrigin[origin])&#123;</span><br><span class="line">    res.<span class="title function_">setHeader</span>(<span class="string">&#x27;access-control-allow-origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  res.<span class="title function_">write</span>(<span class="string">&#x27;&#123;&quot;a&quot;: 12, &quot;b&quot;: &quot;Blue&quot;&#125;&#x27;</span>);</span><br><span class="line">  res.<span class="title function_">end</span>();</span><br><span class="line">&#125;).<span class="title function_">listen</span>(<span class="number">8080</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">dir</span>=<span class="string">&quot;ltr&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">onload</span>=<span class="keyword">function</span> (<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> oBtn=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn1&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      oBtn.<span class="property">onclick</span>=<span class="keyword">function</span> (<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> ajax=<span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        ajax.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;http://localhost:8080/a&#x27;</span>, <span class="literal">true</span>);</span></span><br><span class="line"><span class="language-javascript">        ajax.<span class="title function_">send</span>();</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        ajax.<span class="property">onreadystatechange</span>=<span class="keyword">function</span> (<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="comment">// readyState 0~4</span></span></span><br><span class="line"><span class="language-javascript">          <span class="comment">// 0：初始化1：已连接 2：已发送 3：响应头已经接收到 4：相应体已经接受</span></span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">if</span>(ajax.<span class="property">readyState</span>==<span class="number">4</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span>(ajax.<span class="property">status</span>&gt;=<span class="number">200</span> &amp;&amp; ajax.<span class="property">status</span>&lt;<span class="number">300</span> || ajax.<span class="property">status</span>==<span class="number">304</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">              <span class="title function_">alert</span>(<span class="string">&#x27;成功&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">              <span class="keyword">let</span> json=<span class="title class_">JSON</span>.<span class="title function_">parse</span>(ajax.<span class="property">responseText</span>);</span></span><br><span class="line"><span class="language-javascript">              <span class="variable language_">console</span>.<span class="title function_">log</span>(json);</span></span><br><span class="line"><span class="language-javascript">            &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="language-javascript">              <span class="title function_">alert</span>(<span class="string">&#x27;失败&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript">      &#125;;</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;请求&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><p>ajax为什么不能跨域？</p><p>SOP：同源策略，你代码请求的资源应该和你在一个域名下，如果不是，浏览器会禁止这个请求。</p><p>ajax是被谁阻止住的？</p><p>不是服务器，是浏览器阻止的，这是浏览器的一种”自律”的行为。</p><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1mbdhmy8kj318c0l877m.jpg"></p><p>服务器是一定会响应的，响应后如果不是同源，浏览器会把这个东西扔掉。</p><p>所以这个时候需要服务器返回数据的时候需要声明一下，声明我们是一家子(就是声明哪些人可以从我这里获取数据)，如上代码。</p><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nodejs-几个系统包</title>
      <link href="/2019/03/31/JavaScript-Nodejs-%E5%87%A0%E4%B8%AA%E7%B3%BB%E7%BB%9F%E5%8C%85/"/>
      <url>/2019/03/31/JavaScript-Nodejs-%E5%87%A0%E4%B8%AA%E7%B3%BB%E7%BB%9F%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">assert</span>(<span class="number">5</span>&lt;<span class="number">3</span>, <span class="string">&#x27;aaa&#x27;</span>);</span><br><span class="line"></span><br><span class="line">assert.<span class="title function_">deepEqual</span>(变量, 预期值, msg); <span class="comment">// 深度比较，相当于 ==</span></span><br><span class="line">assert.<span class="title function_">deepStrictEqual</span>(变量, 预期值, msg);<span class="comment">// 相当于 === (比较类型)</span></span><br></pre></td></tr></table></figure><h2 id="path"><a href="#path" class="headerlink" title="path"></a>path</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path=<span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str=<span class="string">&#x27;/root/a/b/1.txt&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">dirname</span>(str));<span class="comment">// 文件夹名 /root/a/b</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">extname</span>(str));<span class="comment">// 扩展名 .txt</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">basename</span>(str));<span class="comment">// 文件名 1.txt</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">resolve</span>(<span class="string">&#x27;/root/a/b&#x27;</span>, <span class="string">&#x27;../c&#x27;</span>, <span class="string">&#x27;build&#x27;</span>, <span class="string">&#x27;..&#x27;</span>, <span class="string">&#x27;strict&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;build&#x27;</span>));</span><br><span class="line"><span class="comment">// __dirname 类似于C中的宏，是当前路径</span></span><br></pre></td></tr></table></figure><h2 id="url"><a href="#url" class="headerlink" title="url"></a>url</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> url=<span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str=<span class="string">&#x27;http://www.bing.com:8080/a/b/1.html?a=1&amp;a=2&amp;a=3&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(url.<span class="title function_">parse</span>(str, <span class="literal">true</span>));<span class="comment">// true表示解析后面的参数(query)，解析成 JSON，不加true就是一个字符串</span></span><br></pre></td></tr></table></figure><h2 id="querystring"><a href="#querystring" class="headerlink" title="querystring"></a>querystring</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> querystring=<span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(querystring.<span class="title function_">parse</span>(<span class="string">&quot;a=12&amp;b=5&amp;c=99&quot;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(querystring.<span class="title function_">stringify</span>(&#123;<span class="attr">a</span>: <span class="number">12</span>, <span class="attr">b</span>: <span class="number">99</span>, <span class="attr">c</span>: <span class="string">&#x27;blue&#x27;</span>&#125;));</span><br></pre></td></tr></table></figure><h2 id="net"><a href="#net" class="headerlink" title="net"></a>net</h2><p>网络通信。</p><p><strong>OSI七层参考模型</strong><br>物理层 &gt; 数据链路层 &gt; 网络层(IP) &gt; 传输层(TCP) &gt; 会话层 &gt; 表现层 &gt; 应用层(HTTP)</p><p><strong>5层模型</strong><br>物理层 &gt; 数据链路层 &gt; 网络层(IP) &gt; 传输层(TCP) &gt; 应用层(HTTP)</p><p>net就是传输层(TCP)的一个包，可以保证质量。</p><hr><p>TCP：保证质量，特别适合网络传输文件，不能丢数据。</p><p>UDP：保证速度，特别适合网络视频直播等，丢一两帧问题不大。</p><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nodejs-处理POST文件数据</title>
      <link href="/2019/03/31/JavaScript-Nodejs-%E5%A4%84%E7%90%86POST%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE/"/>
      <url>/2019/03/31/JavaScript-Nodejs-%E5%A4%84%E7%90%86POST%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">dir</span>=<span class="string">&quot;ltr&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://localhost:8080/upload&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">      用户：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;f1&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Nodejs中原生不带处理文件数据的包。</p><p>POST 文件：</p><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1maxevu28j30ua0ko485.jpg"></p><h2 id="原生处理"><a href="#原生处理" class="headerlink" title="原生处理"></a>原生处理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST文件</span><br><span class="line">&lt;分隔符&gt;\r\n字段信息\r\n\r\n内容\r\n&lt;分隔符&gt;\r\n字段头\r\n\r\n内容\r\n&lt;分隔符&gt;\r\n字段头\r\n\r\n内容\r\n&lt;分隔符&gt;--</span><br></pre></td></tr></table></figure><ol><li>用&lt;分隔符&gt;切分</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  null,</span><br><span class="line">  &quot;\r\n字段信息\r\n\r\n内容\r\n&quot;,</span><br><span class="line">  &quot;\r\n字段信息\r\n\r\n内容\r\n&quot;,</span><br><span class="line">  &quot;\r\n字段信息\r\n\r\n内容\r\n&quot;,</span><br><span class="line">  &#x27;--&#x27;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ol start="2"><li>第0个和最后1个，扔掉</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &quot;\r\n字段信息\r\n\r\n内容\r\n&quot;,</span><br><span class="line">  &quot;\r\n字段信息\r\n\r\n内容\r\n&quot;,</span><br><span class="line">  &quot;\r\n字段信息\r\n\r\n内容\r\n&quot;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ol start="3"><li>每一项</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;\r\n字段信息\r\n\r\n内容\r\n&quot;</span><br><span class="line"></span><br><span class="line">&quot;字段信息\r\n\r\n内容&quot;</span><br><span class="line">&quot;字段信息&quot;, &quot;内容&quot;</span><br></pre></td></tr></table></figure><h2 id="multiparty-包"><a href="#multiparty-包" class="headerlink" title="multiparty 包"></a>multiparty 包</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><code>npm i multiparty -D</code></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http=<span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> multiparty=<span class="built_in">require</span>(<span class="string">&#x27;multiparty&#x27;</span>);</span><br><span class="line"></span><br><span class="line">http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> form=<span class="keyword">new</span> multiparty.<span class="title class_">Form</span>(&#123;</span><br><span class="line">    <span class="attr">uploadDir</span>: <span class="string">&#x27;./upload&#x27;</span><span class="comment">// 上传到哪里</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  form.<span class="title function_">parse</span>(req);</span><br><span class="line"></span><br><span class="line">  form.<span class="title function_">on</span>(<span class="string">&#x27;field&#x27;</span>, <span class="function">(<span class="params">name, value</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;字段：&#x27;</span>, name, value);</span><br><span class="line">  &#125;);</span><br><span class="line">  form.<span class="title function_">on</span>(<span class="string">&#x27;file&#x27;</span>, <span class="function">(<span class="params">name, file</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;文件：&#x27;</span>, name, file);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  form.<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;表单解析完成&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).<span class="title function_">listen</span>(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure><p>上传的文件名是随机的，重名概率不大(特别小)，万一重复就会覆盖之前的文件。</p><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Nao机器人】机器人校准</title>
      <link href="/2019/03/31/Nao%E6%9C%BA%E5%99%A8%E4%BA%BA-%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%A0%A1%E5%87%86/"/>
      <url>/2019/03/31/Nao%E6%9C%BA%E5%99%A8%E4%BA%BA-%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%A0%A1%E5%87%86/</url>
      
        <content type="html"><![CDATA[<p>正确校准的机器人非常重要，因为软件要求NAO的所有部件都在预期的位置。否则，NAO将无法稳定行走，从图像坐标投影到世界坐标(反之亦然)将是错误的。<br>一般来说，很多计算都是不可靠的。NAO的两个物理组件可以通过SimRobot进行校准，关节和摄像机。经常检查这些校准是很重要的，特别是对关节来说。<br>随着时间的推移和使用，关节会磨损。尤其是髋关节。除此之外，B-Human软件还使用四种颜色类(官方文档4.1.4节)，这些颜色类也需要校准。改变位置或光照条件可能需要对其进行调整。</p><span id="more"></span><h2 id="整体物理校准"><a href="#整体物理校准" class="headerlink" title="整体物理校准"></a>整体物理校准</h2><p>物理校准过程可以分为三个步骤，总体目标是一个直立的机器人，以及一个正确校准的相机。</p><p>第一步：让双脚处于一个平面的位置。这并不意味着机器人必须站直。这是通过把机器人抬起来，这样就可以看到脚的底部。然后改变脚和腿的关节偏移量，直到两脚都是平面的，两腿平行。两条腿之间的距离可以在腿的灰色部分测量。它们之间的距离应该是10厘米。</p><p>第二步：<a href="#%E7%9B%B8%E6%9C%BA%E6%A0%A1%E5%87%86">相机校准</a>。这个步骤还可以测量身体相对于脚的倾斜程度。该测量可用于第三步。</p><p>第三步：使用第二步的测量量以改进关节的校准和机器人的扶正。在某些情况下，可能需要重复这些步骤，因为联合校准中的大变化可能使相机校准无效。</p><h2 id="关节校准"><a href="#关节校准" class="headerlink" title="关节校准"></a>关节校准</h2><p>BHuman 支持两种关节校准方法。一是通过手动调整每个关节的偏移量；二是使用使用逆运动学的关节校准模块来校准。<br>整个校准过程的第三步(整体物理校准的第三步)只能通过关节校准器完成。在这两种方法之间切换时，需要<strong>保存关节校准，重新部署NAO，重启bhuman</strong>。否则，前面做的更改将不会生效。</p><p>在改变关节偏移量之前，机器人必须处于固定关节角度的站立位置。否则，运动引擎的平衡机构可能会移动腿，打乱关节的校准。<br>使用：<code>get representation:MotionRequest</code>，在返回的语句中设置<code>motion = stand</code>，校准完成后记得保存，<code>save representation:JointCalibration</code>。</p><h3 id="手动调整关节偏差"><a href="#手动调整关节偏差" class="headerlink" title="手动调整关节偏差"></a>手动调整关节偏差</h3><p>首先，机器人必须切换到一个固定的支架上，否则运动引擎的平衡机械手可能会移动机器人的腿，打乱关节的校准：<code>mr StandArmRequest CalibrationStand</code>，<code>mr StandLegRequest CalibrationStand</code>。</p><p>有两种方法可以调整关节偏移。<br>要么使用 get 来请求 JointCalibration 表示形式：<code>get representation:JointCalibration</code>修改返回的校准，然后设置它。<br>要么通过使用数据视图，更加方便：<code>vd representation:JointCalibration</code>。</p><p>⚠️ 注意：JointCalibration 还包含每个关节的其他信息，不应该改变！</p><h3 id="使用关节校准器-JointCalibrator"><a href="#使用关节校准器-JointCalibrator" class="headerlink" title="使用关节校准器(JointCalibrator)"></a>使用关节校准器(JointCalibrator)</h3><p>首先设置关节校准器，提供关节校准器并切换到校准台：<code>call Calibrators/Joint</code><br>当需要全新校准时，可对关节校准进行复位：<code>dr module:JointCalibrator:reset</code><br>然后，可以修改脚的平移和旋转。再次使用：<code>get module:JointCalibrator:offsets</code>或：<code>vd module:JointCalibrator:offsets</code></p><p>⚠️ 注意：调整的单位是毫米，旋转是度数为基准的。</p><h3 id="让-Nao-直立"><a href="#让-Nao-直立" class="headerlink" title="让 Nao 直立"></a>让 Nao 直立</h3><p>相机校准还计算身体旋转的旋转。这些值可以传递给关节校准器，然后将NAO设置在垂直位置。命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">get representation:CameraCalibration </span><br><span class="line">call Calibrators/Joint</span><br></pre></td></tr></table></figure><p>将 bodyRotationCorrection(CameraCalibration 表示)的值复制到 bodyRotation (JointCalibration 表示)中。之后，设置 bodyRotationCorrection(CameraCalibration 表示) 为零。通过使用具有自动化标志的自动相机校准器，可以自动或多或少地使这些动作成为可能。</p><p>最后一步是在同一时间调整双脚的移动(大部分时间是在同一方向)，使它们垂直于躯干下方。直线激光对这项任务非常有用。当全部操作完成时，通过执行下面的命令来保存校准：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">save representation:JointCalibration </span><br><span class="line">save representation:CameraCalibration</span><br></pre></td></tr></table></figure><p>然后重新部署NAO并重新启动bhuman。</p><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1lxci0ou4j31fg0nihdt.jpg" alt="机器人校准2.1"></p><p>图：校准程序之前(a)和之后(b)的投影线</p><h2 id="相机校准"><a href="#相机校准" class="headerlink" title="相机校准"></a>相机校准</h2><p>使用 AutomaticCameraCalibrator 模块校准相机(参考4.1.2.1节)，请遵循以下步骤：</p><ol><li>将模拟器连接到现场的机器人，并将其放置在确定的位置上(例如，罚球线)。 </li><li>运行SimRobot配置文件Calibrators/Camera.con(在控制台输入 <code>call Calibrators/Camera</code>)。这将初始化校准过程，并进一步将命令或帮助打印到稍后将需要的模拟器控制台。</li><li>使用AutomaticCameraCalibrator模块(自动相机校准模块)，例如将机器人放在罚球线，控制台输入<code>set module:AutomaticCameraCalibrator:robotPose rotation = 0;translation= &#123;x = -3200;y = 0;&#125;</code>，来宣告机器人在球场上的位置。</li><li>若要自动生成以下关节校准的命令以纠正身体旋转，可通过：<code>set module:AutomaticCame raCalibrator:setJointOffsets true</code>，优化完成后，只需输入生成的命令，从而纠正旋转。</li><li>启动点收集：<code>dr module:AutomaticCameraCalibrator:start</code>，然后等待输出”Accumulation finished. Waiting to optimize. . . “。这个过程包括：两个摄像头采集样本进行校准，头部运动覆盖整个场地。<strong>上面相机的样本是蓝色的，下面相机的样本是红色的。</strong>图像上方的图形表示样本数量是否足以优化，可以(绿色)不可以(红色)。</li><li>如果对某些特定示例的集合不满意，可以通过左击找到示例的图像中的示例来删除示例。如果缺少一些示例，可以通过<code>Ctrl+左键单击</code>将它们手动添加到相应的图像中。</li><li>使用自动校准程序：<code>dr module:AutomaticCameraCalibrator:optimize</code>，然后等待优化收敛。</li></ol><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1lxz0nn55j31aa0d8tzx.jpg"></p><p>图：三个有趣的相机校准阶段。a)为校准器的起点。b)为控件从采集的样本开始后的视图。c)为优化后的阶段。</p><h2 id="颜色校准"><a href="#颜色校准" class="headerlink" title="颜色校准"></a>颜色校准</h2><p>校准颜色类分为两个步骤。</p><p>首先：相机驱动程序的参数必须根据环境的需要进行更新。使用<code>get representation:CameraSettings</code>返回当前摄像机的参数。</p><p>此外：将生成必要的set命令。一些比较重要的参数：</p><ul><li><strong>whiteBalanceTemperature：</strong> 白平衡。可用区间为[2700,6500]。</li><li><strong>exposure：</strong> 曝光，可用区间为[0,1000]。通常，使用140的曝光，等于14毫秒。数值越大，图像越模糊。</li><li><strong>gain：</strong> 增益，可用区间为[0,255]。通常，增益设置为50 - 70。高增益值会导致图像嘈杂。</li><li><strong>autoWhiteBalance：</strong> 启用(1)/禁用(0)自动白平衡。此参数应<strong>始终禁用</strong>，因为白平衡中的更改可能会更改颜色并打乱颜色校准。另一方面，环境色温的真实变化也会产生同样的结果。</li><li><strong>autoExposure：</strong> 启用(1)/禁用(0)自动曝光。在标准室内锦标赛等静态灯光条件下进行比赛时，应始终禁用此参数，因为自动化往往会选择高于需要的值，从而导致图像模糊。然而，对于2016年机器人世界杯户外比赛中出现的动态光环境，使用相机驱动程序的自动化可能是必要的。在这种情况下，可以使用参数autoExposureAlgorithm和亮度来改变其行为。</li></ul><p>相机驱动程序可以做一次自动白平衡。该功能可以通过以下命令触发：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dr module:CameraProvider:doWhiteBalanceUpper </span><br><span class="line">dr module:CameraProvider:doWhiteBalanceLower</span><br></pre></td></tr></table></figure><p>在设置好相机驱动程序的参数后，必须更新color类的参数(cf. section . 4.1.4)。为此，需要使用分割的上下摄像头图像和颜色校准视图打开视图，(参看第10.1.4.1节和第10.1.4.1节)。完成color类校准并保存当前参数后，可以使用copyfiles/bush来部署当前设置。确保文件cameraSettingsV5.cfg(或cameraSettingsV4.cfg，如果NAO是V4模型)和fieldColorsCalibrationV5.cfg(或fieldColorsCalibrationV4.cfg)更新了并存储在正确的位置。</p><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1lydfjatyj31720gae81.jpg"></p><p>The left figure shows an image with improper white balance. The right figure shows the same image with better settings for white balance.</p><hr>]]></content>
      
      
      <categories>
          
          <category> Nao机器人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nao机器人 </tag>
            
            <tag> BHuman </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Nao机器人】ssh使用Nao</title>
      <link href="/2019/03/31/Nao%E6%9C%BA%E5%99%A8%E4%BA%BA-ssh%E4%BD%BF%E7%94%A8Nao/"/>
      <url>/2019/03/31/Nao%E6%9C%BA%E5%99%A8%E4%BA%BA-ssh%E4%BD%BF%E7%94%A8Nao/</url>
      
        <content type="html"><![CDATA[<p>有几个脚本可以通过SSH启动和停止NAOqi和bhuman。这些脚本在安装B-Human软件时被复制到NAO。</p><span id="more"></span><ul><li><strong>NAOqi</strong>，在前台执行naoqi。按Ctrl+C终止进程。请注意，如果SSH连接关闭，进程将自动终止。</li><li><strong>nao start|stop|restart</strong>，停止或重启NAOqi。如果libbhuman或libgamectrl被更新，copyfiles将自动重新启动NAOqi。</li><li><strong>bhuman</strong>，在前台执行bhuman可执行文件。按Ctrl+C终止进程。请注意,如果SSH连接关闭，这个过程将自动终止。</li><li><strong>bhumand start|stop|restart</strong>，启动、停止或重新启动bhuman可执行文件。Copyfiles总是在部署前停止bhuman。如果以选项-r启动copyfile，那么在复制所有文件之后，它将重新启动bhuman。</li><li><strong>status</strong>，显示的是naoqi和bhuman的状态。</li><li><strong>halt</strong>，关闭NAO。如果NAOqi正在跑步，这也可以通过按压胸部按钮超过3秒来完成。</li><li><strong>reboot</strong>，NAO重新启动。</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Nao机器人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nao机器人 </tag>
            
            <tag> BHuman </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Nao机器人】BHuman的组件和配置</title>
      <link href="/2019/03/30/Nao%E6%9C%BA%E5%99%A8%E4%BA%BA-BHuman%E7%9A%84%E7%BB%84%E4%BB%B6%E5%92%8C%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/03/30/Nao%E6%9C%BA%E5%99%A8%E4%BA%BA-BHuman%E7%9A%84%E7%BB%84%E4%BB%B6%E5%92%8C%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>B-Human 软件是跨平台的， 包含两个用于 NAOqi 的实际机器人共享库，一个用于机器人的附加可执行文件，相同的运行在模拟器SimRobot(没有 NAOqi)的软件，以及一些库和工具，因此，该软件分为以下组件。</p><span id="more"></span><h2 id="bush"><a href="#bush" class="headerlink" title="bush"></a>bush</h2><p>是一个可以同时部署和管理多个机器人的工具(参看官方手册的10.2节)。</p><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>是一个静态库，其中包含模拟器 NAO 特定的扩展，机器人代码框架的接口<br>以及在 NAO 上运行的代码的控制和高层调试。</p><h2 id="copyfile"><a href="#copyfile" class="headerlink" title="copyfile"></a>copyfile</h2><p>是一个将编译好的代码复制到机器人上的工具，在 Xcode 工程中，叫做 Deploy。更多参看官方手册2.5节内容。</p><h2 id="libbhuman"><a href="#libbhuman" class="headerlink" title="libbhuman"></a>libbhuman</h2><p>是 B-Human 可执行文件与 NAOqi 进行交互的共享库。</p><h2 id="libgamectrl"><a href="#libgamectrl" class="headerlink" title="libgamectrl"></a>libgamectrl</h2><p>是一个与 GameController 通信的共享 NAOqi 库。此外，它实现了官方的按钮界面，并按照规定设置 LED。更多资料见官方手册的第3.1节末尾。</p><h2 id="libqxt"><a href="#libqxt" class="headerlink" title="libqxt"></a>libqxt</h2><p>是一个静态库，为 Windows 和 Linux 上的 Qt 􏰁供了一个额外的部件。在 mac 系统上，相同的源文件只是 libraryController 的一部分。 </p><h2 id="Nao"><a href="#Nao" class="headerlink" title="Nao"></a>Nao</h2><p>是 NAO 的 B-Human 可执行文件，依赖于于 libbhuman 和 libgamectrl。</p><h2 id="qtpropertybrowser"><a href="#qtpropertybrowser" class="headerlink" title="qtpropertybrowser"></a>qtpropertybrowser</h2><p>是一个在 Qt 中实现<strong>属性浏览器</strong>的静态库。</p><h2 id="SimRobot"><a href="#SimRobot" class="headerlink" title="SimRobot"></a>SimRobot</h2><p>是用于运行和控制 B-Human 机器人代码的模拟器可执行文件。它动态链接到组件 SimRobotCore2，SimRobotEditor，SimulatedNao 和一些第三方库。SimRobot 可在编译，开发和调试配置中编译。所有这些配置都包含调试代码，但是 Release 会执行一些优化 并去除调试符号(Linux 和 macOS)。Develop 生成可调试的机器人代码，同时连接不可调试但更快的 Release 库。 </p><h2 id="SimRobotCore2"><a href="#SimRobotCore2" class="headerlink" title="SimRobotCore2"></a>SimRobotCore2</h2><p>是一个共享库，它包含SimRobot的仿真引擎。</p><h2 id="SimRobotEditor"><a href="#SimRobotEditor" class="headerlink" title="SimRobotEditor"></a>SimRobotEditor</h2><p>是一个共享库，其中包含模拟器的编辑器小部件。</p><h2 id="SimulatedNao"><a href="#SimulatedNao" class="headerlink" title="SimulatedNao"></a>SimulatedNao</h2><p>是一个共享库，其中包含模拟器的B-Human代码。它依赖于Controller、qtpropertybrowser和libqxt。它是静态连接的。</p><hr><p>所有组件都可以构建成三种配置:Release，Develop 和 Debug .Release 是为了“游戏代码”而设计的，因此可以实现最高的优化; Debug 􏰁供了全面的debugging 支持，并且没有优化。Debug 是一个特例。它生成可执行文件，并对组件 Nao 和 SimulatedNao 􏰁供一些调试支持(请参阅下面的表格详细信息)。对于所有其他组件，它与 Release 相同。</p><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1labyrsekj31ik0qg14q.jpg" alt="nao"></p><hr>]]></content>
      
      
      <categories>
          
          <category> Nao机器人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nao机器人 </tag>
            
            <tag> BHuman </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Nao机器人】刷机</title>
      <link href="/2019/03/30/Nao%E6%9C%BA%E5%99%A8%E4%BA%BA-%E5%88%B7%E6%9C%BA/"/>
      <url>/2019/03/30/Nao%E6%9C%BA%E5%99%A8%E4%BA%BA-%E5%88%B7%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>给 Nao (小宝贝) 部署 Naoqi 系统和 BHuman 系统。</p><span id="more"></span><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1l8kwg4i9j30hs0hs16e.jpg" alt="Nao"></p><p>机器人相关软件的下载地址：<a href="https://community.ald.softbankrobotics.com/en/resources/software/language/en-gb">https://community.ald.softbankrobotics.com/en/resources/software/language/en-gb</a></p><h2 id="BHuman-to-Naoqi"><a href="#BHuman-to-Naoqi" class="headerlink" title="BHuman to Naoqi"></a>BHuman to Naoqi</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul><li>U盘</li><li>flasher-2.1.0.19-linux64</li><li>opennao-atom-system-image-2.1.4.13_2015-08-27.opn</li></ul><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>在Ubuntu下，将U盘格式化。</li><li>解压flasher-2.1.0.19-linux64，<code>cd</code>到这个解压好的目录下，<code>l</code>查看当前目录下的文件（ps：如果文件名右上角有*，说明权限不够，<code>sudo</code>即可）。</li><li><code>cd bin/</code>然后执行<code>sudo ./flasher</code></li><li>输入nao的密码(一般是<code>0</code>)</li><li>把 u盘插入 Nao 的脑壳，按住胸前按钮直到次按钮不停的高频闪烁，释放按钮，Nao 进入自动刷机状态，等待十几分钟，听到 OGNAK 后说明刷机完成，拔出U盘。</li><li>在 linux 下关闭 Wi-Fi 连接，用网线连接机器人和电脑,编辑一个新网络,断开并重新连接,此时按机器人胸前按钮，会得到一个 ip。(如果是虚拟机要更改成桥连模式,关闭外网)，有时会听到“I cannot connect to the network”，多按几次（一般是3次）可以成功报出 IP，如果还是不行，先将NAO随意连接到其他任意设置的网络，之后断开，再连接回预设网络，方可成功。（由于刷好机后的NAO的有线IP都是以169.254开头，所以可以将Ethernet网的IPv4设置成：Address: 169.254.xxx.xxx; Netmask: 255.255.0.0; Gateway: 169.254.xxx.xxx）。</li></ol><h2 id="Naoqi-to-BHuman"><a href="#Naoqi-to-BHuman" class="headerlink" title="Naoqi to BHuman"></a>Naoqi to BHuman</h2><p>BHuman项目：<a href="https://github.com/bhuman/BHumanCodeRelease">https://github.com/bhuman/BHumanCodeRelease</a></p><p>注意：在部署bhuman之前，确保机器人的系统为naoqi，版本号为2.1.4.13，如若不是，请[给机器人部署naoqi系统](#BHuman to Naoqi)。</p><h3 id="准备-1"><a href="#准备-1" class="headerlink" title="准备"></a>准备</h3><ul><li>电脑、网线、安装 CodeLite</li><li>BHumanCodeRelease-master.zip</li><li>GameController-master.zip</li><li>naoqi-sdk-2.1.4.13-linux32.tar.gz</li></ul><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><h4 id="编译项目"><a href="#编译项目" class="headerlink" title="编译项目"></a>编译项目</h4><ol><li>新建一个文件夹<code>robotcup</code>，将上面三个压缩包放到这个新建的目录下。</li><li>BHumanCodeRelease-master.zip解压，提取出来。把naoqi-sdk-2.1.4.13-linux32.tar.gz复制到robotcup/BHumanCodeRelease-master/Install路径下。</li><li>进入<code>/robotcup/BHumanCodeRelease-master/Install</code>执行<code>./installAlcommon naoqi-sdk-2.1.4.13-linux32.tar.gz</code></li><li>进入<code>/robotcup/BHumanCodeRelease-master/Make/LinuxCodeLite</code>执行<code>./generate</code></li><li>然后执行<code>codelite</code>，选中B-Human,右键选中Build-&gt;ReBuild Workspace</li></ol><h4 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h4><p>进入<code>/robotcup/BHumanCodeRelease-master/Install/Network/Profiles</code>编辑<code>default</code>文件，配置Wi-Fi信息。</p><h4 id="拷贝编译好的文件到Nao"><a href="#拷贝编译好的文件到Nao" class="headerlink" title="拷贝编译好的文件到Nao"></a>拷贝编译好的文件到Nao</h4><ol><li><p>进入<code>/robotcup/BHumanCodeRelease-master/Install</code>执行<code>./createRobot -d -t 17 -r 2 roboname</code>（参数：-d为清空之前的，-t后跟team number，-r后跟机器人序号，roboname是设定机器人名字）</p></li><li><p>执行<code>./addRobotIds -ip 192.168.66.4 roboname</code>（192.168.66.4是让机器人自己报的现在的ip，roboname是设定的名字）</p></li><li><p>执行<code>./installRobot 192.168.66.4</code>（192.168.66.4同上）</p></li><li><p>执行完上述操作后，就成功将机器人的IP设置为：192.168.teamNumber.robotNumber（上述步骤会分别在代码的Config/Robots/下创建相应的内容，./createRobot -d -t 20 -r 10 dashu 会在Config/Robots/下穿件名为dashu的文件夹；./addRobotIds<br>-ip 169.254.210.108 dashu会在Config/Robots/robots.cfg中增加机器人的配置信息）</p></li><li><p>然后将电脑端连接的网络配置更改为192.168.xxx.xxx就可以了，或者在做完前面操作后，将机器人和电脑用网线连起来。</p></li><li><p>然后执行：<code>./copyfiles Release 192.168.17.2</code>。</p></li></ol><p>欧阔~</p><hr>]]></content>
      
      
      <categories>
          
          <category> Nao机器人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nao机器人 </tag>
            
            <tag> BHuman </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Nao机器人】BHuman中的Config</title>
      <link href="/2019/03/30/Nao%E6%9C%BA%E5%99%A8%E4%BA%BA-BHuman%E4%B8%AD%E7%9A%84Config/"/>
      <url>/2019/03/30/Nao%E6%9C%BA%E5%99%A8%E4%BA%BA-BHuman%E4%B8%AD%E7%9A%84Config/</url>
      
        <content type="html"><![CDATA[<p>本文主要记录了 BHuman 代码中的 Config 目录的一些东西。</p><p>2016 的代码和 2017/2018 的代码在 Config 上面稍微有些不同。由于代码的重新编译在某些情况下需要花费大量的时间，并且每个机器人需要不同的配置，软件使用了大量的配置文件，这些文件可以在不引起重新编译的情况下进行修改。</p><p>软件使用的所有文件都位于 Config 目录下。还有一些机器人操作系统的配置文件，它们位于Install目录中。</p><span id="more"></span><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1l9dogsa8j30lg0kqaca.jpg"></p><p>下面主要是 2017 代码中的一些参数解释。</p><h2 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Keys&#123;一些秘钥&#125;</span><br><span class="line">├── KickEngine&#123;踢球引擎(踢球动作等)&#125;</span><br><span class="line">├── Locations&#123;场地信息&#125;</span><br><span class="line">├── Robots&#123;机器人一些关节、速度等参数&#125;</span><br><span class="line">├── Scenarios&#123;情节、脚本&#125;</span><br><span class="line">├── Scenes&#123;现场&#125;</span><br><span class="line">├── Sounds&#123;声音(机器人说的一些话在里面)&#125;</span><br><span class="line">├── WalkKicks&#123;带球？&#125;</span><br><span class="line">├── Whistles&#123;口哨&#125;</span><br><span class="line">├── ballPatterns.dat &#123;二进制文件，球模式&#125;</span><br><span class="line">├── ballPerceptor.dat&#123;二进制文件，球感知器&#125;</span><br><span class="line">├── ballTexture.dat&#123;二进制文件，球文理&#125;</span><br><span class="line">├── mof</span><br><span class="line">├── penaltyMarkPerceptor.dat &#123;二进制文件，点球罚球点&#125;</span><br><span class="line">├── settings.cfg&#123;配置球队，端口，颜色等&#125;</span><br><span class="line">├── teamList.cfg&#123;比赛中的各个球队&#125;</span><br><span class="line">└── teams.cfg&#123;球队信息&#125;</span><br></pre></td></tr></table></figure><h3 id="Scenarios"><a href="#Scenarios" class="headerlink" title="Scenarios"></a>Scenarios</h3><p>可以为不同的独立任务配置软件。只需在Config/scenario中创建一个具有所需名称的新文件夹并将配置文件放入其中，就可以设置它们。只有在Config/settings.cfg文件中激活该场景时，才会考虑这些配置文件。</p><h3 id="Locations"><a href="#Locations" class="headerlink" title="Locations"></a>Locations</h3><p>可用于将软件配置为在不同地点使用，例如在家中的实验室中，以及在不同的比赛中。例如，字段的尺寸和颜色校准可以依赖于机器人所使用的位置。</p><h3 id="Robots"><a href="#Robots" class="headerlink" title="Robots"></a>Robots</h3><p>除了全局配置文件外，还有一些文件依赖于机器人的头部、身体或两者。为了区分这些文件的位置，使用了每个机器人头部和身体的名称。它们在文件Config/Robots/Robots中定义。cfg将机器人头部和身体的序列号映射到它们的实际名称。在模拟器中，两个名称都是“Nao”。</p><h3 id="配置文件的搜索序列"><a href="#配置文件的搜索序列" class="headerlink" title="配置文件的搜索序列"></a>配置文件的搜索序列</h3><ol><li><p><code>Config/Robots/&lt;head name&gt;/Head/&lt;filename&gt;</code></p><ul><li><p>用于仅依赖于机器人头部的文件</p><p>例如：Robots/Amy/Head/cameraIntrinsics.cfg</p></li></ul></li><li><p><code>Config/Robots/&lt;body name&gt;/Body/&lt;filename&gt;</code></p><ul><li><p>用于仅依赖于机器人身体的文件</p><p>例如：Robots/Alex/Body/walkingEngine.cfg</p></li></ul></li><li><p><code>Config/Robots/&lt;head name&gt;/&lt;body name&gt;/&lt;filename&gt;</code></p><ul><li><p>用于同时依赖于机器人头部和身体的文件。</p><p>例如：Robots/Amy/Alex/cameraCalibration.cfg</p></li></ul></li><li><p><code>Config/Locations/&lt;current location&gt;/&lt;filename&gt;</code></p></li><li><p><code>Config/Scenarios/&lt;current scenario&gt;/&lt;filename&gt;</code></p></li><li><p><code>Config/Robots/Default/&lt;filename&gt;</code></p></li><li><p><code>Config/Locations/Default/&lt;filename&gt;</code></p></li><li><p><code>Config/Scenarios/Default/&lt;filename&gt;</code></p></li><li><p><code>Config/&lt;filename&gt;</code></p></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> Nao机器人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nao机器人 </tag>
            
            <tag> BHuman </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nodejs-基础结构和数据处理</title>
      <link href="/2019/03/29/JavaScript-Nodejs-%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84%E5%92%8C%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
      <url>/2019/03/29/JavaScript-Nodejs-%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84%E5%92%8C%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="同步、异步"><a href="#同步、异步" class="headerlink" title="同步、异步"></a>同步、异步</h2><p>在 node.js 中绝大多数的异步操作。</p><h2 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h2><p>规定了浏览器和服务器之间如何进行交互。</p><h3 id="HTTP-发展过程"><a href="#HTTP-发展过程" class="headerlink" title="HTTP 发展过程"></a>HTTP 发展过程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP 1.0 RFC-1945</span><br><span class="line">HTTP 1.1 RFC-2616   持久连接(连接完了一定时间内不会马上断开)</span><br><span class="line">HTTPS    RFC-2818   安全协议</span><br><span class="line">HTTP 2.0 RFC-7540   加密、头部压缩、服务器推送、管线操作、多路复用</span><br></pre></td></tr></table></figure><h3 id="HTTP-报文结构"><a href="#HTTP-报文结构" class="headerlink" title="HTTP 报文结构"></a>HTTP 报文结构</h3><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1jnpqlt1uj31a80l4n12.jpg"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">header &lt;= 32K</span><br><span class="line">body&lt;= 2G</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1jnrbefnij31bw0sy78l.jpg"></p><h3 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1xx 信息</span><br><span class="line">2xx 成功</span><br><span class="line">3xx 重定向(你需要的资源不在我这，在另外一个地址，你去找他要)</span><br><span class="line">4xx 请求错误(<span class="number">404</span> not found，是请求错误)</span><br><span class="line">5xx 服务器错误(是服务器的错误，不是你的错)</span><br></pre></td></tr></table></figure><h3 id="HTTP-请求方式"><a href="#HTTP-请求方式" class="headerlink" title="HTTP 请求方式"></a>HTTP 请求方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET   获取</span><br><span class="line">  数据放在url里面传输的</span><br><span class="line">  1.容量小&lt;=32K</span><br><span class="line"></span><br><span class="line">POST  发送数据</span><br><span class="line">  1.容量大</span><br></pre></td></tr></table></figure><h2 id="http-模块"><a href="#http-模块" class="headerlink" title="http 模块"></a>http 模块</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http=<span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> server=http.<span class="title function_">createServer</span>(<span class="keyword">function</span> (<span class="params">req, res</span>)&#123;<span class="comment">// request(请求), response(相应)</span></span><br><span class="line">  res.<span class="title function_">write</span>(<span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line">  res.<span class="title function_">end</span>();<span class="comment">// 发完东西结束请求，告诉浏览器不用等了，我发完了。</span></span><br><span class="line">&#125;);</span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure><h2 id="fs-模块"><a href="#fs-模块" class="headerlink" title="fs 模块"></a>fs 模块</h2><p>file system。</p><p><code>fs.writeFile(path, data, callback);</code>和<code>fs.readFile(path, callback);</code>他俩就是异步操作，当然他俩也有同步的版本：<code>fs.writeFileSync</code>和<code>fs.readFileSync</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//fs.writeFile(path, data, callback);</span></span><br><span class="line"><span class="comment">//fs.readFile(path, callback);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入文件</span></span><br><span class="line">fs.<span class="title function_">writeFile</span>(<span class="string">&#x27;./a.txt&#x27;</span>, <span class="string">&#x27;asdfasdfad&#x27;</span>, <span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(err)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;失败&#x27;</span>, err);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;成功&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 读取文件</span></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./a.txt&#x27;</span>, <span class="function">(<span class="params">err, data</span>)=&gt;</span>&#123;<span class="comment">// 返回的是一个 Buffer 数据(原始的二进制数据)</span></span><br><span class="line">  <span class="keyword">if</span>(err)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;错误&#x27;</span>, err);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;成功&#x27;</span>, data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http=<span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> server=http.<span class="title function_">createServer</span>(<span class="keyword">function</span> (<span class="params">req, res</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">url</span>);</span><br><span class="line">  <span class="comment">//req.url =&gt;&#x27;/1.html&#x27;</span></span><br><span class="line">  <span class="comment">//=&gt;&#x27;www/1.html&#x27;</span></span><br><span class="line"></span><br><span class="line">  fs.<span class="title function_">readFile</span>(<span class="string">`www<span class="subst">$&#123;req.url&#125;</span>`</span>, <span class="function">(<span class="params">err, buffer</span>)=&gt;</span>&#123;<span class="comment">// 读取相应的文件</span></span><br><span class="line">    <span class="keyword">if</span>(err)&#123;<span class="comment">// 如果请求错误</span></span><br><span class="line">      res.<span class="title function_">writeHeader</span>(<span class="number">404</span>);<span class="comment">// 状态码</span></span><br><span class="line">      res.<span class="title function_">write</span>(<span class="string">&#x27;Not Found&#x27;</span>);<span class="comment">// 显示</span></span><br><span class="line">      res.<span class="title function_">end</span>();<span class="comment">// 结束</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">// res.writeHeader(200); // 200 代表成功，默认是这个</span></span><br><span class="line">      res.<span class="title function_">write</span>(buffer);</span><br><span class="line">      res.<span class="title function_">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure><h2 id="GET-请求"><a href="#GET-请求" class="headerlink" title="GET 请求"></a>GET 请求</h2><p>一次给到数据库。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">dir</span>=<span class="string">&quot;ltr&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://localhost:8080/aaa&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">      用户：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="querystring-模块"><a href="#querystring-模块" class="headerlink" title="querystring 模块"></a>querystring 模块</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http=<span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> querystring=<span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> server=http.<span class="title function_">createServer</span>(<span class="keyword">function</span> (<span class="params">req, res</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> [url, query]=req.<span class="property">url</span>.<span class="title function_">split</span>(<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> get=querystring.<span class="title function_">parse</span>(query);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(url, get);</span><br><span class="line">&#125;);</span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8080</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="url-模块"><a href="#url-模块" class="headerlink" title="url 模块"></a>url 模块</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http=<span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> url=<span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> server=http.<span class="title function_">createServer</span>(<span class="keyword">function</span> (<span class="params">req, res</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123;pathname, query&#125;=url.<span class="title function_">parse</span>(req.<span class="property">url</span>, <span class="literal">true</span>);<span class="comment">// true 就是告诉他连 query 一块处理了吧，处理完变成一个 JSON</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(pathname, query);</span><br><span class="line">&#125;);</span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8080</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="POST-请求"><a href="#POST-请求" class="headerlink" title="POST 请求"></a>POST 请求</h2><p>POST 因为比较大，可能会分几次发给服务器。接收的时候也要分段来接收。</p><p><code>req.on</code>事件、<code>req.end</code>事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http=<span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> querystring=<span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> server=http.<span class="title function_">createServer</span>(<span class="keyword">function</span> (<span class="params">req, res</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> arr=[];</span><br><span class="line">  req.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">buffer</span>=&gt;</span>&#123;</span><br><span class="line">    arr.<span class="title function_">push</span>(buffer);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  req.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> buffer=<span class="title class_">Buffer</span>.<span class="title function_">concat</span>(arr);<span class="comment">// 将 arr 中的数据拼在一起</span></span><br><span class="line">    <span class="keyword">let</span> post=querystring.<span class="title function_">parse</span>(buffer.<span class="title function_">toString</span>());<span class="comment">// 转为字符串</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(post);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8080</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="同时接收-GET-和-POST-请求"><a href="#同时接收-GET-和-POST-请求" class="headerlink" title="同时接收 GET 和 POST 请求"></a>同时接收 GET 和 POST 请求</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http=<span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> url=<span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> querystring=<span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> path=<span class="string">&#x27;&#x27;</span>, get=&#123;&#125;, post=&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(req.<span class="property">method</span>==<span class="string">&#x27;GET&#x27;</span>)&#123;<span class="comment">// 如果是 GET 方式</span></span><br><span class="line">    <span class="keyword">let</span> &#123;pathname, query&#125;=url.<span class="title function_">parse</span>(req.<span class="property">url</span>, <span class="literal">true</span>);</span><br><span class="line">    path=pathname;</span><br><span class="line">    get=query;</span><br><span class="line">    <span class="title function_">complete</span>();</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(req.<span class="property">method</span>==<span class="string">&#x27;POST&#x27;</span>)&#123;<span class="comment">// 如果是 POST 方式</span></span><br><span class="line">    path=req.<span class="property">url</span>;</span><br><span class="line">    <span class="keyword">let</span> arr=[];</span><br><span class="line">    </span><br><span class="line">    req.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">buffer</span>=&gt;</span>&#123;</span><br><span class="line">      arr.<span class="title function_">push</span>(buffer);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    req.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">let</span> buffer=<span class="title class_">Buffer</span>.<span class="title function_">concat</span>(arr);</span><br><span class="line">      post=querystring.<span class="title function_">parse</span>(buffer.<span class="title function_">toString</span>());</span><br><span class="line">      <span class="title function_">complete</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">complete</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(path, get, post);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).<span class="title function_">listen</span>(<span class="number">8080</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口-API：用户注册、登录</p><p>服务器：</p><ol><li>请求文件 -&gt; 结果</li><li>请求接口 -&gt; 操作</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">注册接口：</span><br><span class="line">/reg?username=xxx&amp;password=<span class="function"><span class="params">xxx</span></span></span><br><span class="line"><span class="function">=&gt;</span>&#123;<span class="attr">error</span>: <span class="number">1</span>, <span class="attr">msg</span>: <span class="string">&#x27;为什么&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">登录接口：</span><br><span class="line">/login?username=xxx&amp;password=<span class="function"><span class="params">xxx</span></span></span><br><span class="line"><span class="function">=&gt;</span>&#123;<span class="attr">error</span>: <span class="number">1</span>, <span class="attr">msg</span>: <span class="string">&#x27;xx&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="用户注册登录案例"><a href="#用户注册登录案例" class="headerlink" title="用户注册登录案例"></a>用户注册登录案例</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">dir</span>=<span class="string">&quot;ltr&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;jquery.js&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    $(<span class="keyword">function</span> (<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      $(<span class="string">&#x27;#btn1&#x27;</span>).<span class="title function_">click</span>(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">        $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">url</span>: <span class="string">&#x27;/reg&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">username</span>: $(<span class="string">&#x27;#user&#x27;</span>).<span class="title function_">val</span>(),</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">password</span>: $(<span class="string">&#x27;#pass&#x27;</span>).<span class="title function_">val</span>()</span></span><br><span class="line"><span class="language-javascript">          &#125;,</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">dataType</span>: <span class="string">&#x27;json&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">json</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">if</span>(json.<span class="property">error</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(json.<span class="property">msg</span>);</span></span><br><span class="line"><span class="language-javascript">          &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&#x27;注册成功&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;, <span class="function"><span class="params">err</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">alert</span>(<span class="string">&#x27;注册失败，请刷新重试&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">      &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      $(<span class="string">&#x27;#btn2&#x27;</span>).<span class="title function_">click</span>(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">        $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">url</span>: <span class="string">&#x27;/login&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">username</span>: $(<span class="string">&#x27;#user&#x27;</span>).<span class="title function_">val</span>(),</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">password</span>: $(<span class="string">&#x27;#pass&#x27;</span>).<span class="title function_">val</span>()</span></span><br><span class="line"><span class="language-javascript">          &#125;,</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">dataType</span>: <span class="string">&#x27;json&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">json</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">if</span>(json.<span class="property">error</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(json.<span class="property">msg</span>);</span></span><br><span class="line"><span class="language-javascript">          &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&#x27;登录成功&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;, <span class="function"><span class="params">err</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">alert</span>(<span class="string">&#x27;登录失败，请刷新重试&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">      &#125;);</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    用户：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;pass&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;注册&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn2&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http=<span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> url=<span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> querystring=<span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> users=&#123;&#125;;</span><br><span class="line"></span><br><span class="line">http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> path=<span class="string">&#x27;&#x27;</span>, get=&#123;&#125;, post=&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(req.<span class="property">method</span>==<span class="string">&#x27;GET&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;pathname, query&#125;=url.<span class="title function_">parse</span>(req.<span class="property">url</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    path=pathname;</span><br><span class="line">    get=query;</span><br><span class="line">    <span class="title function_">complete</span>();</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(req.<span class="property">method</span>==<span class="string">&#x27;POST&#x27;</span>)&#123;</span><br><span class="line">    path=req.<span class="property">url</span>;</span><br><span class="line">    <span class="keyword">let</span> arr=[];</span><br><span class="line">    req.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">buffer</span>=&gt;</span>&#123;</span><br><span class="line">      arr.<span class="title function_">push</span>(buffer);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    req.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">let</span> buffer=<span class="title class_">Buffer</span>.<span class="title function_">concat</span>(arr);</span><br><span class="line">      post=querystring.<span class="title function_">parse</span>(buffer.<span class="title function_">toString</span>());</span><br><span class="line">      <span class="title function_">complete</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">complete</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(path==<span class="string">&#x27;/reg&#x27;</span>)&#123;</span><br><span class="line">      <span class="keyword">let</span> &#123;username, password&#125;=get;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(users[username])&#123;</span><br><span class="line">        res.<span class="title function_">write</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;<span class="attr">error</span>: <span class="number">1</span>, <span class="attr">msg</span>: <span class="string">&#x27;此用户名已存在&#x27;</span>&#125;));</span><br><span class="line">        res.<span class="title function_">end</span>();</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        users[username]=password;</span><br><span class="line"></span><br><span class="line">        res.<span class="title function_">write</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;<span class="attr">error</span>: <span class="number">0</span>, <span class="attr">msg</span>: <span class="string">&#x27;&#x27;</span>&#125;));</span><br><span class="line">        res.<span class="title function_">end</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(path==<span class="string">&#x27;/login&#x27;</span>)&#123;</span><br><span class="line">      <span class="keyword">let</span> &#123;username, password&#125;=get;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(!users[username])&#123;</span><br><span class="line">        res.<span class="title function_">write</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;<span class="attr">error</span>: <span class="number">1</span>, <span class="attr">msg</span>: <span class="string">&#x27;找不到此用户&#x27;</span>&#125;));</span><br><span class="line">        res.<span class="title function_">end</span>();</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(users[username]!=password)&#123;</span><br><span class="line">        res.<span class="title function_">write</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;<span class="attr">error</span>: <span class="number">1</span>, <span class="attr">msg</span>: <span class="string">&#x27;密码不对&#x27;</span>&#125;));</span><br><span class="line">        res.<span class="title function_">end</span>();</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        res.<span class="title function_">write</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;<span class="attr">error</span>: <span class="number">0</span>, <span class="attr">msg</span>: <span class="string">&#x27;&#x27;</span>&#125;));</span><br><span class="line">        res.<span class="title function_">end</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      fs.<span class="title function_">readFile</span>(<span class="string">`www<span class="subst">$&#123;path&#125;</span>`</span>, <span class="function">(<span class="params">err, buffer</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">          res.<span class="title function_">writeHeader</span>(<span class="number">404</span>);</span><br><span class="line">          res.<span class="title function_">write</span>(<span class="string">&#x27;Not Found&#x27;</span>);</span><br><span class="line">          res.<span class="title function_">end</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          res.<span class="title function_">write</span>(buffer);</span><br><span class="line">          res.<span class="title function_">end</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).<span class="title function_">listen</span>(<span class="number">8080</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nodejs-入门</title>
      <link href="/2019/03/27/JavaScript-Node-js/"/>
      <url>/2019/03/27/JavaScript-Node-js/</url>
      
        <content type="html"><![CDATA[<p>node 一般是作为 前端和服务器中间的中间层，比如做一些数据处理，数据缓存等，减少服务器压力，也可以处理一些不安全的东西。</p><p>用途：</p><ol><li>中间层（安全性、性能、降低主服务器复杂度）</li><li>小型服务</li><li>工具</li></ol><p>优势：</p><ol><li>性能高</li><li>利于和前端代码整合</li></ol><span id="more"></span><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装node.js <a href="https://nodejs.org/">https://nodejs.org/</a></p><p>npm：Node Package Manager，一般 npm 比较慢，所以要换源：(注意有些 <a href="#%E5%8C%85">包</a> 只能用 npm 下载安装，大部分可以用 cnpm 来安装)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install cnpm -g --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">怎么卸载低版本</span><br><span class="line">1.卸载node本身、删除nodejs目录</span><br><span class="line">2.手动删除C:\Program Files\nodejs\node_modules\</span><br><span class="line">3.手动删除C:\users\你\node_modules\</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="运行-nodejs-程序"><a href="#运行-nodejs-程序" class="headerlink" title="运行 nodejs 程序"></a>运行 nodejs 程序</h3><p>使用 <code>node name.js</code></p><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><h4 id="安装-删除包"><a href="#安装-删除包" class="headerlink" title="安装/删除包"></a>安装/删除包</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">安装</span><br><span class="line">npm install xxx</span><br><span class="line">npm i xxx</span><br><span class="line"></span><br><span class="line">删除</span><br><span class="line">npm uninstall xxx</span><br><span class="line">npm un xxx</span><br><span class="line"></span><br><span class="line">cnpm i xxx</span><br><span class="line">cnpm un xx</span><br></pre></td></tr></table></figure><h4 id="引入包"><a href="#引入包" class="headerlink" title="引入包"></a>引入包</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xx=<span class="built_in">require</span>(<span class="string">&#x27;xxx&#x27;</span>);<span class="comment">// xxx 是包名</span></span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript-JSON</title>
      <link href="/2019/03/26/JavaScript-JSON/"/>
      <url>/2019/03/26/JavaScript-JSON/</url>
      
        <content type="html"><![CDATA[<p>JSON：JavaScript Object Notation 的缩写，它是一种数据交换格式。<a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434499490767fe5a0e31e17e44b69dcd1196f7ec6fc6000">详细资料</a></p><p>JSON -&gt; 字符串：序列化<br>字符串 -&gt; JSON：反序列化</p><span id="more"></span><h2 id="序列化-stringify"><a href="#序列化-stringify" class="headerlink" title="序列化 stringify"></a>序列化 <code>stringify</code></h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">dir</span>=<span class="string">&quot;ltr&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> json=&#123;<span class="attr">a</span>: <span class="number">12</span>, <span class="attr">b</span>: <span class="number">5</span>, <span class="attr">c</span>: <span class="string">&#x27;aaa&#x27;</span>&#125;;<span class="comment">// 注意：这里是不标准的 JSON 写法，但是在 JS 中可以这么写，序列化后，JS 会把它转为标准的 JSON 格式。&#123;&quot;a&quot;:12,&quot;b&quot;:5,&quot;c&quot;:&quot;aaa&quot;&#125;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(json));</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="反序列化-parse"><a href="#反序列化-parse" class="headerlink" title="反序列化 parse"></a>反序列化 <code>parse</code></h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">dir</span>=<span class="string">&quot;ltr&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> str=<span class="string">&#x27;&#123;&quot;a&quot;:12,&quot;b&quot;:5,&quot;c&quot;:&quot;aaa&quot;&#125;&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> json=<span class="title class_">JSON</span>.<span class="title function_">parse</span>(str);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(json);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript-正则表达式</title>
      <link href="/2019/03/25/JavaScript-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2019/03/25/JavaScript-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>在JS中使用正则。</p><span id="more"></span><p>正则表达式用来干啥？</p><p>用来匹配字符串，校验数据来保证安全性，采集一些数据。</p><p>在 JS 中用正则的两种风格：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JS风格</span></span><br><span class="line"><span class="keyword">let</span> re=<span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;\\d+&#x27;</span>, <span class="string">&#x27;g&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//perl风格</span></span><br><span class="line"><span class="keyword">let</span> re=<span class="regexp">/\d+/g</span>;</span><br></pre></td></tr></table></figure><h2 id="search"><a href="#search" class="headerlink" title="search"></a>search</h2><p><code>search</code> 是字符串的方法，用来在字符串中找符合正则表达式的字符，返回一个下标。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str=<span class="string">&#x27;Aweaqesdfaerq&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> re=<span class="regexp">/a/i</span>;<span class="comment">// i 忽略大小写</span></span><br><span class="line"><span class="title function_">alert</span>(str.<span class="title function_">search</span>(re));</span><br></pre></td></tr></table></figure><h2 id="match"><a href="#match" class="headerlink" title="match"></a>match</h2><p><code>match</code> 也是字符串的方法，用来提取出来字符串中匹配正则表达式的字符，返回的是一个数组，里面是符合要求的字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str=<span class="string">&#x27;f34rrfsdf 45tsdgsrdg 5terg56456fdghdr675 dsf3434535645645645674567&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> re=<span class="regexp">/\d+/g</span>;<span class="comment">// g 全局匹配。 \d 是转义字符，表示所有的数字， + 是尽可能多的数字。</span></span><br><span class="line"><span class="title function_">alert</span>(str.<span class="title function_">match</span>(re));</span><br></pre></td></tr></table></figure><h2 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h2><p><code>replace</code> 也是字符串的方法，替换掉匹配正则表达式的东西。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str=<span class="string">&#x27;asdfde we fsadfas weAr efAf&#x27;</span>;</span><br><span class="line"><span class="title function_">alert</span>(str.<span class="title function_">replace</span>(<span class="regexp">/a/gi</span>, <span class="string">&#x27;*&#x27;</span>));<span class="comment">// 用 * 替换掉 str 中所有的 a 忽略大小写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 去掉所有的空格</span></span><br><span class="line"><span class="keyword">let</span> str=<span class="string">&#x27; dffsdfsd   dfasdfsadf asdf asdf asdf  &#x27;</span>;</span><br><span class="line"><span class="title function_">alert</span>(str.<span class="title function_">replace</span>(<span class="regexp">/\s+/g</span>, <span class="string">&#x27;&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的代码，将 ## 分割的东西用 p 标签包裹起来</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span>=<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> oDiv=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div1&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> str=<span class="string">&#x27;sdfsf##dfasderferfef##dfdfsgdsgf##dgdfbfdghg&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  oDiv.<span class="property">innerHTML</span>=str.<span class="title function_">split</span>(<span class="regexp">/##/g</span>).<span class="title function_">map</span>(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&lt;p&gt;<span class="subst">$&#123;item&#125;</span>&lt;/p&gt;`</span>;</span><br><span class="line">  &#125;).<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="test"><a href="#test" class="headerlink" title="test"></a>test</h2><p><code>test</code> 是正则的方法，举个🌰：注意test有个毛病，就是有一部分正则符合就让过，这种情况下就要使用[修饰符<code>^ $</code>](#修饰符 <code>^ $</code>)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 校验 QQ 号，1开头 5-12 个数字</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">dir</span>=<span class="string">&quot;ltr&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">onload</span>=<span class="keyword">function</span> (<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> oTxt=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;txt1&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> oBtn=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn1&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      oBtn.<span class="property">onclick</span>=<span class="keyword">function</span> (<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> re=<span class="regexp">/^[1-9]\d&#123;4,11&#125;$/</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(re.<span class="title function_">test</span>(oTxt.<span class="property">value</span>))&#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">alert</span>(<span class="string">&#x27;通过&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">alert</span>(<span class="string">&#x27;不对&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;;</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;txt1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;校验&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符 []"></a>元字符 <code>[]</code></h2><ol><li><p>任何<strong>一个</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/a[abc]q/   匹配的是：aaq,abq,acq</span><br><span class="line">但是不能匹配 abbq</span><br></pre></td></tr></table></figure></li><li><p>范围</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/[a-z]/i</span><br><span class="line">/[<span class="number">0</span>-<span class="number">9</span>]/</span><br><span class="line"><span class="regexp">/[a-z0-9]/</span></span><br><span class="line">注意：如果要匹配 <span class="number">3</span>-<span class="number">55</span> 不能这样写 [<span class="number">3</span>-<span class="number">59</span>]</span><br></pre></td></tr></table></figure></li><li><p>排除</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[^a-z0-<span class="number">9</span>]匹配除了 a-z <span class="number">0</span>-<span class="number">9</span> 以外的东西</span><br></pre></td></tr></table></figure></li></ol><h2 id="转义"><a href="#转义" class="headerlink" title="转义 \"></a>转义 <code>\</code></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\d    [<span class="number">0</span>-<span class="number">9</span>]</span><br><span class="line">\w    [a-z0-9_]</span><br><span class="line">\s    空白</span><br><span class="line">.     任意字符</span><br><span class="line"></span><br><span class="line">\D    [^<span class="number">0</span>-<span class="number">9</span>]</span><br><span class="line">\W    [^a-z0-9_]</span><br><span class="line">\S    非空白</span><br></pre></td></tr></table></figure><h2 id="量词-n"><a href="#量词-n" class="headerlink" title="量词 {n}"></a>量词 <code>&#123;n&#125;</code></h2><p>在正则中不加量词，就是一个。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;n&#125;       /a&#123;<span class="number">6</span>&#125;/  匹配<span class="number">6</span>个a    /\d&#123;<span class="number">11</span>&#125;/ 匹配<span class="number">11</span>个数字</span><br><span class="line">&#123;n,m&#125;     /\d&#123;<span class="number">5</span>,<span class="number">12</span>&#125;/匹配<span class="number">5</span>-<span class="number">12</span>个数字</span><br><span class="line">&#123;n,&#125;      /\w&#123;<span class="number">6</span>,&#125;/匹配<span class="number">6</span>个[a-z0-9_]中的字符</span><br><span class="line">+   &#123;<span class="number">1</span>,&#125;最少一个，多了不限</span><br><span class="line">?   &#123;<span class="number">0</span>,<span class="number">1</span>&#125;要么有，要么没有</span><br><span class="line"></span><br><span class="line">/\.<span class="property">jsx</span>?/    可以匹配 .<span class="property">js</span>  .<span class="property">jsx</span></span><br><span class="line"></span><br><span class="line">a 任何字符<span class="number">5</span>-<span class="number">18</span>个 z</span><br><span class="line">/a.&#123;<span class="number">5</span>,<span class="number">18</span>&#125;z/</span><br></pre></td></tr></table></figure><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符 ^"></a>修饰符 <code>^</code></h2><p>是用来说明条件的。<a href="#test">栗子：校验QQ号</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">^ 行首⚠️注意： ^ 放在 [] 里面是排除，没在里面就是行首</span><br><span class="line">$ 行尾</span><br><span class="line"></span><br><span class="line">/\.<span class="property">js</span>/      匹配：<span class="number">1.</span>js.<span class="property">png</span>    <span class="number">1.</span>html.<span class="property">js</span>.<span class="property">png</span></span><br><span class="line">/\.<span class="property">js$</span>/i    匹配：<span class="number">1.</span>js    <span class="number">1231.</span>txt.<span class="property">js</span></span><br><span class="line"></span><br><span class="line">/^https?:\/\<span class="comment">//匹配：http 或者 https</span></span><br></pre></td></tr></table></figure><h2 id="或"><a href="#或" class="headerlink" title="或 |"></a>或 <code>|</code></h2><p>⚠️ 注意，或运算符的优先级特别低，要使用<code>()</code>来提升优先级。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/\.<span class="property">jpg</span>|gif|png$/</span><br><span class="line">如果这么写的话，匹配的是：有 .<span class="property">jpg</span> 或 gif 或 png结尾的字符串</span><br><span class="line">实际上机器认为是这样的 /(\.<span class="property">jpg</span>)|(gif)|(png$)/</span><br><span class="line">              </span><br><span class="line">所以有：/\.(jpg|gif|png)$/i</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript-ES6笔记</title>
      <link href="/2019/03/23/JavaScript-ES6%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/03/23/JavaScript-ES6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>ES6 的笔记。</p><span id="more"></span><p>ECMAScript。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ES6</span>(<span class="variable constant_">ECMA</span> <span class="number">2015</span>)</span><br><span class="line"></span><br><span class="line"><span class="title class_">ES7</span>(<span class="variable constant_">ECMA</span> <span class="number">2016</span>)</span><br><span class="line">  **<span class="comment">// 求幂 比如 2**3 == 2 ^ 3</span></span><br><span class="line">  <span class="title class_">Array</span>.<span class="title function_">includes</span>()</span><br><span class="line"></span><br><span class="line"><span class="title class_">ES8</span>(<span class="variable constant_">ECMA</span> <span class="number">2017</span>)</span><br><span class="line">  <span class="keyword">await</span>/<span class="keyword">async</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">ES9</span>(<span class="variable constant_">ECMA</span> <span class="number">2018</span>)</span><br><span class="line">  rest/spread</span><br><span class="line">  异步迭代</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">finally</span>()</span><br><span class="line">  正则</span><br></pre></td></tr></table></figure><h2 id="关于变量"><a href="#关于变量" class="headerlink" title="关于变量"></a>关于变量</h2><p><strong>var：</strong></p><ol><li>可以重复声明</li><li>没有块级作用域</li><li>不能限制</li></ol><p><strong>let：</strong> 用来声明变量。</p><p><strong>const：</strong> 声明常量。</p><ol><li>进制重复声明</li><li>控制修改</li><li>支持块级作用域</li></ol><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><ol><li>左右两边对应</li><li>右边得是个东西(JSON)</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a,b,c&#125;=&#123;<span class="attr">a</span>: <span class="number">12</span>, <span class="attr">b</span>: <span class="number">55</span>, <span class="attr">c</span>: <span class="number">99</span>&#125;;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><ol><li>函数只有一个参数的时候，可以省略参数的括号</li><li>函数体内只有一个 return 语句的时候，可以省略大括号</li></ol><p>正常的函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f = <span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>箭头函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">f</span> = x =&gt; x * x</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">sum</span>=(<span class="params">a,b</span>)=&gt;a+b;</span><br><span class="line"><span class="title function_">alert</span>(<span class="title function_">sum</span>(<span class="number">12</span>, <span class="number">88</span>));</span><br></pre></td></tr></table></figure><p>几个 🌰：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span>=<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span>=<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">onclick</span>=<span class="keyword">function</span> (<span class="params">ev</span>)&#123;</span><br><span class="line">  <span class="title function_">alert</span>(ev.<span class="property">clientX</span>+<span class="string">&#x27;,&#x27;</span>+ev.<span class="property">clientY</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">onclick</span>=<span class="function"><span class="params">ev</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="title function_">alert</span>(ev.<span class="property">clientX</span>+<span class="string">&#x27;,&#x27;</span>+ev.<span class="property">clientY</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">show</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">a</span>: <span class="number">12</span>, <span class="attr">b</span>: <span class="number">5</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">show</span>=(<span class="params"></span>)=&gt;(&#123;<span class="attr">a</span>: <span class="number">12</span>, <span class="attr">b</span>: <span class="number">5</span>&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">show</span>());</span><br></pre></td></tr></table></figure><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>箭头函数完全修复了<code>this</code>的指向，<code>this</code>总是指向词法作用域，也就是外层调用者<code>obj</code>。</p><h3 id="参数展开"><a href="#参数展开" class="headerlink" title="参数展开"></a>参数展开</h3><p>剩余参数必须是最后一个。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">show</span>(<span class="params">a, b, ...arr</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">show</span>(<span class="number">12</span>,<span class="number">5</span>,<span class="number">44</span>,<span class="number">7</span>,<span class="number">85</span>,<span class="number">34</span>,<span class="number">33</span>);</span><br><span class="line"><span class="comment">/* 错误的用法</span></span><br><span class="line"><span class="comment">function show(a, b, ...arr, c)&#123;</span></span><br><span class="line"><span class="comment">  console.log(a, b, arr, c);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>展开数组，就跟把数组的东西写在那一样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=[<span class="number">12</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">99</span>,<span class="number">27</span>];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a,b,c,d,e</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> a+b+c+d+e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// alert(sum(arr[0], arr[1], ...))</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="title function_">sum</span>(...arr));<span class="comment">// 相当于 alert(sum(12,5,8,99,27));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2=[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="keyword">let</span> arr=[...arr1, ...arr2]; <span class="comment">// 相当于 let arr=[1,2,3, 4,5,6];</span></span><br></pre></td></tr></table></figure><h2 id="系统对象"><a href="#系统对象" class="headerlink" title="系统对象"></a>系统对象</h2><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>映射，1 对 1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let arr=[<span class="number">100</span>, <span class="number">98</span>, <span class="number">37</span>, <span class="number">28</span>, <span class="number">19</span>, <span class="number">96</span>, <span class="number">56</span>, <span class="number">67</span>];</span><br><span class="line">let res=arr.<span class="built_in">map</span>(<span class="built_in">function</span> (item)&#123;</span><br><span class="line">    <span class="keyword">if</span>(item&gt;=<span class="number">60</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 使用箭头函数：let res=arr.map(item=&gt;item&gt;=60);</span></span><br><span class="line">console.<span class="built_in">log</span>(arr, res);</span><br></pre></td></tr></table></figure><p><img src="https://wx4.sinaimg.cn/mw690/006wR0dcly1g1d2a0gwenj30ns0cat9r.jpg" alt="map"></p><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><p>遍历，循环一遍。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=[<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">99</span>];</span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//alert(&#x27;第&#x27;+index+&#x27;个：&#x27;+item);</span></span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">`第<span class="subst">$&#123;index&#125;</span>个：<span class="subst">$&#123;item&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>过滤。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=[<span class="number">12</span>, <span class="number">88</span>, <span class="number">19</span>, <span class="number">27</span>, <span class="number">82</span>, <span class="number">81</span>, <span class="number">100</span>, <span class="number">107</span>];</span><br><span class="line"><span class="keyword">let</span> arr2=arr.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span>=&gt;</span>item%<span class="number">2</span>==<span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><p>减少，多对 1。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求和</span></span><br><span class="line"><span class="keyword">let</span> arr=[<span class="number">12</span>, <span class="number">66</span>, <span class="number">81</span>, <span class="number">92</span>];</span><br><span class="line"><span class="keyword">let</span> res=arr.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">tmp, item, index</span>)&#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">`第<span class="subst">$&#123;index&#125;</span>次，<span class="subst">$&#123;tmp&#125;</span>+<span class="subst">$&#123;item&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> tmp+item;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求平均数</span></span><br><span class="line"><span class="keyword">let</span> arr=[<span class="number">12</span>, <span class="number">66</span>, <span class="number">81</span>, <span class="number">92</span>];</span><br><span class="line"><span class="keyword">let</span> res=arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">tmp, item, index</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(index&lt;arr.<span class="property">length</span>-<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> tmp+item;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (tmp+item)/arr.<span class="property">length</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>字符串模板。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;xixi&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">27</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> info = <span class="string">`my name is <span class="subst">$&#123;name&#125;</span>, my age is <span class="subst">$&#123;age&#125;</span>. just a test <span class="subst">$&#123;<span class="number">1</span> + <span class="number">10</span>&#125;</span>!`</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(info);<span class="comment">// my name is xixi, my age is 27. just a test 11!</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>要了解的两个函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url=<span class="string">&#x27;http://www.bing.com/a&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(url.<span class="title function_">startsWith</span>(<span class="string">&#x27;http://&#x27;</span>) || url.<span class="title function_">startsWith</span>(<span class="string">&#x27;https://&#x27;</span>))&#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&#x27;是网址&#x27;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&#x27;不是&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><h4 id="标准写法"><a href="#标准写法" class="headerlink" title="标准写法"></a>标准写法</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;aaa&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;key2&quot;</span><span class="punctuation">:</span> <span class="number">12</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="JSON对象"><a href="#JSON对象" class="headerlink" title="JSON对象"></a>JSON对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stringify 将一个json对象转为字符串(序列化)</span></span><br><span class="line"><span class="keyword">let</span> json=&#123;<span class="attr">a</span>: <span class="number">12</span>, <span class="attr">b</span>: <span class="number">5</span>, <span class="attr">c</span>: <span class="string">&#x27;blue&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> str=<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(json);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str);<span class="comment">// &#123;&quot;a&quot;:12,&quot;b&quot;:5,&quot;c&quot;:&quot;blue&quot;&#125;</span></span><br><span class="line"><span class="comment">// parse将一个字符串 反序列化 为json对象</span></span><br><span class="line"><span class="keyword">let</span> str=<span class="string">&#x27;&#123;&quot;a&quot;:12,&quot;b&quot;:5,&quot;c&quot;:&quot;blue&quot;&#125;&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> json=<span class="title class_">JSON</span>.<span class="title function_">parse</span>(str);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(json);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://wx4.sinaimg.cn/mw690/006wR0dcly1g1d2p42fo8j30iu08cglz.jpg" alt="parse"></p><h2 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h2><p>异步，多个操作可以一起进行，互不干扰。<br>同步，操作一个个进行。</p><p>ajax 异步处理方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;data/1.json&#x27;</span>,</span><br><span class="line">  <span class="attr">dataType</span>: <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">  <span class="title function_">success</span>(<span class="params">data1</span>)&#123;</span><br><span class="line">    $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">      <span class="attr">url</span>: <span class="string">&#x27;data/2.json&#x27;</span>,</span><br><span class="line">      <span class="attr">dataType</span>: <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">      <span class="title function_">success</span>(<span class="params">data2</span>)&#123;</span><br><span class="line">        $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">          <span class="attr">url</span>: <span class="string">&#x27;data/3.json&#x27;</span>,</span><br><span class="line">          <span class="attr">dataType</span>: <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">          <span class="title function_">success</span>(<span class="params">data3</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(data1, data2, data3);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data1=$.<span class="title function_">ajax</span>(<span class="string">&#x27;data/1.json&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> data2=$.<span class="title function_">ajax</span>(<span class="string">&#x27;data/2.json&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> data3=$.<span class="title function_">ajax</span>(<span class="string">&#x27;data/3.json&#x27;</span>);</span><br></pre></td></tr></table></figure><p>promise</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p=<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>)&#123;</span><br><span class="line">  $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;data/1.json&#x27;</span>,</span><br><span class="line">    <span class="attr">dataType</span>: <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">    <span class="title function_">success</span>(<span class="params">data</span>)&#123;</span><br><span class="line">      <span class="title function_">resolve</span>(data);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">error</span>(<span class="params">res</span>)&#123;</span><br><span class="line">      <span class="title function_">reject</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">data</span>)&#123;<span class="comment">// resolve</span></span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&#x27;成功&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">res</span>)&#123;<span class="comment">// reject</span></span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&#x27;失败&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line">  $.<span class="title function_">ajax</span>(&#123;<span class="attr">url</span>: <span class="string">&#x27;data/1.json&#x27;</span>, <span class="attr">dataType</span>: <span class="string">&#x27;json&#x27;</span>&#125;),</span><br><span class="line">  $.<span class="title function_">ajax</span>(&#123;<span class="attr">url</span>: <span class="string">&#x27;data/2.json&#x27;</span>, <span class="attr">dataType</span>: <span class="string">&#x27;json&#x27;</span>&#125;),</span><br><span class="line">  $.<span class="title function_">ajax</span>(&#123;<span class="attr">url</span>: <span class="string">&#x27;data/3.json&#x27;</span>, <span class="attr">dataType</span>: <span class="string">&#x27;json&#x27;</span>&#125;),</span><br><span class="line">]).<span class="title function_">then</span>(<span class="function">(<span class="params">arr</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [data1, data2, data3]=arr;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data1, data2, data3);</span><br><span class="line">&#125;, <span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&#x27;错了&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>async / await</p><p>看起来是同步的方式，这是语法糖提供的方便，编译渲染后还是异步的方式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">show</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> data1=<span class="keyword">await</span> $.<span class="title function_">ajax</span>(&#123;<span class="attr">url</span>: <span class="string">&#x27;data/1.json&#x27;</span>, <span class="attr">dataType</span>: <span class="string">&#x27;json&#x27;</span>&#125;);</span><br><span class="line">  <span class="keyword">let</span> data2=<span class="keyword">await</span> $.<span class="title function_">ajax</span>(&#123;<span class="attr">url</span>: <span class="string">&#x27;data/2.json&#x27;</span>, <span class="attr">dataType</span>: <span class="string">&#x27;json&#x27;</span>&#125;);</span><br><span class="line">  <span class="keyword">let</span> data3=<span class="keyword">await</span> $.<span class="title function_">ajax</span>(&#123;<span class="attr">url</span>: <span class="string">&#x27;data/3.json&#x27;</span>, <span class="attr">dataType</span>: <span class="string">&#x27;json&#x27;</span>&#125;);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data1, data2, data3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;jquery.min.js&quot;</span> charset=<span class="string">&quot;utf-8&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">show</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> data1=<span class="keyword">await</span> $.<span class="title function_">ajax</span>(&#123;<span class="attr">url</span>: <span class="string">&#x27;data/1.json&#x27;</span>, <span class="attr">dataType</span>: <span class="string">&#x27;json&#x27;</span>&#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">if</span>(data1.<span class="property">a</span>&lt;<span class="number">10</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">let</span> data2=<span class="keyword">await</span> $.<span class="title function_">ajax</span>(&#123;<span class="attr">url</span>: <span class="string">&#x27;data/2.json&#x27;</span>, <span class="attr">dataType</span>: <span class="string">&#x27;json&#x27;</span>&#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">alert</span>(<span class="string">&#x27;a&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;<span class="keyword">else</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">let</span> data3=<span class="keyword">await</span> $.<span class="title function_">ajax</span>(&#123;<span class="attr">url</span>: <span class="string">&#x27;data/3.json&#x27;</span>, <span class="attr">dataType</span>: <span class="string">&#x27;json&#x27;</span>&#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">alert</span>(<span class="string">&#x27;b&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="title function_">show</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br></pre></td></tr></table></figure><p>##兼容 IE</p><p>使用 babel。</p><h3 id="在线编译"><a href="#在线编译" class="headerlink" title="在线编译"></a>在线编译</h3><p>给浏览器的执行造成负担。</p><p><strong>使用：</strong> 在 <a href="https://babeljs.io/">https://babeljs.io/</a> 下载 browser.min.js 文件，引入。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意： type=<span class="string">&quot;text/babel&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1e5cii67xj30y40suwr5.jpg" alt="babel"></p><h3 id="编译出来"><a href="#编译出来" class="headerlink" title="编译出来"></a>编译出来</h3><p>先安装 node.js。</p><p>安装 babel 包。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i @babel/core @babel/cli @babel/preset-env</span><br></pre></td></tr></table></figure><p>首先在用之前，用一条命令来生成一个 node.js 的工程文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在工程文件下</span></span><br><span class="line">npm init -y</span><br></pre></td></tr></table></figure><p>然后会在本目录下生成一个 package.json 文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;browser.min.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;build&quot;</span>: <span class="string">&quot;babel src -d dest&quot;</span><span class="comment">// 源文件在哪，生成到哪里去</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;keywords&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在此目录下新建一个<code>.babelrc</code>文件，里面有：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;presets&quot;</span>: [<span class="string">&quot;@babel/preset-env&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 html 代码中引入 src/1.js 文件，然后使用<code>npm run build</code>，就可以生成一个 dest 目录，里面就有兼容 IE 的 ES6代码。</p><hr>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cpp-迭代器</title>
      <link href="/2019/03/19/Cpp-%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
      <url>/2019/03/19/Cpp-%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>C++中的迭代器用法总结。</p><span id="more"></span><p>对于一个容器的遍历，可以用 for 循环，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="string">&quot; world&quot;</span>);</span><br><span class="line">v.<span class="built_in">emplace_back</span>(<span class="string">&quot;, Cpp&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; v[i];</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>也可以用迭代器。</p><p>迭代器：是一种对容器的遍历工具。</p><p>迭代器用起来是指针使用，在内部，不同的容器有不同的实现方式，不一定是原生指针。</p><p>迭代器：正向迭代器、反向迭代器、const迭代器。</p><p>迭代器的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">begin</span>()</span><br><span class="line">  <span class="built_in">end</span>()</span><br><span class="line"><span class="built_in">rbegin</span>()</span><br><span class="line">  <span class="built_in">rend</span>()</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1d5qnucp8j311y0kcgmz.jpg"></p><p>C++11 正向、反向有了一些新功能。</p><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1d5p5wz5gj315m0bajvv.jpg" alt="pic-2"></p><h2 id="正向迭代器"><a href="#正向迭代器" class="headerlink" title="正向迭代器"></a>正向迭代器</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt;::iterator vit = v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (vit != v.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *vit;</span><br><span class="line">    vit++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h2 id="反向迭代器"><a href="#反向迭代器" class="headerlink" title="反向迭代器"></a>反向迭代器</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt;::reverse_iterator rit = v.<span class="built_in">rbegin</span>();</span><br><span class="line"><span class="keyword">while</span> (rit != v.<span class="built_in">rend</span>())</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *rit;</span><br><span class="line">    ++rit;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h2 id="const-迭代器"><a href="#const-迭代器" class="headerlink" title="const 迭代器"></a>const 迭代器</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt;::const_iterator cvit = v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (cvit != v.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *cvit;</span><br><span class="line">    cvit++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h2 id="C-11-语法糖-auto"><a href="#C-11-语法糖-auto" class="headerlink" title="C++11 语法糖 auto"></a>C++11 语法糖 auto</h2><p>在写代码的时候编译器智能提示，让把迭代器改成 auto：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> avit = v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (avit != v.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *avit;</span><br><span class="line">    avit++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h3 id="语法糖-auto-用于-for-循环"><a href="#语法糖-auto-用于-for-循环" class="headerlink" title="语法糖 auto 用于 for 循环"></a>语法糖 auto 用于 for 循环</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : str)</span><br><span class="line">&#123;</span><br><span class="line">  cout &lt;&lt; e &lt;&lt; endl;<span class="comment">// 输出 : abcd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感觉尝不到甜头，来一个🌰，感受下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, std::vector&lt;std::string&gt;&gt; strVMap;</span><br><span class="line">std::map&lt;std::string, std::vector&lt;std::string&gt;&gt;::const_reverse_iterator msvit = strVMap.<span class="built_in">crbegin</span>();</span><br><span class="line"><span class="keyword">while</span> (msvit != strVMap.crend)</span><br><span class="line">&#123;</span><br><span class="line">  ++msvit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : strVMap)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&quality=100&size=b4000_4000&sec=1553089425&di=e0639ca58c0bdfd2905e045f6e77c69f&src=http://f.hiphotos.baidu.com/image/pic/item/d1160924ab18972b016d358bedcd7b899e510a1f.jpg" alt="我靠"></p><blockquote><p>好吧，其实用了 auto 编译器编译后也会成迭代器的形式，这个 Java 里的增强 for 也是。</p></blockquote><h2 id="为什么要出现迭代器"><a href="#为什么要出现迭代器" class="headerlink" title="为什么要出现迭代器"></a>为什么要出现迭代器</h2><p>在 STL 中有很多容器，容器实现的方式是一些不同的数据结构，如果我们要遍历这些容器中的内容，就需要注意一些细节问题(比如单链表的遍历，从后往前遍历，等等的细节问题)。</p><p>迭代器用一种统一的方式来访问容器，不用关心具体的访问细节(屏蔽掉了底层复杂的结构细节)。</p><hr>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cpp-模板初阶</title>
      <link href="/2019/03/18/Cpp-%E6%A8%A1%E6%9D%BF%E5%88%9D%E9%98%B6/"/>
      <url>/2019/03/18/Cpp-%E6%A8%A1%E6%9D%BF%E5%88%9D%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<p>告诉编译器一个模子，让编译器根据不同的类型利用该模子来生成代码。<br>泛型编程：编写与类型无关的通用代码，是代码复用的一种手段。模板是泛型编程的基础。</p><span id="more"></span><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>函数模板代表了一个函数家族，该函数模板与类型无关，在使用时被参数化，根据实参类型产生函数的特定类型版本。</p><h3 id="函数模板的格式"><a href="#函数模板的格式" class="headerlink" title="函数模板的格式"></a>函数模板的格式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2,......,<span class="keyword">typename</span> Tn&gt;</span><br><span class="line">返回值类型 函数名(参数列表)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">// 模板头</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(T&amp; left,  T&amp; right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T temp = left;</span><br><span class="line">    left = right;</span><br><span class="line">    right = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⚠️ 注意：typename 是用来定义模板参数关键字，也可以使用 class (切记：不能使用 struct 代替 class)</p><h3 id="函数模板的原理"><a href="#函数模板的原理" class="headerlink" title="函数模板的原理"></a>函数模板的原理</h3><p>模板是一个蓝图，它本身并不是函数，是编译器用使用方式产生特定具体类型函数的模具。所以其实模板就是将本来应该我们做的重复的事情交给了编译器。</p><p>在编译器编译阶段，对于模板函数的使用，编译器需要根据传入的实参类型来推演生成对应类型的函数以供调用。</p><p>⚠️ 注意：理解一下，这里。比如调用上面的 Swap 函数，传入 int 和 double 最终编译后其实调用的是两个函数，这个可以通过查看汇编代码或者打印函数地址来验证。</p><h3 id="函数模板的实例化"><a href="#函数模板的实例化" class="headerlink" title="函数模板的实例化"></a>函数模板的实例化</h3><p>用不同类型的参数使用函数模板时，称为函数模板的实例化。模板参数实例化分为：<strong>隐式实例化</strong>和<strong>显式实例化</strong>。</p><h4 id="隐式实例化"><a href="#隐式实例化" class="headerlink" title="隐式实例化"></a>隐式实例化</h4><p>让编译器根据实参推演模板参数的实际类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Add</span><span class="params">(<span class="type">const</span> T&amp; left, <span class="type">const</span> T&amp; right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a1 = <span class="number">10</span>, a2 = <span class="number">20</span>;</span><br><span class="line">    <span class="type">double</span> d1 = <span class="number">10.0</span>, d2 = <span class="number">20.0</span>;</span><br><span class="line">    <span class="built_in">Add</span>(a1, a2);</span><br><span class="line">    <span class="built_in">Add</span>(d1, d2);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      该语句不能通过编译，因为在编译期间，当编译器看到该实例化时，需要推演其实参类型 通过实参a1将T推演为int，通过实参d1将T推演为double类型，但模板参数列表中只有一个T， 编译器无法确定此处到底该将T确定为int 或者 double类型而报错</span></span><br><span class="line"><span class="comment">      注意：在模板中，编译器一般不会进行类型转换操作，因为一旦转化出问题，编译器就需要背黑锅</span></span><br><span class="line"><span class="comment">      Add(a1, d1);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 此时有两种处理方式:1. 用户自己来强制转化 2. 使用显式实例化 </span></span><br><span class="line">  <span class="built_in">Add</span>(a, (<span class="type">int</span>)d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="显示实例化"><a href="#显示实例化" class="headerlink" title="显示实例化"></a>显示实例化</h4><p>显式实例化：在函数名后的 &lt;&gt; 中指定模板参数的实际类型。</p><p>如果类型不匹配，编译器会尝试进行隐式类型转换，如果无法转换成功编译器将会报错。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Add</span>&lt;<span class="type">int</span>&gt;(a, b);</span><br></pre></td></tr></table></figure><h3 id="模板参数的匹配原则"><a href="#模板参数的匹配原则" class="headerlink" title="模板参数的匹配原则"></a>模板参数的匹配原则</h3><h4 id="1-懒"><a href="#1-懒" class="headerlink" title="1. 懒"></a>1. 懒</h4><p>一个非模板函数可以和一个同名的函数模板同时存在，而且该函数模板还可以被实例化为这个非模板函数。</p><p>编译器也很「懒」，哈哈。编译器：”这里你已经有了，我就不给你再推断再生成一个函数去覆盖你的了。”</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非模板函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用加法函数 template&lt;class T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Add</span><span class="params">(T left, T right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Add</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 与非模板函数匹配，编译器不需要特化</span></span><br><span class="line"><span class="built_in">Add</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 调用编译器特化的Add版本 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-勤快"><a href="#2-勤快" class="headerlink" title="2. 勤快"></a>2. 勤快</h4><p>对于非模板函数和同名函数模板，如果其他条件都相同，在调动时会优先调用非模板函数而不会从该模板产生出一个实例。如果模板可以产生一个具有更好匹配的函数， 那么将选择模板。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Add</span>(<span class="number">1</span>, <span class="number">2.0</span>);</span><br><span class="line"><span class="comment">// 模板函数可以生成更加匹配的版本，编译器根据实参生成更加匹配的Add函数</span></span><br></pre></td></tr></table></figure><h4 id="3-小气"><a href="#3-小气" class="headerlink" title="3. 小气"></a>3. 小气</h4><p>模板函数不允许自动类型转换，但普通函数可以进行自动类型转换。</p><h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类模板名</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 类内成员定义 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>⚠️ 注意：叫法上有一点需要注意一哈！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">  Date类：</span><br><span class="line">    类名 Date 类型 Date</span><br><span class="line">  模板类：</span><br><span class="line">    类名 Vector 类型 Vector&lt;int&gt;</span><br></pre></td></tr></table></figure><p>🌰 栗子：Vector 动态顺序表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">Vector</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="built_in">Vector</span>(<span class="type">size_t</span> capacity = <span class="number">10</span>)</span><br><span class="line">        : _pData(<span class="keyword">new</span> T[capacity])</span><br><span class="line">        , _size(<span class="number">0</span>)</span><br><span class="line">        , _capacity(capacity)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="comment">// 使用析构函数演示:在类中声明，在类外定义。 ~Vector();</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PushBack</span><span class="params">(<span class="type">const</span> T&amp; data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// _CheckCapacity();</span></span><br><span class="line">        _pData[_size++] = data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PopBack</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        --_size; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">Size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _size;</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> pos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert</span>(pos &lt; _size);</span><br><span class="line">        <span class="keyword">return</span> _pData[pos];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _pData;</span><br><span class="line">    <span class="type">size_t</span> _size;</span><br><span class="line">    <span class="type">size_t</span> _capacity;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>⚠️ 注意：</p><ul><li><p>重载操作符 <code>[]</code> 、实现 Size 接口是为了实现类似于数组的方式访问 private 成员。</p></li><li><p>类模板中函数放在类外进行定义时，需要加模板参数列表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">Vector&lt;T&gt;::~<span class="built_in">Vector</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_pData) </span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] _pData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><p>类模板实例化与函数模板实例化不同，类模板实例化需要在类模板名字后跟 &lt;&gt;，然后将实例化的类型放在 &lt;&gt; 中即可，类模板名字不是真正的类，而实例化的结果才是真正的类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Vector&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">s1.<span class="built_in">PushBack</span>(<span class="number">1</span>);</span><br><span class="line">s1.<span class="built_in">PushBack</span>(<span class="number">2</span>);</span><br><span class="line">s1.<span class="built_in">PushBack</span>(<span class="number">3</span>);</span><br><span class="line">Vector&lt;<span class="type">double</span>&gt; s2;</span><br><span class="line">s2.<span class="built_in">PushBack</span>(<span class="number">1.0</span>);</span><br><span class="line">s2.<span class="built_in">PushBack</span>(<span class="number">2.0</span>);</span><br><span class="line">s2.<span class="built_in">PushBack</span>(<span class="number">3.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; s1.<span class="built_in">Size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;s1[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; s2.<span class="built_in">Size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;s2[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br></pre></td></tr></table></figure><hr><h2 id="STL-简介-入坑😆"><a href="#STL-简介-入坑😆" class="headerlink" title="STL 简介(入坑😆)"></a>STL 简介(入坑😆)</h2><p>真的真的真的方便啊，吼吼吼。</p><p>网上有句话说:“不懂STL，不要说你会C++”，入坑学习咯。</p><p>STL(standard template libaray-标准模板库)：是 C++ 标准库的重要组成部分，不仅是一个可复用的组件库，而且<br>是一个包罗数据结构与算法的软件框架。</p><h3 id="STL-的版本"><a href="#STL-的版本" class="headerlink" title="STL 的版本"></a>STL 的版本</h3><p><strong>原始版本</strong> Alexander Stepanov、Meng Lee 在惠普实验室完成的原始版本，本着开源精神，他们声明允许任何人任意 运用、拷贝、修改、传播、商业使用这些代码，无需付费。唯一的条件就是也需要向原始版本一样做开源使 用。 HP 版本–所有STL实现版本的始祖。 </p><p><strong>P. J. 版本</strong> 由P. J. Plauger开发，继承自HP版本，被Windows Visual C++采用，不能公开或修改，缺陷：可读性比较低， 符号命名比较怪异。 </p><p><strong>RW版本</strong> 由Rouge Wage公司开发，继承自HP版本，被 C+ + Builder 采用，不能公开或修改，可读性一般。</p><p>✨ <strong>SGI版本</strong> 由Silicon Graphics Computer Systems，Inc公司开发，继承自HP版 本。被 <strong>GCC(Linux)</strong> 采用，可移植性好， 可公开、修改甚至贩卖，从命名风格和编程风格上看，阅读性非常高。</p><h3 id="STL-的六大组件"><a href="#STL-的六大组件" class="headerlink" title="STL 的六大组件"></a>STL 的六大组件</h3><p>容器（Container）</p><p>算法（Algorithm）</p><p>迭代器（Iterator）</p><p>仿函数（Function object）</p><p>适配器（Adaptor）</p><p>空间配置器（allocator）</p><h3 id="学习-STL-三个阶段"><a href="#学习-STL-三个阶段" class="headerlink" title="学习 STL 三个阶段"></a>学习 STL 三个阶段</h3><p>能用，明理，能扩展。</p><h3 id="STL-缺陷"><a href="#STL-缺陷" class="headerlink" title="STL 缺陷"></a>STL 缺陷</h3><ol><li><p>STL 库的更新太慢了。这个得严重吐槽，上一版靠谱是C++98，中间的C++03基本一些修订。C++11出来已经相隔了13年，STL才进一步更新。 </p></li><li><p>STL 现在都没有支持线程安全。并发环境下需要我们自己加锁。且锁的粒度是比较大的。</p></li><li><p>STL 极度的追求效率，导致内部比较复杂。比如类型萃取，迭代器萃取。 </p></li><li><p>STL 的使用会有代码膨胀的问题，比如使用 vector/vector/vector 这样会生成多份代码，当然这是模板语法本身导致的。 </p></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cpp-内存管理</title>
      <link href="/2019/03/18/Cpp-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2019/03/18/Cpp-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>C/Cpp 中管理内存的方式。</p><span id="more"></span><h2 id="C-C-内存分布"><a href="#C-C-内存分布" class="headerlink" title="C/C++ 内存分布"></a>C/C++ 内存分布</h2><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1d5txonqqj30dm0ugtal.jpg"></p><p><strong>栈：</strong>又叫堆栈，非静态局部变量/函数参数/返回值等等，栈是向下增长的。 </p><p><strong>内存映射段：</strong>是高效的 I/O 映射方式，用于装载一个共享的动态内存库。用户可使用系统接口创建共享共 </p><p>享内存，做进程间通信。 </p><p><strong>堆：</strong>程序运行过程中动态分配，向上生长。</p><p><strong>数据段：</strong>全局数据、静态数据。</p><p><strong>代码段：</strong>只读常量、可执行代码。</p><h2 id="C-内存管理方式"><a href="#C-内存管理方式" class="headerlink" title="C 内存管理方式"></a>C 内存管理方式</h2><h3 id="malloc-calloc-realloc-和-free"><a href="#malloc-calloc-realloc-和-free" class="headerlink" title="malloc/calloc/realloc 和 free"></a>malloc/calloc/realloc 和 free</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* p1 = (<span class="type">int</span>*) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line">    <span class="comment">// malloc/calloc/realloc的区别是什么?</span></span><br><span class="line">    <span class="type">int</span>* p2 = (<span class="type">int</span>*)<span class="built_in">calloc</span>(<span class="number">4</span>, <span class="built_in">sizeof</span> (<span class="type">int</span>)); </span><br><span class="line">    <span class="type">int</span>* p3 = (<span class="type">int</span>*)<span class="built_in">realloc</span>(p2, <span class="built_in">sizeof</span>(<span class="type">int</span>)*<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 这里需要free(p2)吗?</span></span><br><span class="line">    <span class="built_in">free</span>(p3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⚠️ 这里不能<code>free(p2)</code>，因为 realloc 在申请内存时可能会改变存储的地址，这里只需要 free p3 就行。</p><h2 id="C-内存管理方式-1"><a href="#C-内存管理方式-1" class="headerlink" title="C++ 内存管理方式"></a>C++ 内存管理方式</h2><h3 id="new-amp-delete"><a href="#new-amp-delete" class="headerlink" title="new &amp; delete"></a>new &amp; delete</h3><h4 id="对于内置类型"><a href="#对于内置类型" class="headerlink" title="对于内置类型"></a>对于内置类型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p_a = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="type">int</span> *p_b = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">233</span>);</span><br><span class="line"><span class="type">int</span> *p_arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> p_a;</span><br><span class="line"><span class="keyword">delete</span> p_b;</span><br><span class="line"><span class="keyword">delete</span>[] p_arr;</span><br></pre></td></tr></table></figure><h4 id="对于自定义类型"><a href="#对于自定义类型" class="headerlink" title="对于自定义类型"></a>对于自定义类型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">Student *ps1 = <span class="keyword">new</span> Student;</span><br><span class="line">Student *ps2 = <span class="keyword">new</span> Student[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>在申请自定义类型的空间时，new 会调用构造函数，delete 会调用析构函数，而 malloc 与 free 不会。</p><h3 id="operator-new-amp-operator-delete"><a href="#operator-new-amp-operator-delete" class="headerlink" title="operator new &amp; operator delete"></a>operator new &amp; operator delete</h3><p>operator new 和 operator delete 是系统提供的<strong>全局函数</strong>，new 在底层调用 operator new 全局函数来申请空间，delete 在底层通过 operator delete 全局函数来释放空间。</p><p>operator new 实际也是通过 malloc 来申请空间，如果 malloc 申请空间成功就直接返回，否则执行用户提供的空间不足应对措施，如果用户提供该措施就继续申请，否则就抛异常。operator delete 最终是通过free来释放空间的。</p><h4 id="operator-new"><a href="#operator-new" class="headerlink" title="operator new"></a>operator new</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">operator new:</span></span><br><span class="line"><span class="comment">该函数实际通过malloc来申请空间，当malloc申请空间成功时直接返回;</span></span><br><span class="line"><span class="comment">申请空间失败，尝试执行空间不足应对措施，如果改应对措施用户设置了，则执行，否则抛异常。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> *__CRTDECL <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> _<span class="title">THROW1</span><span class="params">(_STD bad_alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// try to allocate size bytes</span></span><br><span class="line">  <span class="type">void</span> *p;</span><br><span class="line">  <span class="keyword">while</span> ((p = <span class="built_in">malloc</span>(size)) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> (_callnewh(size) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// report no memory</span></span><br><span class="line">      <span class="comment">// 如果申请内存失败了，这里会抛出 bad_alloc 类型异常 </span></span><br><span class="line">      <span class="type">static</span> <span class="type">const</span> std::bad_alloc nomem;</span><br><span class="line">      _RAISE(nomem);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> (p); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="operator-delete"><a href="#operator-delete" class="headerlink" title="operator delete"></a>operator delete</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">operator delete: 该函数最终是通过free来释放空间的 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *pUserData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _CrtMemBlockHeader * pHead;</span><br><span class="line">  <span class="built_in">RTCCALLBACK</span>(_RTC_Free_hook, (pUserData, <span class="number">0</span>));</span><br><span class="line">  <span class="keyword">if</span> (pUserData == <span class="literal">NULL</span>)</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">  _mlock(_HEAP_LOCK);  <span class="comment">/* block other threads */</span></span><br><span class="line">  __TRY</span><br><span class="line">    <span class="comment">/* get a pointer to memory block header */</span></span><br><span class="line">    pHead = <span class="built_in">pHdr</span>(pUserData);</span><br><span class="line">    <span class="comment">/* verify block type */</span></span><br><span class="line">    _ASSERTE(_BLOCK_TYPE_IS_VALID(pHead-&gt;nBlockUse));</span><br><span class="line">    _free_dbg( pUserData, pHead-&gt;nBlockUse );<span class="comment">// 释放空间，调用 _free_dbg</span></span><br><span class="line">  __FINALLY</span><br><span class="line">    _munlock(_HEAP_LOCK);  <span class="comment">/* release other threads */</span></span><br><span class="line">  __END_TRY_FINALLY</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">free</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> free(p)_free_dbg(p, _NORMAL_BLOCK)</span></span><br></pre></td></tr></table></figure><h4 id="🌰-重载类专属-operator-new-operator-delete"><a href="#🌰-重载类专属-operator-new-operator-delete" class="headerlink" title="🌰 重载类专属 operator new/ operator delete"></a>🌰 重载类专属 operator new/ operator delete</h4><p>针对链表的节点 ListNode 通过<strong>重载类专属 operator new/ operator delete</strong>，实现链表节点使用内存池申请和释放内存，提高效率。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line">    ListNode* _next;</span><br><span class="line">    ListNode* _prev;</span><br><span class="line">    <span class="type">int</span> _data;</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">void</span>* p = <span class="literal">nullptr</span>;</span><br><span class="line">        p = <span class="built_in">allocator</span>&lt;ListNode&gt;().<span class="built_in">allocate</span>(<span class="number">1</span>);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;memory pool allocate&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">allocator</span>&lt;ListNode&gt;().<span class="built_in">deallocate</span>((ListNode*)p, <span class="number">1</span>);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;memory pool deallocate&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">List</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">List</span>()</span><br><span class="line">    &#123;</span><br><span class="line">            _head = <span class="keyword">new</span> ListNode;</span><br><span class="line">            _head-&gt;_next = _head;</span><br><span class="line">            _head-&gt;_prev = _head;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">List</span>() </span><br><span class="line">    &#123;</span><br><span class="line">            ListNode* cur = _head-&gt;_next;</span><br><span class="line">            <span class="keyword">while</span> (cur != _head)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode* next = cur-&gt;_next;</span><br><span class="line">                <span class="keyword">delete</span> cur;</span><br><span class="line">                cur = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span> _head;</span><br><span class="line">            _head = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ListNode* _head;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List l;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="new-和-delete-的实现原理"><a href="#new-和-delete-的实现原理" class="headerlink" title="new 和 delete 的实现原理"></a>new 和 delete 的实现原理</h3><h4 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h4><p>如果申请的是内置类型的空间，new 和 malloc，delete 和 free 基本类似。</p><p>不同的地方是：new/delete 申请和释放的是单个元素的空间，new[] 和 delete[] 申请的是连续空间，而且 new 在申请空间失败时会抛异常，malloc 会返回 NULL 。</p><h4 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h4><ul><li>new<ol><li>调用 operator new 函数申请空间</li><li>在申请的空间上执行构造函数，完成对象的构造</li></ol></li><li>delete<ol><li>在空间上执行析构函数，完成对象中资源的清理工作</li><li>调用 operator delete 函数释放对象的空间</li></ol></li><li>new T[N]<ol><li>调用 operator new[] 函数，在 operator new[] 中实际调用 operator new 函数完成 N 个对象空间的申请</li><li>在申请的空间上执行 N 次构造函数</li></ol></li><li>delete[]<ol><li>在释放的对象空间上执行 N 次析构函数，完成 N 个对象中资源的清理</li><li>调用 operator delete[] 释放空间，实际在 operator delete[] 中调用 operator delete 来释放空间</li></ol></li></ul><h3 id="定位-new-表达式（placement-new）"><a href="#定位-new-表达式（placement-new）" class="headerlink" title="定位 new 表达式（placement-new）"></a>定位 new 表达式（placement-new）</h3><p>定位 new 表达式是在已分配的原始内存空间中调用构造函数初始化一个对象。</p><p>使用场景：定位 new 表达式在实际中一般是配合内存池使用。因为内存池分配出的内存没有初始化，所以如果是自定义类型的对象，需要使用 new 的定义表达式进行显示调构造函数进行初始化。</p><p>用法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> (place_address) type;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">new</span> (place_address) <span class="built_in">type</span>(initializer-list);</span><br><span class="line"><span class="comment">// place_address 必须是一个指针，initializer-list 是类型的初始化列表</span></span><br><span class="line"></span><br><span class="line">Date* pd = (Date*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Date));</span><br><span class="line"><span class="comment">// 此时的 pd 指向的空间只是一个大小和 Date 对象一样的空间，并不能算是一个对象，构造函数还没有执行</span></span><br><span class="line"><span class="keyword">new</span>(pd)<span class="built_in">Date</span>(<span class="number">1939</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h2><p><em>内存泄漏指因为疏忽或错误造成程序未能释放已经不再使用的内存的情况。内存泄漏并不是指内存在物理上<br>的消失，而是应用程序分配某段内存后，因为设计错误，失去了对该段内存的控制，因而造成了内存的浪费。</em></p><ul><li><p>内存申请了忘记释放</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p1 = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="type">int</span>* p2 = <span class="keyword">new</span> <span class="type">int</span>;</span><br></pre></td></tr></table></figure></li><li><p>异常安全问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p3 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">Func</span>(); <span class="comment">// 这里Func函数抛异常导致 delete[] p3未执行，p3没被释放. </span></span><br><span class="line"><span class="keyword">delete</span>[] p3;</span><br></pre></td></tr></table></figure></li></ul><h3 id="内存泄露分类"><a href="#内存泄露分类" class="headerlink" title="内存泄露分类"></a>内存泄露分类</h3><ul><li><p>堆内存泄漏(Heap leak)</p><p>堆内存指的是程序执行中依据须要分配通过malloc / calloc / realloc / new等从堆中分配的一块内存，用完后必须通过调用相应的 free 或者 delete 删掉。假设程序的设计错误导致这部分内存没有被释放，那么以后这部分空间将无法再被使用，就会产生 Heap leak。</p></li><li><p>系统资源泄漏</p><p>指程序使用系统分配的资源，比方套接字、文件描述符、管道等没有使用对应的函数释放掉，导致系统资源的浪费，严重可导致系统效能减少，系统执行不稳定。</p></li></ul><h3 id="检测内存泄露"><a href="#检测内存泄露" class="headerlink" title="检测内存泄露"></a>检测内存泄露</h3><ul><li><a href="https://blog.csdn.net/gatieme/article/details/51959654">Linux 下内存泄漏检测工具</a></li><li><a href="https://blog.csdn.net/GZrhaunt/article/details/56839765">Windows 下的第三方工具</a></li><li><a href="https://www.cnblogs.com/liangxiaofeng/p/4318499.html">内存泄漏工具比较</a></li></ul><h3 id="避免内存泄漏"><a href="#避免内存泄漏" class="headerlink" title="避免内存泄漏"></a>避免内存泄漏</h3><p>事前预防型，如智能指针、良好的设计。</p><p>事后查错型，如泄漏检测工具。 </p><hr>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cpp-类和对象</title>
      <link href="/2019/03/15/Cpp-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
      <url>/2019/03/15/Cpp-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>类和对象的知识，面向对象Code吧。</p><span id="more"></span><h2 id="类的引入"><a href="#类的引入" class="headerlink" title="类的引入"></a>类的引入</h2><p>万物皆对象。类是一种用户自定义的数据类型,包括表示属性的成员变量和表示行为的成员函数，类是现实世界对象的抽象,对象是类虚拟世界的实例。</p><ul><li><p>C++ 中 struct 中不仅可以有变量，还可以有函数。</p></li><li><p>类定义结束时后面分号。</p></li><li><p>成员函数声明和定义可以全部放在类体中，需要注意：成员函数如果在类中定义，编译器可能会将其当成内联函数处理。</p></li><li><p>一般定义在 .h 文件中，定义放在 .cpp 文件中。</p></li><li><p>面向对象三大特性：封装、继承、多态。</p></li></ul><h2 id="访问限定符及封装"><a href="#访问限定符及封装" class="headerlink" title="访问限定符及封装"></a>访问限定符及封装</h2><h3 id="访问限定符"><a href="#访问限定符" class="headerlink" title="访问限定符"></a>访问限定符</h3><p>C++ 实现封装的方式：用类将对象的属性与方法结合在一块，让对象更加完善，通过访问权限选择性的将其接口提供给外部的用户使用。</p><p>public 公有的、protected 保护的、private 私有的。</p><ul><li><p>public 修饰的成员在类外可以直接被访问。</p></li><li><p>protected 和 private 修饰的成员在类外不能直接被访问。</p></li><li><p>访问权限作用域从该访问限定符出现的位置开始直到下一个访问限定符出现时为止。</p></li><li><p>class 的默认访问权限为 private ，struct 默认为 public (因为struct要兼容C)。</p></li><li><p>访问限定符只在编译时有用，当数据映射到内存后，没有任何访问限定符上的区别。</p></li></ul><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互。</p><p>封装本质上是一种管理：我们如何管理兵马俑呢？比如如果什么都不管，兵马俑就被随意破坏了。那么我们<br>首先建了一座房子把兵马俑给封装起来。但是我们目的全封装起来，不让别人看。所以我们开放了售票通<br>道，可以买票突破封装在合理的监管机制下进去参观。类也是一样，我们使用类数据和方法都封装到一下。<br>不想给别人看到的，我们使用 protected/private 把成员封装起来。开放一些共有的成员函数对成员合理的访<br>问。所以封装本质是一种管理。</p><h2 id="类的实例化"><a href="#类的实例化" class="headerlink" title="类的实例化"></a>类的实例化</h2><p>用类类型创建对象的过程，称为类的实例化。</p><p>类好比是一个房子的设计图纸，类的实例化就是按照图纸建造一个房子。一个设计图可以建好几套房子。</p><p>造对象~~~。</p><h2 id="类的对象模型"><a href="#类的对象模型" class="headerlink" title="类的对象模型"></a>类的对象模型</h2><h3 id="计算类对象的大小"><a href="#计算类对象的大小" class="headerlink" title="计算类对象的大小"></a>计算类对象的大小</h3><p>❓ 类中既可以有成员变量，又可以有成员函数，那么一个类的对象中包含了什么？如何计算一个类的大小？</p><p>✔️ 只保存成员变量，成员函数存放在公共的代码段。一个类的大小，实际就是该类中”成员变量”之和，当然也要进行内存对齐，注意空类的大小，空类比较特殊，编译器给了空类一个字节来唯一标识这个类。</p><p>🌰 栗子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A1</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 类中仅有成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A2</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 类中什么都没有---空类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A3</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof(A1) : &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(A1) &lt;&lt; endl;<span class="comment">// 4</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof(A2) : &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(A2) &lt;&lt; endl;<span class="comment">// 1</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof(A3) : &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(A3) &lt;&lt; endl;<span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内存对齐规则"><a href="#内存对齐规则" class="headerlink" title="内存对齐规则"></a>内存对齐规则</h3><p>结构体内存对齐规则：</p><ul><li><p>第一个成员在与结构体偏移量为 0 的地址处。</p></li><li><p>其他成员变量要对齐到某个数字(对齐数)的整数倍的地址处。</p><ul><li><p>对齐数 = 编译器默认的一个对齐数与该成员大小的较小值。</p></li><li><p>VS 中默认的对齐数为 8，gcc 中的对齐数为 4 。</p></li></ul></li><li><p>结构体总大小为：最大对齐数(所有变量类型最大者与默认对齐参数取最小)的整数倍。</p></li><li><p>如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数(含嵌套结构体的对齐数)的整数倍。</p></li></ul><p>结构体的内存对齐规则适用于类。</p><p>⚠️ 类中嵌套的类是不占用空间的，只有当有了类的对象后，才会占用空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A1</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">A2</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;<span class="comment">// sizeof(A1) = 4</span></span><br></pre></td></tr></table></figure><p>❓ 为什么要进行内存对齐？</p><p>✔️ <a href="https://www.cnblogs.com/jijiji/p/4854581.html">https://www.cnblogs.com/jijiji/p/4854581.html</a></p><p>❓ 如何让结构体按照指定的对齐参数进行对齐？</p><p>✔️ <code>#pragma pack(4)</code></p><p>❓ 如何知道结构体中某个成员相对于结构体起始位置的偏移量？</p><p>✔️ 造个对象，地址相减。</p><p>✔️ <code>&amp;(((type*)0)-&gt;m)</code>。</p><p>❓ 什么是大小端？如何测试某台机器是大端还是小端？有没有遇到过要考虑大小端的场景？</p><p>✔️ 在网络通信中会涉及到。</p><h2 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h2><p>成员函数最终会被编译成与对象无关的普通函数。除了成员变量，丢失所有信息。</p><p>C++ 编译器给每个“成员函数“增加了一个隐藏的指针参数，让该指针指向当前对象(函数运行时调用该函数的对象)，在函数体中所有成员变量的操作，都是通过该指针去访问。只不过所有的操作对用户是透明的，即用户不需要来传递，编译器自动完成。</p><ul><li><p>this 指针是 const 的，类型为对象的类型。</p></li><li><p>只能在“成员函数”的内部使用。</p></li><li><p>this 指针本质上其实是一个成员函数的形参，是对象调用成员函数时，将对象地址作为实参传递给 this 形参。所以对象中不存储 this 指针。</p></li><li><p>this 指针是成员函数第一个隐含的指针形参，一般情况由编译器通过 ecx 寄存器自动传递，不需要用户传递。</p></li></ul><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1d5shp7ywj315m0ggmzu.jpg"></p><h2 id="6-个默认成员函数"><a href="#6-个默认成员函数" class="headerlink" title="6 个默认成员函数"></a>6 个默认成员函数</h2><p>任何一个类在我们不写的情况下，都会自动生成下面6个默认成员函数。</p><p><code>class Date &#123;&#125;;</code></p><ul><li>初始化和清理<ul><li><a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">构造函数</a>：完成初始化工作</li><li><a href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0">析构函数</a>：完成清理工作</li></ul></li><li>拷贝复制<ul><li><a href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0">拷贝构造</a>：使用同类对象初始化创建对象</li><li>赋值重载：把一个对象赋值给另一个对象</li></ul></li><li>[取地址重载](#取地址及 const 取地址操作符重载)<ul><li>主要是普通对象和 const 对象取地址，这两个很少会自己实现</li></ul></li></ul><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数是一个特殊的成员函数，名字与类名相同，创建类类型对象时由编译器<strong>自动调用</strong>，保证每个数据成员都有一个合适的初始值，并且在对象的<strong>生命周期内只调用一次</strong>。</p><ul><li><p>构造函数可以重载。</p></li><li><p>为成员变量赋初始值，分配资源（是给对象的成员变量分配资源），设置对象的初始状态。</p></li><li><p>函数名与类名相同，没有返回类型。</p></li><li><p>对象创建时自动调用且只调用一次。</p><ul><li>栈区创建对象：对象定义语句。</li><li>堆区创建对象：new 操作符。</li></ul></li><li><p>自定义成员类型要调用自己的构造函数，编译器自动生成的构造函数会自己调用它。</p></li><li><p>对象创建过程：</p><ol><li>为整个对象分配内存；</li><li>构造基类部分（如果存在基类）；</li><li>构造成员变量；</li><li>执行构造函数代码。</li></ol></li><li><p>一般访问属性为 public，除非我们不允许外部创建对象。</p></li></ul><p>⚠️</p><ul><li>构造函数的虽然名称叫构造，但是需要注意的是构造函数的主要任务<strong>并不是给对象开空间创建对象，而是初始化对象，给对象里的成员变量开空间、赋值</strong>。 </li><li>如果通过无参构造函数创建对象时，对象后面不用跟括号，否则就成了函数声明。如<code>Date d3();</code>，声明了d3函数，该函数无参，返回一个日期类型的对象。</li><li>如果类中没有显式定义构造函数，则编译器会自动生成一个无参的默认构造函数，一旦用户显式定义编译器将不再生成。</li><li>无参的构造函数和全缺省的构造函数都称为默认构造函数，并且默认构造函数只能有一个。</li><li>无参构造和全缺省构造都称为默认构造函数，并且默认只能有一个。</li></ul><h4 id="成员变量命名风格"><a href="#成员变量命名风格" class="headerlink" title="成员变量命名风格"></a>成员变量命名风格</h4><p><code>m_name</code>、<code>_age</code>，具体看要求~，主要是和参数做区分。</p><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>与构造函数功能相反，析构函数不是完成对象的销毁，局部对象销毁工作是由编译器完成的。而对象在销毁时会自动调用析构函数，完成类的一些资源清理工作。</p><ul><li>无参数无返回值。</li><li>只有一个析构函数，不能重载。</li><li>负责对象销毁时回收对象占用资源。</li><li>自定义成员类型要调用自己的析构，编译器自动生成的析构函数会自己调用它。</li><li>在析构函数中 delete / free 构造函数中 new / malloc 的东西。</li><li>在用完对象后 delete 对象，调用析构函数，当对象的生命周期后，自动调用析构函数。</li></ul><p>⚠️ 析构函数中，释放空间前要判断要释放的空间是否为 NULL / nullptr，释放完后要指向空，避免野指针。</p><h3 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造"></a>拷贝构造</h3><p>用已存在的类类型对象创建新对象时由编译器自动调用。</p><ul><li><p>拷贝构造函数是构造函数的一个重载形式。</p></li><li><p>参数只有一个且必须使用引用传参（并且加 const 修饰），使用传值方式会引发无穷递归调用。</p><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1d5ssmkd1j31ck0okdj7.jpg"></p></li><li><p>如果一个类没有定义拷贝构造函数，那么编译器提供一个默认拷贝构造函数（public）。</p></li><li><p>系统生成默认的拷贝构造函数。 默认的拷贝构造函数对象按内存存储按字节序完成拷<br>贝，这种拷贝我们叫做<strong>浅拷贝</strong>，或者值拷贝。</p><p>例如：成员变量中有一个<code>char *</code>的成员变量，系统生成的默认拷贝构造会拷贝这个指针变量的值（指向的地址）给新的对象，这样，这两个对象就指向的同一块空间，在析构的时候会出现问题。</p></li></ul><h3 id="类型转换构造"><a href="#类型转换构造" class="headerlink" title="类型转换构造"></a>类型转换构造</h3><p>构造函数不仅可以构造与初始化对象，<strong>对于单个参数的构造函数，还具有类型转换的作用</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">int</span> year):_year(year)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _year;</span><br><span class="line">    <span class="type">int</span> _month:</span><br><span class="line">    <span class="type">int</span> _day; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestDate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Date <span class="title">d1</span><span class="params">(<span class="number">2018</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 用一个整形变量给日期类型对象赋值</span></span><br><span class="line">    <span class="comment">// 实际编译器背后会用2019构造一个无名对象，最后用无名对象给d1对象进行赋值 </span></span><br><span class="line">    d1 = <span class="number">2019</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码可读性不是很好，用 <strong>explicit</strong> 修饰构造函数，将会禁止单参构造函数的隐式转换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Date</span><span class="params">(<span class="type">int</span> year)</span>:_year(year)&#123;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><ul><li>不能通过连接其他符号来创建新的操作符：比如 operator@。</li><li>重载操作符必须有一个类类型或者枚举类型的操作数，<code>int operator+(int a, int b) &#123;&#125;</code>，就是不可以的。</li><li>作为类成员的重载函数时，其形参看起来比操作数数目少 1 成员函数的操作符有一个默认的形参 this，限定为第一个形参，<code>bool operator==(Date* this, const Date&amp; d2)</code>，调用<code>cout&lt;&lt;(d1 == d2)&lt;&lt;endl;</code>相当于<code>d1.operator==(d2)</code>。</li><li>一个类如果没有显式定义赋值运算符重载，编译器也会生成一个，完成对象按字节序的值拷贝。</li><li><code>#</code>、<code>-&gt;*</code>、<code>.* </code>、<code>::</code> 、<code>sizeof</code>、<code>?:</code>、 <code>.</code> 注意以上5个运算符不能重载。这个经常在笔试选择题中出现。</li></ul><p>⚠️  <code>.</code>、<code>.*</code>运算符不能重载是为了保证访问成员的功能不能被改变，域运算符合<code>sizeof</code>运算符的运算对象是类型而不是变量或一般表达式，不具备重载的特征。</p><p>❓ 运算符重载成全局的就需要成员变量是共有的，封装性如何保证？</p><p>✔️ 友元或者直接重载成成员函数。</p><p>⚠️ <img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1d5t2d0lkj319k0lygr0.jpg"></p><p>⚠️ 重载前置++（<code>Complex&amp; operator++()</code>）和后置++（<code>Complex operator++(int)</code>，哑元占位，用来区分）这种的运算符应注意！</p><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1d5tfcs8jj317c0rm77z.jpg"></p><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><h3 id="const-修饰类的成员变量"><a href="#const-修饰类的成员变量" class="headerlink" title="const 修饰类的成员变量"></a>const 修饰类的成员变量</h3><p>必须使用初始化参数列表初始化，初始化之后不能修改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">A</span>():<span class="built_in">m_a</span>(<span class="number">10</span>)&#123;&#125;   <span class="comment">//常成员变量必须用这种方式赋初始值</span></span><br><span class="line">    ~<span class="built_in">A</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="const-修饰类的成员函数"><a href="#const-修饰类的成员函数" class="headerlink" title="const 修饰类的成员函数"></a>const 修饰类的成员函数</h3><p>将 const 修饰的类成员函数称之为 const 成员函数，const 修饰类成员函数，实际修饰该成员函数隐含的 this 指针，表明在该成员函数中不能对类的任何成员进行修改，也叫常函数。</p><p>⚠️ 常函数内部无法修改成员变量的值，除非 <strong>mutable</strong> 修饰该成员变量。</p><p><code>void Display() const&#123;...&#125;</code> &lt;=&gt; <code>void Display(const Date* this)&#123;...&#125;</code></p><h3 id="const-对象"><a href="#const-对象" class="headerlink" title="const 对象"></a>const 对象</h3><ul><li><p>这个对象里的成员变量是无法修改的。</p></li><li><p>被const修饰的对象，对象指针或对象引用，统称为<strong>常对象</strong>。</p></li><li><p>常对象只能调用常函数，非常对象即可调用常函数，也可调用非常函数，优先调用非常版本。</p></li><li><p>成员函数常版本和非常版本可以构成重载。</p></li></ul><p>⚠️ 区别的标记并不是谁离得近，而是他在<code>*</code>号的前面还是后面。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Person* p = &amp;p1;<span class="comment">//对象是const</span></span><br><span class="line">Person <span class="type">const</span>* p = &amp;p1;<span class="comment">//对象是const</span></span><br><span class="line">Person *<span class="type">const</span> p = &amp;p1;<span class="comment">//指针是const</span></span><br></pre></td></tr></table></figure><h3 id="取地址及-const-取地址操作符重载"><a href="#取地址及-const-取地址操作符重载" class="headerlink" title="取地址及 const 取地址操作符重载"></a>取地址及 const 取地址操作符重载</h3><p>这两个默认成员函数一般不用重新定义，编译器默认会生成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    Date* <span class="keyword">operator</span>&amp;()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> Date* <span class="keyword">operator</span>&amp;()<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line"><span class="type">int</span> _year ; <span class="comment">// 年</span></span><br><span class="line">    <span class="type">int</span> _month ; <span class="comment">// 月</span></span><br><span class="line">    <span class="type">int</span> _day ; <span class="comment">// 日</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>⚠️ 这两个运算符一般不需要重载，使用编译器生成的默认取地址的重载即可，只有特殊情况，才需要重载，比<br>如<strong>想让别人获取到指定的内容!</strong></p><h2 id="再谈构造函数"><a href="#再谈构造函数" class="headerlink" title="再谈构造函数"></a>再谈构造函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span><br><span class="line">    &#123;</span><br><span class="line">        _year = year;</span><br><span class="line">        _month = month;</span><br><span class="line">        _day = day;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>虽然上述构造函数调用之后，对象中已经有了一个初始值，但是不能将其称作为类对象成员的初始化，构造<br>函数体中的语句只能将其称作为赋初值，而不能称作初始化。因为初始化只能初始化一次，而构造函数体内<br>可以多次赋值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Currency</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SavingsAccount</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SavingsAccount</span>(<span class="type">const</span> <span class="type">char</span>* name,<span class="type">const</span> <span class="type">char</span>* address,<span class="type">int</span> cents);<span class="comment">// 这里是不合适的</span></span><br><span class="line">    <span class="comment">// Person and Currency都有自己的构造函数，应该由自己来初始化自己，而不是SavingsAccount来构造</span></span><br><span class="line">    ~<span class="built_in">SavingAccount</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Person m_saver;</span><br><span class="line">    Currency m_balance;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p>初始化列表：以一个冒号开始，接着是一个以逗号分隔的数据成员列表，每个”成员变量”后面跟一个放在括 号中的初始值或表达式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// So:</span></span><br><span class="line">SavingsAccount::<span class="built_in">SavingsAccount</span>(<span class="type">const</span> <span class="type">char</span> * name,<span class="type">const</span> <span class="type">char</span>* address,<span class="type">int</span> cents):<span class="built_in">m_saver</span>(name,address),<span class="built_in">m_balance</span>(<span class="number">0</span>,cents)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SavingsAccount::print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_saver.<span class="built_in">print</span>();    <span class="comment">//print() in saver</span></span><br><span class="line">    m_balance.<span class="built_in">print</span>();  <span class="comment">//print() in balance</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⚠️</p><ul><li>每个成员变量在初始化列表中只能出现一次（初始化只能初始化一次）。</li><li>类中包含以下成员，必须放在初始化列表位置进行初始化：<ul><li>引用成员变量（引用在定义的是时候必须初始化）</li><li>const 成员变量（和上面一个道理，const在定义的时候必须初始化一个值）</li><li>类类型成员（该类没有默认构造函数，如果有，要通过自己的构造函数来初始化）</li></ul></li><li>成员变量在类中声明次序就是其在初始化列表中的初始化顺序，与其在初始化列表中的先后次序无关。</li></ul><h3 id="C-11成员初始化新方式"><a href="#C-11成员初始化新方式" class="headerlink" title="C++ 11成员初始化新方式"></a>C++ 11成员初始化新方式</h3><p>非静态成员变量，可以在成员声明时，直接初始化。</p><p>相当于给无参构造函数一个缺省参数。</p><h2 id="static-成员"><a href="#static-成员" class="headerlink" title="static 成员"></a>static 成员</h2><p>声明为 static 的类成员称为类的静态成员，用 static 修饰的成员变量，称之为静态成员变量；用 static 修饰的成员函数，称之为静态成员函数。</p><p>面试题：实现一个类，计算中程序中创建出了多少个类对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;++_scount;&#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; t) &#123;++_scount;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">GetACount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _scount;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> _scount;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Test::_count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;A::<span class="built_in">GetACount</span>()&lt;&lt;endl;</span><br><span class="line">    A a1, a2;</span><br><span class="line">    <span class="function">A <span class="title">a3</span><span class="params">(a1)</span></span>;</span><br><span class="line">    cout&lt;&lt;A::<span class="built_in">GetACount</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⚠️ </p><ul><li>静态的成员变量一定要在类外进行初始化。</li><li>静态成员为所有类对象所共享，不属于某个具体的实例。</li><li>静态成员变量必须在类外定义，定义时不添加static关键字。</li><li>类静态成员即可用<code>类名::静态成员</code>或者<code>对象.静态成员</code>来访问。</li><li>静态成员函数没有隐藏的 this 指针，不能访问任何非静态成员。</li><li>静态成员和类的普通成员一样，也有public、protected、private3种访问级别，也可以具有返回值，const修饰符等参数。</li></ul><p>❓ 静态成员函数可以调用非静态成员函数吗？</p><p>✔️ 不可以，非静态的成员函数默认有一个参数（this指针），但是静态成员函数没有这个 this 指针传给他，所以不可以调用。</p><p>❓ 非静态成员函数可以调用类的静态成员函数吗？</p><p>✔️ 可以。</p><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>友元提供了一种突破封装的方式，有时提供了便利。但是友元会增加<strong>耦合度</strong>，破坏了封装，所以友元不宜多用。</p><h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>友元函数可以直接访问类的私有成员，它是定义在类外部的普通函数，不属于任何类，但需要在类的内部声明，声明时需要加 friend 关键字。</p><ul><li>友元函数可访问类的私有成员，但不是类的成员函数</li><li>友元函数不能用 const 修饰</li><li>友元函数可以在类定义的任何地方声明，不受类访问限定符限制</li><li>一个函数可以是多个类的友元函数</li><li>友元函数的调用与普通函数的调用和原理相同</li></ul><p>问题：现在我们尝试去重载operator&lt;&lt;，然后发现我们没办法将operator&lt;&lt;重载成成员函数。因为 cout 的输出流对象和隐含的this指针在抢占第一个参数的位置。this 指针默认是第一个参数也就是左操作数了。但是实际使用中cout需要是第一个形参对象，才能正常使用。所以我们要将operator&lt;&lt;重载成全局函数。但是这样的话，又会导致类外没办法访问成员，那么这里就需要友元来解决。operator&gt;&gt;同理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span><br><span class="line">        : _year(year)</span><br><span class="line">        , _month(month)</span><br><span class="line">        , _day(day) &#123;&#125;</span><br><span class="line">    ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; _cout)</span><br><span class="line">    &#123;</span><br><span class="line">        _cout&lt;&lt;d._year&lt;&lt;<span class="string">&quot;-&quot;</span>&lt;&lt;d._month&lt;&lt;<span class="string">&quot;-&quot;</span>&lt;&lt;d._day;</span><br><span class="line">        <span class="keyword">return</span> _cout;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _year;</span><br><span class="line">    <span class="type">int</span> _month;</span><br><span class="line">    <span class="type">int</span> _day </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Date <span class="title">d</span><span class="params">(<span class="number">2017</span>, <span class="number">12</span>, <span class="number">24</span>)</span></span>;</span><br><span class="line">    d&lt;&lt;cout;<span class="comment">// 这种使用方式很别扭，不符合使用习惯</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用友元修改后：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; _cout, <span class="type">const</span> Date&amp; d);</span><br><span class="line">    <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; _cin, <span class="type">const</span> Date&amp; d);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span><br><span class="line">        : _year(year)</span><br><span class="line">        , _month(month)</span><br><span class="line">        , _day(day)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _year;</span><br><span class="line">    <span class="type">int</span> _month;</span><br><span class="line">    <span class="type">int</span> _day </span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; _cout, <span class="type">const</span> Date&amp; d)</span><br><span class="line">&#123;</span><br><span class="line">    _cout&lt;&lt;d._year&lt;&lt;<span class="string">&quot;-&quot;</span>&lt;&lt;d._month&lt;&lt;<span class="string">&quot;-&quot;</span>&lt;&lt;d._day;</span><br><span class="line">    <span class="keyword">return</span> _cout;</span><br><span class="line">&#125;</span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; _cin, <span class="type">const</span> Date&amp; d)</span><br><span class="line">&#123;</span><br><span class="line">    _cin&gt;&gt;d._year;</span><br><span class="line">    _cin&gt;&gt;d._month;</span><br><span class="line">    _cin&gt;&gt;d._day;</span><br><span class="line">    <span class="keyword">return</span> _cin;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Date d;</span><br><span class="line">    cin&gt;&gt;d;</span><br><span class="line">    cout&lt;&lt;d&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><p>友元类的所有成员函数都可以是另一个类的友元函数，都可以访问另一个类中的非公有成员。</p><ul><li><p>友元关系是单向的，不具有交换性。</p><p>我把你当朋友，带你去我家吃好吃的，你却不把我当朋友，不带我去你家。</p></li><li><p>友元关系不能传递。</p><p>如果 B 是 A 的友元，C 是 B 的友元，则不能说明 C 时 A 的友元。</p></li></ul><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>如果一个类定义在另一个类的内部，这个内部类就叫做内部类。注意此时这个内部类是一个独立的类，它不属于外部类，更不能通过外部类的对象去调用内部类。外部类对内部类没有任何优越的访问权限。</p><ul><li>内部类可以定义在外部类的 public、protected、private 都是可以的。</li><li>内部类可以直接访问外部类中的 static、枚举成员，不需要外部类的对象/类名。</li><li>sizeof(外部类)=外部类，和内部类没有任何关系。</li></ul><p>⚠️ 内部类就是外部类的友元类。注意友元类的定义，内部类可以通过外部类的对象参数来访问外部类中的所有成员。但是外部类不是内部类的友元。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> k;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> A&amp; a)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout &lt;&lt; k &lt;&lt; endl;<span class="comment">//OK</span></span><br><span class="line">            cout &lt;&lt; a.h &lt;&lt; endl;<span class="comment">//OK</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> A::k = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A::B b;</span><br><span class="line">    b.<span class="built_in">foo</span>(<span class="built_in">A</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cpp-入门</title>
      <link href="/2019/03/13/Cpp-%E5%85%A5%E9%97%A8/"/>
      <url>/2019/03/13/Cpp-%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>从C到C++，我要面朝对象了。</p><span id="more"></span><h2 id="从-C-到-C"><a href="#从-C-到-C" class="headerlink" title="从 C 到 C++"></a>从 C 到 C++</h2><ol><li><p><code>cout</code>中的 c 指的是 console。</p></li><li><p><code>endl</code> =&gt; end line。</p></li><li><p>作用域限定符<code>::</code>相当于中文<code>的</code>，表示作用域或所属关系。</p></li><li><p><code>extern &quot;C&quot;</code></p><p>有时候在 C++ 工程中可能需要将某些函数按照 C 的风格来编译，在代码前加 extern “C” ，意思是告诉编译器，将该函数按照C语言规则来编译。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> “C”</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">something</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>typeid(变量名).name</code>输出变量的类型。</p></li><li><p><code>bool</code>类型，true 为真，false 为假。</p><p>任何基本类型都可以隐士转换为 bool 类型，非 0 即真，0 即假。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">boolalpha -&gt; 相当于一个开关，表示开，打印 true / false</span></span><br><span class="line"><span class="comment">noboolalpha -&gt; 表示关，关闭后打印 0 / 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">bool</span> a = <span class="literal">false</span>;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; boolalpha &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">a = <span class="number">20</span>;</span><br><span class="line">cout &lt;&lt; noboolalpha &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">a = *(<span class="string">&quot;abc&quot;</span>+<span class="number">3</span>); <span class="comment">// 0-&gt;a 1-&gt;b 2-&gt;c 3-&gt;\0</span></span><br><span class="line">cout &lt;&lt; boolalpha &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    这三种意思相同</span></span><br><span class="line"><span class="comment">    a = *(&quot;abc&quot;+3);</span></span><br><span class="line"><span class="comment">    a = &quot;abc&quot;[3];</span></span><br><span class="line"><span class="comment">    a = 3[&quot;abc&quot;];</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="命名空间（namespace）"><a href="#命名空间（namespace）" class="headerlink" title="命名空间（namespace）"></a>命名空间（namespace）</h2><blockquote><p>在 C/C++ 中，变量、函数和后面要学到的类都是大量存在的，这些变量、函数和类的名称将都存在于全局作用域中，可能会导致很多冲突。使用命名空间的目的是对标识符的名称进行本地化，以避免命名冲突或名字污染，namespace 关键字的出现就是针对这种问题的。</p></blockquote><ol><li><p>相同名字的 namespace 作用域相同，同一个工程中允许存在多个相同名称的命名空间，编译器最后会合成同一个命名空间中。</p></li><li><p>命名空间的作用：避免名字冲突、划分逻辑单元，名字空间中的声明和定义可以分开。</p></li><li><p>名字空间可以嵌套，使用时候得一层一层的扒皮。</p></li><li><p>名字空间也可以赋值取别名，🌰 栗子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">namespace</span> A11</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">namespace</span> A12</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">something</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> A = A1::A11::A12;</span><br><span class="line"><span class="comment">// A1::A11::A12::something(); 等价于 A::something();</span></span><br></pre></td></tr></table></figure></li><li><p><code>using namespace A1;</code>就相当于”裸奔“ ，把 A1 中的东西暴露在当前作用域下。</p><p><code> using namespace std;</code>也是一样，把 cout 暴露在全局下。</p><p>风险：可能会出现命名冲突，一般还是带上<code>::</code>。</p></li></ol><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="缺省参数"><a href="#缺省参数" class="headerlink" title="缺省参数"></a>缺省参数</h3><blockquote><p>缺省参数是声明或定义函数时为函数的参数指定一个默认值。在调用该函数时，如果没有指定实参则采用该默认值，否则使用指定的实参。</p></blockquote><p>全缺省参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestFunc</span><span class="params">(<span class="type">int</span> a = <span class="number">10</span>, <span class="type">int</span> b = <span class="number">20</span>, <span class="type">int</span> c = <span class="number">30</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>半缺省参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestFunc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>, <span class="type">int</span> c = <span class="number">20</span>)</span></span>;</span><br></pre></td></tr></table></figure><ol><li><p>缺省参数必须从右开始设置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*ERROR*/</span> <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a = <span class="number">3</span>,<span class="type">char</span> b,<span class="type">char</span> *c = <span class="string">&quot;ahoj&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>缺省参数不能在函数声明和定义中同时出现，建议声明时指定。如果生命与定义位置同时出现，恰巧两个位置提供的值不同，那编译器就无法确定到底该用那个缺省值。</p></li><li><p>缺省值必须是常量或者全局变量。</p></li><li><p>C语言不支持(编译器不支持)。</p></li></ol><h3 id="哑元"><a href="#哑元" class="headerlink" title="哑元"></a>哑元</h3><blockquote><p>只指定类型而不指定名称的函数，占着茅坑不拉屎。</p></blockquote><p>🌰 栗子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ya</span><span class="params">(<span class="type">int</span>,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="built_in">ya</span>(<span class="number">10</span>,<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>兼容老版本。</li><li>支持函数重载。</li></ol><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><blockquote><p>自然语言中，一个词可以有多重含义，人们可以通过上下文来判断该词真实的含义，即该词被重载了。<br>比如：以前有一个笑话，国有两个体育项目大家根本不用看，也不用担心。一个是乒乓球，一个是男足。前者是“谁也赢不了”，后者是“谁也赢不了” 。</p><p>函数重载：是函数的一种特殊情况，C++ 允许在同一作用域中声明几个功能类似的同名函数，这些同名函数的形参列表(参数个数 / 类型 / 顺序)必须不同，常用来处理实现功能类似数据类型不同的问题。</p></blockquote><p>🌰 栗子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;void foo();&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;void foo(int a);&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;void foo(int a,int b);&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> a,<span class="type">double</span> b)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;void foo(int a,double b);&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">double</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;void foo(double a,int b);&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>();</span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">1</span> , <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">1</span> , <span class="number">3.14</span>);</span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">3.14</span> , <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>同一作用域，函数名相同，参数表不同的函数。</li><li>参数表不同：<ul><li>参数类型不同</li><li>参数个数不同</li><li>参数顺序不同</li></ul></li><li>重载和形参名无关。</li><li>重载和返回类型无关。</li><li>不同作用域同名函数遵循就近原则。</li></ol><h4 id="重载的原理"><a href="#重载的原理" class="headerlink" title="重载的原理"></a>重载的原理</h4><p><code>nm a.out</code>，查看 C++ 编译器给看书取得名字：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000001000010</span>a0 T __Z3Maxii</span><br><span class="line"><span class="number">0000000100000</span>de0 T __Z3foodi</span><br><span class="line"><span class="number">0000000100000</span>cf0 T __Z3fooi</span><br><span class="line"><span class="number">0000000100000</span>d90 T __Z3fooid</span><br><span class="line"><span class="number">0000000100000</span>d40 T __Z3fooii</span><br><span class="line"><span class="number">0000000100000</span>b50 T __Z3foov</span><br></pre></td></tr></table></figure><p>C++ 函数重载通过编译器改名实现。</p><h4 id="名字修饰（Name-Mangling）"><a href="#名字修饰（Name-Mangling）" class="headerlink" title="名字修饰（Name Mangling）"></a>名字修饰（Name Mangling）</h4><p>在 C/C++ 中，一个程序要运行起来，需要经历：预处理、编译、汇编、链接。</p><p>Name Mangling 是一种在编译过程中，将函数、变量的名称重新改编的机制，简单来说就是编译器为了区分各个函数，将函数通过某种算法，重新修饰为一个全局唯一的名称。</p><p>C语言的名字修饰规则非常简单，只是在函数名字前面添加了下划线。</p><p>C++ 要支持函数重载、命名空间等，使得其修饰规则比较复杂，不同编译器在底层的实现方式可能都有差<br>异。</p><p>被重新修饰后的名字中包含了：函数的名字以及参数类型。这就是为什么函数重载中几个同名函数要求其参数<br>列表不同的原因。只要参数列表不同，编译器在编译时通过对函数名字进行重新修饰，将参数类型包含在最终<br>的名字中，就可保证名字在底层的全局唯一性。</p><p>📒 文章：</p><p><a href="http://www.cnblogs.com/skynet/archive/2010/09/05/1818636.html">C++的函数重载</a></p><h2 id="引用（-amp-）"><a href="#引用（-amp-）" class="headerlink" title="引用（&amp;）"></a>引用（&amp;）</h2><blockquote><p>引用不是新定义一个变量，而是给已存在变量取了一个别名，编译器不会为引用变量开辟内存空间，它和它引用的变量共用同一块内存空间。</p><p>李白 &lt;=&gt; 李太白 青莲居士 诗仙 ……</p></blockquote><p>🌰 栗子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span>&amp; b = a;</span><br><span class="line">    <span class="type">int</span>&amp; c = b;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    c = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &amp;a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;c &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;==========&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">foo</span>(a);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>引用必须初始化且不能为空。</li><li>引用不能更换目标。</li><li>一个变量可以有多个引用。</li><li>引用不占用额外的内存。</li><li>引用类型必须和引用实体是同种类型的。</li></ol><h3 id="常引用"><a href="#常引用" class="headerlink" title="常引用"></a>常引用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestConstRef</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// int&amp; ra = a; // 该语句编译时会出错，a为常量 const int&amp; ra = a;</span></span><br><span class="line">    <span class="comment">// int&amp; b = 10; // 该语句编译时会出错，b为常量 const int&amp; b = 10;</span></span><br><span class="line">    <span class="type">double</span> d = <span class="number">12.34</span>;</span><br><span class="line">    <span class="comment">// int&amp; rd = d; // 该语句编译时会出错，类型不同 const int&amp; rd = d;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li><p>做参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">int</span>&amp; left, <span class="type">int</span>&amp; right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = left;</span><br><span class="line">    left = right;</span><br><span class="line">    right = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>做返回值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">TestRefReturn</span><span class="params">(<span class="type">int</span>&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a += <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> a; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>⚠️</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c = a + b;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>&amp; ret = <span class="built_in">Add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">Add</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Add(1, 2) is :&quot;</span>&lt;&lt; ret &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这段代码输出结果为一个随机值</span></span><br></pre></td></tr></table></figure><p><em>如果函数返回时，离开函数作用域后，其栈上空间已经还给系统，因此不能用栈上的空间作为引用类型<br>返回。如果以引用类型返回，返回值的生命周期必须不受函数的限制(即比函数生命周期长)。</em></p><p><em>传值和传引用（作为参数 / 作为返回值）在效率上的差距！</em></p><h3 id="引用和指针的区别"><a href="#引用和指针的区别" class="headerlink" title="引用和指针的区别"></a>引用和指针的区别</h3><ol><li><p>在语法概念上引用就是一个别名，没有独立空间，和其引用实体共用同一块空间。</p></li><li><p>在底层实现上实际是有空间的，因为引用是按照指针方式来实现的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>&amp; ra = a;</span><br><span class="line">    ra = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span>* pa = &amp;a;</span><br><span class="line">    *pa = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看汇编代码：</p><p>保留编译过程中生成的临时文件：<code>g++ a.cpp -save-temps</code></p><p>其中<code>a.s</code>就是汇编文件，在 VS 里面可以 DEBUG 起来，直接看汇编代码，比较方便。</p><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1d5ubiv1sj311c0dcabr.jpg"></p></li><li><p>引用在定义时必须初始化，指针没有要求。</p></li><li><p>没有NULL引用，但有NULL指针。</p></li><li><p>在 sizeof 中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数( 32 位平台下占 4 </p><p>个字节) 。</p></li><li><p>引用自加即引用的实体增加 1 ，指针自加即指针向后偏移一个类型的大小。</p></li><li><p>有多级指针，没有多级引用。</p></li><li><p>访问实体方式不同，指针需要显式解引用，引用编译器自己处理。</p></li><li><p>引用比指针使用起来相对更安全。</p></li></ol><h2 id="内联函数（inline）"><a href="#内联函数（inline）" class="headerlink" title="内联函数（inline）"></a>内联函数（inline）</h2><blockquote><p>以 inline 修饰的函数叫做内联函数，编译时 C++ 编译器会在调用内联函数的地方展开，没有函数压栈的开销，内联函数提升程序运行的效率。</p></blockquote><p>以下是没有加 inline 的汇编代码。</p><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1d5ulq49ej31140eamz0.jpg"></p><p>在 Add 前加了 inline 后，在编译期间编译器会用函数体替换函数的调用。</p><p><img src="https://ws1.sinaimg.cn/large/006wR0dcly1g1d5uunx5yj310c0e0jtd.jpg"></p><ol><li><p>inline 是一种以空间换时间的做法，省去调用函数额开销。所以代码很长或者有循环 / 递归的函数不适宜使<br>用作为内联函数。</p></li><li><p> inline 对于编译器而言只是一个建议，编译器会自动优化，如果定义为inline的函数体内有循环/递归等等，编译器优化时会忽略掉内联。</p></li><li><p>inline 不建议声明和定义分离，分离会导致链接错误。因为 inline 被展开，就没有函数地址了，链接就会找不到。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// F.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// F.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;F.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;F.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 链接错误:main.obj : error LNK2019: 无法解析的外部符号 &quot;void __cdecl f(int)&quot; (?f@@YAXH@Z)，该符号在函数 _main 中被引用</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="auto（C-11）"><a href="#auto（C-11）" class="headerlink" title="auto（C++11）"></a>auto（C++11）</h2><blockquote><p>在早期 C/C++ 中 auto 的含义是：使用 auto 修饰的变量，是具有自动存储器的局部变量，但遗憾的是一直没有人去使用它。</p><p>C++11 中，标准委员会赋予了 auto 全新的含义即：auto 不再是一个存储类型指示符，而是作为一个新的类型指示符来指示编译器，auto 声明的变量必须由编译器在编译时期推导而得。</p></blockquote><p>🌰 栗子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">TestAuto</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">auto</span> d = <span class="built_in">TestAuto</span>();</span><br><span class="line"><span class="comment">//auto e; 无法通过编译，使用auto定义变量时必须对其进行初始化</span></span><br></pre></td></tr></table></figure><p>⚠️</p><ol><li><p>使用 auto 定义变量时必须对其进行初始化，在编译阶段编译器需要根据初始化表达式来推导 auto 的实际类<br>型。因此 auto 并非是一种“类型”的声明，而是一个类型声明时的“占位符”，编译器在编译期会将 auto 替换为变量实际的类型。</p></li><li><p>用 auto 声明指针类型时，用 auto 和 auto* 没有任何区别，但用 auto 声明引用类型时则必须加 &amp;。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">auto</span> a = &amp;x;</span><br><span class="line">    <span class="keyword">auto</span>* b = &amp;x;</span><br><span class="line">    <span class="keyword">auto</span>&amp; c = x;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(a).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(b).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(c).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    *a = <span class="number">20</span>;</span><br><span class="line">    *b = <span class="number">30</span>;</span><br><span class="line">     c = <span class="number">40</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当在同一行声明多个变量时，这些变量必须是相同的类型，否则编译器将会报错，因为编译器实际只对第一个类型进行推导，然后用推导出来的类型定义其他变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> c = <span class="number">3</span>, d = <span class="number">4.0</span>; <span class="comment">// 该行代码会编译失败，因为c和d的初始化表达式类型不同</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="auto-不能推导的场景"><a href="#auto-不能推导的场景" class="headerlink" title="auto 不能推导的场景"></a>auto 不能推导的场景</h3><ol><li><p>auto 不能作为函数的参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">auto</span> a)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>auto 不能直接用来声明数组。</p></li><li><p>为了避免与 C++98 中的 auto 发生混淆，C++11 只保留了 auto 作为类型指示符的用法。</p></li><li><p>auto 在实际中最常见的优势用法就是跟以后会讲到的 C++11 提供的新式 for 循环，还有 lambda 表达式等进 </p><p>行配合使用。</p></li><li><p>auto 不能定义类的非静态成员变量。</p></li><li><p>实例化模板时不能使用 auto 作为模板参数。</p></li></ol><h2 id="基于范围的-for-循环（C-11）"><a href="#基于范围的-for-循环（C-11）" class="headerlink" title="基于范围的 for 循环（C++11）"></a>基于范围的 for 循环（C++11）</h2><p>🌰 栗子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestFor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> array[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; e : array)</span><br><span class="line">    &#123;</span><br><span class="line">         e *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> e : array)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; e &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⚠️</p><ol><li><p>与普通循环类似，可以用 continue 来结束本次循环，也可以用 break 来跳出整个循环。</p></li><li><p>for 循环迭代的范围必须是确定的，对于数组而言，就是数组中第一个元素和最后一个元素的范围;对于类而言，应该提供 begin 和 end 的方法，begin 和 end 就是 for 循环迭代的范围。 </p></li><li><p>```cpp<br>// 下面这段代码就有问题<br>void TestFor(int array[])<br>{</p><pre><code>for(auto&amp; e : array)&#123;    cout&lt;&lt; e &lt;&lt;endl;&#125;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## nullptr（C++11）</span><br><span class="line"></span><br><span class="line">NULL 实际是一个宏，在传统的 C 头文件`stddef.h`中：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#ifndef NULL</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">#define NULL    0</span><br><span class="line">#else</span><br><span class="line">#define NULL    ((void *)0)</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></li></ol><p>NULL 可能被定义为字面常量 0，或者被定义为无类型指针 (void*) 的常量。不论采取何种定义，在<br>使用空值的指针时，都不可避免的会遇到一些麻烦，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;f(int)&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;f(int*)&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">f</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">f</span>((<span class="type">int</span>*)<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序本意是想通过 f(NULL) 调用指针版本的 f(int*) 函数，但是由于 NULL 被定义成 0，因此与程序的初衷相悖。 在C++98 中，字面常量 0 既可以是一个整形数字，也可以是无类型的指针 (void*) 常量，但是编译器默认情况下将其看成是一个整形常量，如果要将其按照指针方式来使用，必须对其进行强转 (void *)0。 </p><p>为了避免混淆，C++11 提供了 nullptr ，即：nullptr 代表一个指针空值常量。nullptr 是有类型的，其类型为nullptr_t ，仅仅可以被隐式转化为指针类型，nullptr_t 被定义在头文件中：</p><p><code>typedef decltype(nullptr) nullptr_t;</code></p><p>⚠️</p><ol><li>在使用 nullptr 表示指针空值时，不需要包含头文件，因为 nullptr 是 C++11 作为新关键字引入的。</li><li>在 C++11 中，sizeof(nullptr) 与 sizeof((void*)0) 所占的字节数相同。</li><li>为了提高代码的健壮性，在后续表示指针空值时建议最好使用nullptr。</li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git-提交规范</title>
      <link href="/2019/03/13/Git-%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83/"/>
      <url>/2019/03/13/Git-%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<p>Git提交规范方便你我。<br>转载，原文链接：<a href="http://jartto.wang/2018/07/08/git-commit/">http://jartto.wang/2018/07/08/git-commit/</a></p><span id="more"></span><h2 id="为什么需要规范"><a href="#为什么需要规范" class="headerlink" title="为什么需要规范"></a>为什么需要规范</h2><p>无规矩不成方圆，编程也一样。</p><p>Git Commit 规范可能并没有那么夸张，但如果你在版本回退的时候看到一大段糟心的 Commit，恐怕会懊恼不已吧。所以，严格遵守规范，利人利己。</p><h2 id="具体规则"><a href="#具体规则" class="headerlink" title="具体规则"></a>具体规则</h2><p>公式：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">type</span>&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line">// 注意冒号后有个空格</span><br></pre></td></tr></table></figure><ul><li><p><strong>type</strong></p><p>用于说明 commit 的类别，只允许使用下面7个标识。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">feat：新功能（feature）</span><br><span class="line">fix：修补bug</span><br><span class="line">docs：文档（documentation）</span><br><span class="line">style： 格式（不影响代码运行的变动）</span><br><span class="line">refactor：重构（即不是新增功能，也不是修改bug的代码变动）</span><br><span class="line">test：增加测试</span><br><span class="line">chore：构建过程或辅助工具的变动</span><br></pre></td></tr></table></figure></li><li><p><strong>scope</strong></p><p>用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。</p></li><li><p><strong>subject</strong></p><p>是 commit 目的的简短描述，不超过50个字符。</p><p>以动词开头，使用第一人称现在时，比如change，而不是changed或changes</p><p>第一个字母小写，结尾不加句号(.)</p></li></ul><h2 id="如何修改之前的-commit-信息"><a href="#如何修改之前的-commit-信息" class="headerlink" title="如何修改之前的 commit 信息"></a>如何修改之前的 commit 信息</h2><ol><li><p>将当前分支无关的工作状态进行暂存</p><p><code>git stash </code></p></li><li><p>将 HEAD 移动到需要修改的 commit 上</p><p><code>git rebase 9633cf0919^ --interactive</code></p></li><li><p>找到需要修改的 commit ,将首行的 pick 改成 edit</p></li><li><p>开始着手解决你的 bug</p></li><li><p>git add 将改动文件添加到暂存</p></li><li><p>git commit –amend 追加改动到提交</p></li><li><p>git rebase –continue 移动 HEAD 回最新的 commit</p></li><li><p>恢复之前的工作状态</p><p><code>git stash pop</code></p></li></ol><p>大功告成</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C-数组的不对称边界</title>
      <link href="/2019/03/11/C-%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%8D%E5%AF%B9%E7%A7%B0%E8%BE%B9%E7%95%8C/"/>
      <url>/2019/03/11/C-%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%8D%E5%AF%B9%E7%A7%B0%E8%BE%B9%E7%95%8C/</url>
      
        <content type="html"><![CDATA[<p>不对称边界，在计算机科学中经常会见到，比如一个数组有10个元素，它的下标为**[0,10)**。<br>一个有趣的知识：<a href="https://blog.csdn.net/Hanoi_ahoj/article/details/82931630">为什么很多编程语言从0开始编号</a></p><span id="more"></span><h2 id="一个小问题"><a href="#一个小问题" class="headerlink" title="一个小问题"></a>一个小问题</h2><p>如果一个数组有10个元素，那么这个数组下表的允许取值范围是什么呢？</p><p>下面代码1，这段代码的运行结果是什么？为什么？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 代码1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">12</span>; i++)<span class="comment">// 注意这里是 i&lt;12</span></span><br><span class="line">    &#123;</span><br><span class="line">        arr[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hey, girl!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果出人意料。</p><p>这段代码在Windows下DevC++下运行结果是：死循环。。。</p><img src="https://wx4.sinaimg.cn/mw690/006wR0dcly1fwrgx9ulprj30mz0juabe.jpg" width="50%" height="50%" /><p>来看看why：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;i = %p\n&quot;</span>, &amp;i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;arr[0] = %p\n&quot;</span>, &amp;arr[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;arr[10] = %p\n&quot;</span>, &amp;arr[<span class="number">10</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;arr[11] = %p\n&quot;</span>, &amp;arr[<span class="number">11</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><img src="https://wx4.sinaimg.cn/mw690/006wR0dcly1fwrh7mtbwmj30k40f6gmp.jpg" width="50%" height="50%" /><p>从输出的结果可以得到<code>i</code>和<code>arr[]</code>在内存中的样子：</p><img src="https://wx3.sinaimg.cn/mw690/006wR0dcly1fwrhofc35gj30kq132abj.jpg" width="30%" height="30%" /><p><code>&amp;arr[11] == &amp;i</code>，当循环中做<code>arr[11] = 0;</code>这步操作时，也把循环变量i的值改为了0，这样就陷入了一个死循环。</p><p>我们把<code>int i = 0;</code>这句话写在数组<code>int arr[10] = &#123;0&#125;;</code>这句的后面再试试：</p><img src="https://wx4.sinaimg.cn/mw690/006wR0dcly1fwrhvflpi6j30le0em0tu.jpg" width="40%" height="40%" /><p>可以看到，这次 i 的地址就在数组arr地址的下面了，这下就不是死循环的情况咯。</p><p>另外！对于不同平台下代码1的运行结果是不同的：</p><ol><li><p>Microsoft Visual Studio在debug下是死循环，但是在release下编译运行程序就不是死循环，debug模式下没有进行任何优化，在release模式下将变量在内存中进行了优化，不会出现死循环。</p></li><li><p>在MAC OS gcc下编译执行代码1，不会死循环，而且不论i是定义在数组上面还是数组下面，i的地址都是在数组首元素地址的前面，数组向后访问，不会访问到i。</p><p><img src="https://wx4.sinaimg.cn/mw690/006wR0dcly1fwrjr2o5x8j31eq0ei0xq.jpg" alt="pic1"></p><p><img src="https://wx2.sinaimg.cn/mw690/006wR0dcly1fwrjnfxuk8j31080fw417.jpg" alt="pic2"></p><p>嘿嘿，如果i是负数的话，还是会改变到循环变量i的地址滴，下面这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1234</span>;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;i = %p\n&quot;</span>, &amp;i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;arr[0] = %p\n&quot;</span>, &amp;arr[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">12</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[-i] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;nice to meet you!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="不对称边界"><a href="#不对称边界" class="headerlink" title="不对称边界"></a>不对称边界</h2><blockquote><p>C语言中数组的这种特别的设计正是其最大优势所在。    ——《C陷阱与缺陷》</p><p>在编码过程中，for语句循环控制变量采用半开半闭区间的写法。    ——《高质量C++/C编程指南》的建议【4-5-1】</p></blockquote><p>why？</p><p>这个其实是为了增加代码的可读性，看下面这段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">16</span>; i&lt;=<span class="number">37</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        something1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">16</span>; j&lt;<span class="number">38</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        something2();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题：在第一个循环中<code>something1()</code>被调用了多少次，在第二个循环中<code>something2()</code>被调用多少次。</p><p>答案：37-16+1 = 22次，38-16 = 22。</p><p>显然半开半闭区间比较直观。</p><img src="https://wx2.sinaimg.cn/mw690/006wR0dcly1fwrk6oymgvj31kw0wxgsx.jpg" width="50%" height="50%" /><blockquote><p>这种不对称也许从数学上而言并不优美，但是它对于程序设计的简化效果却足以令人吃惊：</p><ol><li>取值范围的大小就是上界与下界的差。38-16的值是22，恰是不对称边界16和38之间所包括的元素数目。</li><li>如果取值范围为空，那么上界等于下界。</li><li>即使取值范围为空，上界也永远不可能小于下界。</li></ol><p>像C语言这样的数组下标从0开始的语言，不对称边界给程序设计带来的便利尤为明显：这种数组的上界(即第一个“出界点”)恰是循环执行的次数。</p></blockquote><p>按照这种不对称边界的惯例，有如下语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">my_strcpy</span><span class="params">(<span class="type">char</span> *str_dest, <span class="type">const</span> <span class="type">char</span> *str_src)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(str_dest != <span class="literal">NULL</span>);</span><br><span class="line">    assert(str_src != <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> *tmp = str_dest;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>((*tmp++ = *str_src++))<span class="comment">// 这里是重点</span></span><br><span class="line">    &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> str_dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外：在计算字符串长度时候，我们可以用这样的上界指针减去字符串首元素地址的指针然后除每个元素大小。</p><p><code>string_length = (upp - downp)/sizeof(downp[0]);</code></p><hr><p>参考书籍：</p><blockquote><p>《高质量C++/C编程指南》、《C陷阱与缺陷》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c-字符串相关的库函数</title>
      <link href="/2019/03/11/C-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0/"/>
      <url>/2019/03/11/C-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>C语言中关于字符串处理的一些函数。</p><span id="more"></span><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><p><code>#include &lt;string.h&gt;</code></p><h3 id="strlen"><a href="#strlen" class="headerlink" title="strlen()"></a>strlen()</h3><p><code>size_t strlen(const char *s);</code></p><ul><li>以<code>\0</code>作为结束标志，这个函数返回的是字符串中第一个<code>\0</code>前面的字符个数，不包括<code>\0</code>。</li><li>函数的返回值是<code>size_t</code>，是一个无符号的数。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * s1 = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * s2 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(s2) - <span class="built_in">strlen</span>(s1) &gt; <span class="number">0</span>)<span class="comment">// 无符号数 - 无符号数 = 无符号数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;s1 &lt; s2\n&quot;</span>);<span class="comment">// 输出这句！</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;s1 &gt; s2\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy()"></a>strcpy()</h3><p><code>char * stpcpy(char * dst, const char * src);</code></p><ul><li><p>函数的返回值是拷贝后的<code>dst</code>的地址。</p></li><li><p>源字符串必须以<code>\0</code>结束。</p></li><li><p>会将源字符串中的<code>\0</code>拷贝到目标空间。</p></li><li><p>目标空间必须足够大，足以容纳源字符串。</p></li><li><p>目标空间必须可以改变！</p><h3 id="strncpy"><a href="#strncpy" class="headerlink" title="strncpy()"></a>strncpy()</h3><p><code>char * strncpy(char * dst, const char * src, size_t len);</code></p><ul><li>拷贝len个字符串从源字符串到目标字符串</li><li>如果源字符串的长度小于len，拷贝完源字符串之后，在目标后面继续追加0，直到len个。</li></ul><p><img src="https://wx3.sinaimg.cn/mw690/006wR0dcly1fxoyvwya4wj314i0u0wi3.jpg" alt="strncpy"></p></li></ul><h3 id="strcat"><a href="#strcat" class="headerlink" title="strcat()"></a>strcat()</h3><p><code>char * strcat(char *restrict s1, const char *restrict s2);</code></p><ul><li><p>源字符串必须以<code>\0</code>结束。</p></li><li><p>目标空间必须足够大，足以容纳源字符串。</p></li><li><p>目标空间必须可以改变！</p></li><li><p><strong>字符串自己给自己拼接，会把<code>\0</code>覆盖掉（因为拼接过程是一个字符一个字符的copy）。</strong></p><h3 id="strncat"><a href="#strncat" class="headerlink" title="strncat()"></a>strncat()</h3><p><code>char * strncat(char *restrict s1, const char *restrict s2, size_t n);</code></p><ul><li>从s2中拷贝n个字符串到s1字符串的后面，如果s2字符串的长度小于n，只拷贝到<code>\0</code>为止。</li></ul><p><img src="https://wx2.sinaimg.cn/mw690/006wR0dcly1fxoz0lmbpzj314e0u0gpy.jpg" alt="strncat"></p></li></ul><h3 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp()"></a>strcmp()</h3><p><code>int strcmp(const char *s1, const char *s2);</code></p><p>注意！这个函数比较的是对应位置的ascii码的大小，而不是比较长度。</p><ul><li><p><code>s1 &gt; s2</code>，返回大于0的数。</p></li><li><p><code>s1 == s2</code>，返回0。</p></li><li><p><code>s1 &lt; s2</code>，返回小于0的数。</p><h3 id="strncmp"><a href="#strncmp" class="headerlink" title="strncmp()"></a>strncmp()</h3><p><code>int strncmp(const char *s1, const char *s2, size_t n);</code></p><ul><li>比较到出现第一个字符不一样的地方或一个字符串结束或者n个字符全部比完。</li></ul><p>栗子：查找以<code>R2</code>开头的字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[][<span class="number">5</span>] = &#123; <span class="string">&quot;R2D2&quot;</span>, <span class="string">&quot;C3PO&quot;</span>, <span class="string">&quot;R2A6&quot;</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;<span class="number">3</span>; n++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strncmp</span>(str[n], <span class="string">&quot;R2xx&quot;</span>, <span class="number">2</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str[n]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="strstr"><a href="#strstr" class="headerlink" title="strstr()"></a>strstr()</h3><p><code>char * strstr(const char *haystack, const char *needle);</code></p><ul><li>查找第二个字符串参数在第一个参数重首次出现的地方，返回指向这个地方的指针。</li></ul><p>栗子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;This is a simple string!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> * p = <span class="literal">NULL</span>;</span><br><span class="line">    p = <span class="built_in">strstr</span>(str, <span class="string">&quot;simple&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, p);</span><br><span class="line">    <span class="built_in">strncpy</span>(p, <span class="string">&quot;aaaaaa&quot;</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">puts</span>(p);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="strtok"><a href="#strtok" class="headerlink" title="strtok()"></a>strtok()</h3><p><code>char * strtok(char *restrict str, const char *restrict sep);</code></p><p><strong>打散字符串！</strong></p><ul><li><p>第一个参数str是要打散的字符串，第二个参数是个字符串，定义了用作分隔符的字符集合。</p></li><li><p>第一个参数必须是可以修改的。打散的过程其实就是将str中出现sep的地方替换为<code>\0</code>，对于str中连续出现的分隔符，只会将第一个分隔符替换为<code>\0</code>，其他的跳过。</p><p>例如：str = <code>str:::str:end</code>，sep = <code>:</code>。</p></li><li><p><code>strtok</code>函数的第一个参数不为<code>NULL</code>，函数将找到<code>str</code>中第一个标记，<code>strtok</code>函数将保存它在字符串中的位置。</p></li><li><p><code>strtok</code>函数的第一个参数为<code>NULL</code>，函数将在同一个字符串中被保存的位置开始，查找下一个标记。</p></li><li><p>如果字符串中不存在更多的标记，返回<code>NULL</code>指针。</p></li></ul><p>栗子1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">100</span>] = <span class="string">&quot;abcdefg@qq.com&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *e = <span class="string">&quot;@.&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    p = strtok(str, e);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(p);</span><br><span class="line">        p = strtok(<span class="literal">NULL</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栗子2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">100</span>] = <span class="string">&quot;str::::str...end&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *e = <span class="string">&quot;:.&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *p = strtok(str, e);</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(p);</span><br><span class="line">        p = strtok(<span class="literal">NULL</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://wx4.sinaimg.cn/mw690/006wR0dcly1fxp0450dcuj30zt0u0n3a.jpg" alt="strtok"></p><p>可以看到，当出现连续的分隔符时候，只会把第一个分隔符替换为<code>\0</code>，跳过后面的分隔符，返回的值是遇到的第一个不是分隔符的地址。</p><h3 id="strerror"><a href="#strerror" class="headerlink" title="strerror()"></a>strerror()</h3><p><code>char * strerror(int errnum);</code></p><ul><li>返回错误码，对应的错误信息。</li></ul><p>栗子：输出结果：<strong>No such file or directory</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C库中，<code>errno.h</code>是一个全局的错误码，成功为0，不成功为非0。非0表示失败，还有为什么失败的字符串描述。</p><p>main函数的返回值称为程序的退出码，在Linux下使用：<code>echo $?</code>命令可以查看最近一次程序执行完成的退出码。</p><p><img src="https://wx2.sinaimg.cn/mw690/006wR0dcly1fxp159wyw3j30xc09k768.jpg" alt="echo $?"></p><h2 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h2><p><code>#include &lt;ctype.h&gt;</code></p><table><thead><tr><th>函数</th><th>参数满足以下条件，返回值为1</th></tr></thead><tbody><tr><td>iscntrl()</td><td>任何控制字符</td></tr><tr><td>isspace()</td><td>空白字符：空格、换页符、换行、回车、制表符<code>\t</code>或者垂直制表符<code>\v</code></td></tr><tr><td>isdigit()</td><td>十进制数字：0～9</td></tr><tr><td>isxdigit()</td><td>十六进制数字：0～9、A～F、a～f</td></tr><tr><td>islower()</td><td>是小写字母</td></tr><tr><td>isupper()</td><td>是大写字母</td></tr><tr><td>isalpha()</td><td>是字母a<del>z、A</del>Z</td></tr><tr><td>isalnum()</td><td>是字母或者十进制数字</td></tr><tr><td>ispunct()</td><td>标点符号，任何不属于数字或字母的图形字符(可打印)</td></tr><tr><td>isgraph()</td><td>任何图形字符</td></tr><tr><td>isprint()</td><td>任何可打印的字符</td></tr></tbody></table><hr>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab基础</title>
      <link href="/2019/03/11/Matlab%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/03/11/Matlab%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>《Matlab 基础》整理了下 MATLAB 的基础知识，在《计算方法》实验中会用到。</p><span id="more"></span><p>三个区域：</p><p>Command Window 用于输入命令和得到输出结果</p><p>Workspace 记录Command中用到的变量</p><p>Command History 记录Command输入历史</p><h1 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h1><h2 id="基础运算"><a href="#基础运算" class="headerlink" title="基础运算"></a>基础运算</h2><ul><li><p>清空屏幕</p><p><code>clc</code></p></li><li><p>注释</p><p><code>%</code></p></li><li><p>加减乘除</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">2</span></span><br><span class="line"><span class="number">1</span> - <span class="number">2</span></span><br><span class="line"><span class="number">1</span> * <span class="number">2</span></span><br><span class="line"><span class="number">1</span> / <span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p>指数</p><ul><li><p>例如$5^2$</p><p><code>5^2</code></p></li></ul></li><li><p>对数</p><ul><li><p>例如：$\ln32$</p><p><code>log(32)</code></p></li><li><p>$\lg32$</p><p><code>log10(32)</code></p></li><li><p>$\log_232$</p><p><code>log2(32)</code></p></li><li><p>$\log_87 = \frac{\log_e7}{\log_e8}$</p><p><code>log(7)/log(8)</code></p></li></ul></li><li><p>三角函数</p><p><code>sin(x)</code></p><p><code>cos(x)</code></p><p>还有一些其他的三角函数，动手试一试。</p></li><li><p>变量</p><p><code>x = 10</code></p><p><code>y = 20</code></p><p><code>x + y</code></p><p>不可以这样<code>x + 1 = 2</code>，没办法直接来解方程。在Matlab中<code>=</code>是赋值符号，不是<strong>等于</strong>。这个类似于C语言。</p><p>可以这样：<code>x = x + 1</code></p><p>输出变量的值：<code>fprintf(&#39;%g\n&#39;, x);</code>或者<code>disp(x);</code></p></li><li><p>按方向键⬆️⬇️用来重复命令</p><p>这个和Linux中一样。</p></li><li><p>$\sqrt3$</p><p><code>sqrt(3)</code></p></li></ul><h2 id="向量运算"><a href="#向量运算" class="headerlink" title="向量运算"></a>向量运算</h2><ul><li><p>$\vec x = (1,2,3)$</p><p><code>x = [1,2,3]</code>或<code>x = [1 2 3]</code></p></li><li><p>$\vec x*2$</p><p>这个是计算$\vec x*2$的值，但是$\vec x$的值并没有改变，只是计算了这个表达式的结果。</p><p><code>x = x * 2</code>，这样才会改变$\vec x$的值，这个和C语言一样～</p></li><li><p>当然也可以做向量和向量的基本运算（加减乘除）等。</p></li><li><p><code>sum(x)</code></p><p>这个命令是用来求和的，例如：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>];</span><br><span class="line"><span class="built_in">disp</span>(sum(v));<span class="comment">% 输出 6</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h2><ul><li><p>矩阵<br>$$<br>A =<br>\begin{Bmatrix}<br>\mathbf{1} &amp; \mathbf{2} &amp; \mathbf{3} \<br>\mathbf{4} &amp; \mathbf{5} &amp; \mathbf{6}<br>\end{Bmatrix}<br>$$</p><p>$$<br>B =<br>\begin{Bmatrix}<br>\mathbf{7} &amp; \mathbf{8} &amp; \mathbf{9} \<br>\mathbf{10} &amp; \mathbf{11} &amp; \mathbf{12}<br>\end{Bmatrix}<br>$$</p></li></ul><p>  输入：<code>A = [1 2 3;4 5 6]</code></p><p>  按上面的输入同样，矩阵B</p><p>  输入：<code>B = [7,8,9;10,11,12]</code></p><p>  然后就可以做矩阵的运算咯，<code>A*B,A+B,A-B,A/B</code>等。</p><p>  注意这里矩阵运算需要遵循矩阵运算规则。</p><ul><li><p>另一种矩阵乘法</p><p>在Matlab中输入<code>A*B</code>就是数学中的矩阵乘法</p><p>还有一种是输入<code>A.*B</code>，这样就是矩阵每个位置($A_{i,j}*B_{i,j}$)对应相乘。</p></li></ul><h2 id="Script"><a href="#Script" class="headerlink" title="Script"></a>Script</h2><ul><li><p>New Script</p><p>在脚本里写一堆命令。</p><p>例如：计算$x+y$</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span>;<span class="comment">% 加了;后，在command window里，就不会出现x=10的结果。</span></span><br><span class="line">y = <span class="number">20</span>;<span class="comment">% 也可以不加分号。</span></span><br><span class="line">x + y</span><br></pre></td></tr></table></figure><p>保存脚本扩展名为.m -&gt; 然后在左面切换到刚才保存的文件夹 -&gt; RUN</p><p>写脚本可以实现输入互动，例如：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = input(<span class="string">&#x27;Please input x:&#x27;</span>);</span><br><span class="line">y = input(<span class="string">&#x27;Please input y:&#x27;</span>);</span><br><span class="line"></span><br><span class="line">x + y</span><br></pre></td></tr></table></figure><p>然后RUN，输入x，y，就会输出结果。</p><ul><li><p>例子：摄氏温度转华氏温度</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C = input(<span class="string">&#x27;enter a temperature in Celesius:&#x27;</span>);</span><br><span class="line">F = (C * <span class="number">1.8</span>) + <span class="number">32</span></span><br><span class="line"></span><br><span class="line">fprintf(<span class="string">&#x27;Fahrenheit = %f\n&#x27;</span>, F);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>栗子1：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">num = input(<span class="string">&#x27;enter a number:&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> num &gt; <span class="number">0</span></span><br><span class="line">fprintf(<span class="string">&#x27;正数\n&#x27;</span>);</span><br><span class="line"><span class="keyword">elseif</span> num == <span class="number">0</span></span><br><span class="line">fprintf(<span class="string">&#x27;0\n&#x27;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">fprintf(<span class="string">&#x27;负数\n&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>栗子2：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = input(<span class="string">&#x27;a = &#x27;</span>);</span><br><span class="line">b = input(<span class="string">&#x27;b = &#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a &gt; b</span><br><span class="line">fprintf(<span class="string">&#x27;%g\n&#x27;</span>, a);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">fprintf(<span class="string">&#x27;%g\n&#x27;</span>, b);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>栗子3：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 1.</span></span><br><span class="line">a = input(<span class="string">&#x27;a = &#x27;</span>);</span><br><span class="line">b = input(<span class="string">&#x27;b = &#x27;</span>);</span><br><span class="line">c = input(<span class="string">&#x27;c = &#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a + b &lt;= c</span><br><span class="line">fprintf(<span class="string">&#x27;NO\n&#x27;</span>);</span><br><span class="line"><span class="keyword">elseif</span> a + c &lt;= b</span><br><span class="line">fprintf(<span class="string">&#x27;NO\n&#x27;</span>);</span><br><span class="line"><span class="keyword">elseif</span> b + c &lt;= a</span><br><span class="line">fprintf(<span class="string">&#x27;NO\n&#x27;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">fprintf(<span class="string">&#x27;YES\n&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% 2.</span></span><br><span class="line"><span class="keyword">if</span> (a + b &gt; c) &amp;&amp; (b + c &gt; a) &amp;&amp; (a + c &gt; b)</span><br><span class="line">fprintf(<span class="string">&#x27;YES\n&#x27;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">fprintf(<span class="string">&#x27;NO\n&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p>栗子1：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> t &lt;= <span class="number">5</span></span><br><span class="line"><span class="built_in">disp</span>(t);</span><br><span class="line">t = t + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>栗子2：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = input(<span class="string">&#x27;a = &#x27;</span>);</span><br><span class="line">b = input(<span class="string">&#x27;b = &#x27;</span>);</span><br><span class="line">r = <span class="built_in">mod</span>(a, b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> r ~= <span class="number">0</span></span><br><span class="line">a = b;</span><br><span class="line">b = r;</span><br><span class="line">r = <span class="built_in">mod</span>(a, b);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">disp</span>(b);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>栗子1：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 输出 1 ～ 5</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="number">5</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="built_in">i</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 输出 5 ～ -5</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">5</span> : <span class="number">-1</span> : <span class="number">-5</span> <span class="comment">% 这的-1表示步长，步长默认为 1，步长可以为小数。</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="built_in">i</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>栗子2：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="number">100</span></span><br><span class="line">s = s + <span class="built_in">i</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">disp</span>(s);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>栗子3：计算</p><p>$\frac{1}{1}+\frac{1}{2}+\frac{1}{3}+…+\frac{1}{100} = ?$</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="number">100</span></span><br><span class="line">s = s + (<span class="number">1</span> / <span class="built_in">i</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">disp</span>(s);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>栗子4：</p><p>$$\frac{1}{1}-\frac{1}{2}+\frac{1}{3}-…-\frac{1}{100} =?$$</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sum = <span class="number">0</span>;</span><br><span class="line">flag = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="number">100</span></span><br><span class="line">sum = sum + (<span class="number">1</span> / <span class="built_in">i</span>)*flag;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>栗子5：for loop和向量</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = v</span><br><span class="line"><span class="built_in">disp</span>(<span class="built_in">i</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h1><h2 id="无返回值"><a href="#无返回值" class="headerlink" title="无返回值"></a>无返回值</h2><p>新建一个function。</p><p>栗子1：计算$1+2+3+…+100 = ?$</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mysum1</span><span class="params">( )</span></span></span><br><span class="line">s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="number">100</span></span><br><span class="line">        s = s + <span class="built_in">i</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>(s);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行：<code>mysum1()</code></p><p>栗子2：计算$1+2+3+…+n = ?$</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mysum2</span><span class="params">( n )</span></span></span><br><span class="line">s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : n</span><br><span class="line">        s = s + <span class="built_in">i</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>(s);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行：<code>mysum2(100)</code></p><p>栗子3：计算$n+(n+1)+(n+2)+…+m = ?$</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mysum3</span><span class="params">( n, m )</span></span></span><br><span class="line">s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = n : m</span><br><span class="line">        s = s + <span class="built_in">i</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>(s);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行：<code>mysum(4, 10)</code></p><blockquote><p>上面这个例子，在command window调用时，我们需要把他的结果保存在一个变量中，如：<code>s1 = mysum(4,10)</code>。就会出错，这个就是没有返回值。</p></blockquote><h2 id="带返回值function"><a href="#带返回值function" class="headerlink" title="带返回值function"></a>带返回值function</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ret</span> = <span class="title">mysum3</span><span class="params">( n, m )</span></span></span><br><span class="line">s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = n : m</span><br><span class="line">        s = s + <span class="built_in">i</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    ret = s;<span class="comment">% return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时：<code>s1 = mysum(4, 10)</code></p><p>这样就完成了一个具有返回值的function。</p><hr>]]></content>
      
      
      <categories>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MASM的使用</title>
      <link href="/2019/03/03/MASM%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/03/03/MASM%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>如何使用 MASM 编写汇编程序。</p><span id="more"></span><p>汇编语言工具包：链接:<a href="https://pan.baidu.com/s/1biXtlVcb1HW9WoiliD6SbQ">https://pan.baidu.com/s/1biXtlVcb1HW9WoiliD6SbQ</a>  密码:86zz</p><p>一下介绍的是使用MASM来翻译和链接汇编程序，还有一款 emu8086 的软件也挺好用，还支持 debug 单步运行。😼</p><h2 id="在32位机上（学校的机子上，Win7-x86）"><a href="#在32位机上（学校的机子上，Win7-x86）" class="headerlink" title="在32位机上（学校的机子上，Win7_x86）"></a>在32位机上（学校的机子上，Win7_x86）</h2><ol><li><p>将工具包中<code>MASM</code>文件夹复制到C盘下</p><p><img src="https://wx3.sinaimg.cn/mw690/006wR0dcly1fy4dcg8n15j31400u01l3.jpg" alt="1"></p></li><li><p>打开<code>cmd</code>，来到这个目录下</p><p><img src="https://wx1.sinaimg.cn/mw690/006wR0dcly1fy4dcb5af0j31400u04qq.jpg" alt="2"></p></li><li><p>创建一个<code>1.asm</code>文件，使用<code>edit</code>工具进行编辑（edit就是个编辑器，还是<code>notepad</code>好用）</p><p><img src="https://wx4.sinaimg.cn/mw690/006wR0dcly1fy4dcfblo2j31400u0b2a.jpg" alt="3"></p></li><li><p>使用<code>edit</code>编辑代码，并保存</p><p><img src="https://wx2.sinaimg.cn/mw690/006wR0dcly1fy4dcfkwj5j31400u04qs.jpg" alt="4"></p></li><li><p><code>masm 1;</code>进行汇编，会生成一个<code>1.obj</code>文件</p><p><img src="https://wx4.sinaimg.cn/mw690/006wR0dcly1fy4dccm188j31400u07wi.jpg" alt="5"></p></li><li><p><code>link 1;</code>链接文件</p><p><img src="https://wx4.sinaimg.cn/mw690/006wR0dcly1fy4dcd87f9j31400u01l0.jpg" alt="6"></p></li><li><p><code>1.exe</code>或者<code>1;</code>运行程序</p><p><img src="https://wx3.sinaimg.cn/mw690/006wR0dcly1fy4dcf7bvrj31400u0b2b.jpg" alt="7.1"></p><p><img src="https://wx1.sinaimg.cn/mw690/006wR0dcly1fy4dchnkh8j31400u01l0.jpg" alt="7.2"></p></li></ol><h2 id="在64位Windows机器上"><a href="#在64位Windows机器上" class="headerlink" title="在64位Windows机器上"></a>在64位Windows机器上</h2><p>要使用一个叫 DOSBox 的工具来模拟32位环境。</p><ol><li><p>安装 DOSBox 一路 next</p></li><li><p>运行 DOSbox</p></li><li><p>绑定 MASM 的路径</p><p><code>mount C C:\MASM</code></p><p><img src="https://wx1.sinaimg.cn/mw690/006wR0dcly1fy4dnaccokj30a306pdgx.jpg" alt="3"></p></li><li><p>切换到挂载的C盘</p><p><img src="https://wx2.sinaimg.cn/mw690/006wR0dcly1fy4dne2bbmj309i06cwff.jpg" alt="4"></p></li><li><p>然后就可以和上面一样咯</p><p><img src="https://wx3.sinaimg.cn/mw690/006wR0dcly1fy4dnhkdj8j309h06d0tj.jpg" alt="5.1"></p><p><img src="https://wx1.sinaimg.cn/mw690/006wR0dcly1fy4dnkr1jyj30a306pwff.jpg" alt="5.2"></p><p><img src="https://wx1.sinaimg.cn/mw690/006wR0dcly1fy4dnnynksj30a706raau.jpg" alt="5.3"></p></li></ol><h2 id="在Mac上汇编"><a href="#在Mac上汇编" class="headerlink" title="在Mac上汇编"></a>在Mac上汇编</h2><p>DOSBox 也有 Mac 版本的。</p><p><a href="https://blog.csdn.net/zach_z/article/details/78171329">MAC上编写汇编程序</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> ASM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ASM </tag>
            
            <tag> 微机原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git-基础命令</title>
      <link href="/2019/02/27/Git-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/02/27/Git-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>Git 一些常用命令。</p><span id="more"></span><h2 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h2><ul><li>获得版本库<ul><li><code>git init</code></li><li><code>git clone</code></li></ul></li><li>版本管理<ul><li><code>git add</code></li><li><code>git commit</code></li><li><code>git rm</code></li></ul></li><li>查看信息<ul><li><code>git help</code></li><li><code>git log</code></li><li><code>git diff</code></li></ul></li><li>远程协作<ul><li><code>git pull</code></li><li><code>git push</code></li></ul></li></ul><hr><p><code>git log</code>查看提交记录</p><p><code>git log -3</code>，查看最近三条的提交记录</p><p><code>git log --pretty=oneline </code>，以单行的形式查看提交记录</p><p><code>git log --pretty=format:&quot;%h - %an,%ar : %s&quot;</code>，以特定格式显示提交记录</p><hr><p>Git的提交id（commit id）是一个摘要值，这个摘要值实际上是用sha1计算出来的。</p><hr><p><code>git checkout -- 文件名/文件夹名</code>，丢弃提交</p><hr><p>对于user.name与user.email来说，有3个地方可以设置</p><ol><li><code>/etc/gitconfig</code>（几乎不会使用，如果使用的是Xcode自带的git的话这个目录是不存在的，需要手动创建），<code>git config --system</code></li><li><code>~/.gitconfig</code>（很常用），<code>git config --global</code></li><li>针对特定项目的，<code>.git/config</code>文件中，<code>git config --local</code></li></ol><p>上面三个设置，优先级由上到下递减，也就是说在3中配置了，会屏蔽掉1，2的配置。</p><p><code>git config --local user.name &#39;张三&#39;</code></p><p><code>git config --local user.email &#39;123@abc.com&#39;</code></p><p>查看文档：<code>git help config</code>  <code>git config --help</code>  <code>man git-config</code> <code>git config</code></p><p><code>git config user.name</code>：查看用户名</p><p><code>git config user.email</code>：查看用户邮箱</p><hr><p>注意：<code>git rm</code>与<code>rm</code></p><p><code>git mv</code>，rename</p><hr><p><code>git add --all</code> &lt;==&gt; <code>git add .</code></p><p>提交描述信息写错了，需要修改，使用<code>git commit --amend -m &quot;修正msg&quot;</code></p><h2 id="gitignore"><a href="#gitignore" class="headerlink" title="#gitignore"></a>#gitignore</h2><p><code>.gitignore</code>文件需要手动创建，将需要忽略的文件名放在这个文件中，支持增则表达式。</p><p>一些栗子：</p><p>要忽略项目目录下的<code>test.xcodeproject</code>文件，将文件名写入即可。</p><p>忽略项目目录下所有的<code>.xcodeproject</code>工程文件，则<code>*.xcodeproject</code>。</p><p><code>!a.xcodeproject</code>，a.xcodeproject这个工程文件不忽略。</p><ul><li><code>*.c</code>#忽略所有以.c为后缀的文件</li><li><code>!lib.c</code>#但是lib.c除外</li><li><code>/TODO</code>#仅仅忽略项目根目录下的TODO文件，不包括subdir/TODO</li><li><code>build/</code>#忽略build目录下的所有文件</li><li><code>doc/*.txt</code>#会忽略doc/notes.txt，但不会忽略doc/server/arch.txt</li><li><code>/*/test.txt</code>，忽略根目录下第一级子目录下的test.txt文件</li><li><code>/**/test.txt</code>，忽略根目录下所有子目录里的test.txt文件</li></ul><h2 id="分支branch"><a href="#分支branch" class="headerlink" title="分支branch"></a>分支branch</h2><p>查看当前分支：<code>git branch</code></p><p>新建分支：<code>git branch new_branch</code></p><p>切换分支：<code>git checkout new_branch</code></p><p>快捷切换回上一次的分支：<code>git checkout -</code>，这个和<code>cd -</code>类似</p><p>删除分支：<code>git branch -d new_branch</code></p><p>​    <strong>删除分支常见错误</strong>：</p><p>​    1. 删除当前正处于的分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: 无法删除检出于 &#x27;/Users/hanoi_ahoj/mtgit&#x27; 的分支 &#x27;new_branch&#x27;。</span><br></pre></td></tr></table></figure><p>​    2. 删除一个没有合并的分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error: 分支 &#x27;new_branch&#x27; 没有完全合并。</span><br><span class="line">如果您确认要删除它，执行 &#x27;git branch -D new_branch&#x27;</span><br></pre></td></tr></table></figure><p>合并分支：<code>git merge new_branch</code></p><h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p>HEAD指向的是当前分支</p><p>（HEAD保存在.git目录下的HEAD文件里，cat HEAD看一看）</p><h3 id="master"><a href="#master" class="headerlink" title="master"></a>master</h3><p>master本质上指向提交</p><ul><li>HEAD指向当前分支</li></ul><p><img src="https://wx2.sinaimg.cn/mw690/006wR0dcly1fy350gkfyhj31c00u0mxd.jpg" alt="1.png"></p><ul><li><p>新建一个分支：dev</p><p><img src="https://wx1.sinaimg.cn/mw690/006wR0dcly1fy350glycpj31c00u00sz.jpg" alt="2.png"></p></li><li><p>在dev分支上进行了一次commit</p><p><img src="https://wx2.sinaimg.cn/mw690/006wR0dcly1fy350gq3cxj31c00u0q38.jpg" alt="3.png"></p></li><li><p>fast-forward(即快进，快速合并，没有冲突)</p><p><img src="https://wx3.sinaimg.cn/mw690/006wR0dcly1fy350gmdrsj31c00u0wes.jpg" alt="4.png"></p></li><li><p>如果两个分支修改的同一个文件的同一行，在合并的时候Git是不知道以master为准还是别的分支为准，这时就会提示冲突，这个时候看这个文件的内容就会发现里面的内容被Git用自己的方式标注出来了冲突的地方，需要自己手动处理冲突。解决完后使用<code>git add file_name</code>来告诉Git这个冲突已经解决了。当在master分支中解决了这一个冲突后，在dev分支中再进行合并master分支，就不会提示冲突了，而是fast-forward。</p></li></ul><h2 id="Mac-Linux下一些小技巧"><a href="#Mac-Linux下一些小技巧" class="headerlink" title="Mac/Linux下一些小技巧"></a>Mac/Linux下一些小技巧</h2><p>优秀的工具：oh my zsh</p><p>拷贝文件<code>cp</code>，移动文件<code>mv</code>（也用来重命名）</p><p>当不想输入当前命令，可以使用<code>ctrl+c</code></p><p><code>rm -rf 文件夹名</code>，递归的删除文件夹</p><p><code>ctrl+l</code>，相当于<code>clear</code>，清屏幕</p><p><code>ctrl+a</code>，跳到当前命令的开头，<code>ctrl+e</code>，跳到当前命令的结尾</p><p><code>l</code>，相当于<code>ls -al</code>，显示当前目录下所有文件，包括隐藏文件</p><p><code>ctrl+f</code>，向下翻页，<code>ctrl+b</code>，向上翻页</p><p><code>mkdir -p test/test1/test2</code>，递归建立多个目录</p><p>快速切换回上次的文件夹：<code>cd -</code></p><p>同时执行多条命令：<code>mkdir mydir &amp;&amp; cd mydir</code></p><p><code>.</code>代表当前目录，<code>..</code>代表上一级目录</p><hr>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-网络编程</title>
      <link href="/2019/02/26/Java-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2019/02/26/Java-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>有人说，20世纪最伟大的发明不是计算机，而是计算机网络。</p><p>还有人说，如果你买了计算机而没有联网，就等于买了电话机而没有接电话线一样。</p><span id="more"></span><h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><p>计算机网络之间以何种规则进行通信，就是网络模型研究问题。</p><p>网络模型一般是指：</p><ul><li><p>OSI（Open System Interconnection开放系统互连）参考模型 </p></li><li><p>TCP/IP参考模型 </p></li></ul><p><img src="https://s2.ax1x.com/2019/02/26/koGO4H.md.jpg" alt="网络模型"></p><p><strong>网络模型7层概述：</strong> </p><ol><li><p><strong>物理层</strong>：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。 </p></li><li><p><strong>数据链路层</strong>：主要将从物理层接收的数据进行MAC地址（网卡的地址）的封装与解封装。常把这一层的数据叫做帧。在这一层工作的设备是交换机，数据通过交换机来传输。 </p></li><li><p><strong>网络层</strong>：主要将从下层接收到的数据进行IP地址（例192.168.0.1)的封装与解封装。在这一层工作的设备是路由器，常把这一层的数据叫做数据包。 </p></li><li><p><strong>传输层</strong>：定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。 </p></li><li><p><strong>会话层</strong>：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名） </p></li><li><p><strong>表示层</strong>：主要是进行对接收的数据进行解释、加密与解密、压缩与解压缩等（也就是把计算机能够识别的东西转换成人能够能识别的东西（如图片、声音等）。 </p></li><li><p><strong>应用层</strong>： 主要是一些终端的应用，比如说FTP（各种文件下载），WEB（IE浏览），QQ之类的（可以把它理解成我们在电脑屏幕上可以看到的东西．就是终端应用）。 </p></li></ol><h3 id="网络编程三要素"><a href="#网络编程三要素" class="headerlink" title="网络编程三要素"></a>网络编程三要素</h3><ol><li><p><strong>IP 地址</strong></p><p>要想让网络中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要接受数据的计算机和识别发送的计算机，在TCP/IP协议中，这个标识号就是IP地址。为了方便对IP地址的获取和操作，java 提供了一个类 InetAddress 供使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">A:所谓IP地址就是给每个连接在Internet上的主机分配的一个32bit地址。按照TCP/IP规定，IP地址用二进制来表示，每个IP地址长32bit，比特换算成字节，就是<span class="number">4</span>个字节。例如一个采用二进制形式的IP地址是“<span class="number">00001010000000000000000000000001</span>”，这么长的地址，人们处理起来也太费劲了。为了方便人们的使用，IP地址经常被写成十进制的形式，中间使用符号“.”分开不同的字节。于是，上面的IP地址可以表示为“<span class="number">10.0</span><span class="number">.0</span><span class="number">.1</span>”。IP地址的这种表示法叫做“点分十进制表示法”，这显然比<span class="number">1</span>和<span class="number">0</span>容易记忆得多。</span><br><span class="line"></span><br><span class="line">B:IP地址的组成</span><br><span class="line">IP地址 = 网络号码+主机地址</span><br><span class="line"></span><br><span class="line">A类IP地址:第一段号码为网络号码，剩下的三段号码为本地计算机的号码</span><br><span class="line">B类IP地址:前二段号码为网络号码，剩下的二段号码为本地计算机的号码</span><br><span class="line">C类IP地址:前三段号码为网络号码，剩下的一段号码为本地计算机的号码</span><br><span class="line"></span><br><span class="line">特殊地址:</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> 回环地址,可用于测试本机的网络是否有问题。 ping <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>   </span><br><span class="line"></span><br><span class="line">xxx.xxx.xxx<span class="number">.0</span> 网络地址</span><br><span class="line">xxx.xxx.xxx<span class="number">.255</span> 广播地址，向此地址发送udp数据包将广播出去，此网段下所有主机都可以收到信息。</span><br><span class="line"></span><br><span class="line">A类<span class="number">1.0</span><span class="number">.0</span><span class="number">.1</span>---<span class="number">127.255</span><span class="number">.255</span><span class="number">.254</span></span><br><span class="line">    (<span class="number">1</span>)<span class="number">10.</span>X.X.X是私有地址(私有地址就是在互联网上不使用，而被用在局域网络中的地址)(<span class="number">2</span>)<span class="number">127.</span>X.X.X是保留地址，用做循环测试用的</span><br><span class="line">B类<span class="number">128.0</span><span class="number">.0</span><span class="number">.1</span>---<span class="number">191.255</span><span class="number">.255</span><span class="number">.254</span><span class="number">172.16</span><span class="number">.0</span><span class="number">.0</span>---<span class="number">172.31</span><span class="number">.255</span><span class="number">.255</span>是私有地址</span><br><span class="line"><span class="number">169.254</span>.X.X是保留地址</span><br><span class="line">C类<span class="number">192.0</span><span class="number">.0</span><span class="number">.1</span>---<span class="number">223.255</span><span class="number">.255</span><span class="number">.254</span></span><br><span class="line">    <span class="number">192.168</span>.X.X是私有地址</span><br><span class="line">D类<span class="number">224.0</span><span class="number">.0</span><span class="number">.1</span>---<span class="number">239.255</span><span class="number">.255</span><span class="number">.254</span></span><br><span class="line">E类<span class="number">240.0</span><span class="number">.0</span><span class="number">.1</span>---<span class="number">247.255</span><span class="number">.255</span><span class="number">.254</span></span><br></pre></td></tr></table></figure></li><li><p><strong>端口号</strong></p><p>物理端口：网卡口。</p><p>逻辑端口：逻辑端口 。</p><p>A:每个网络程序都会至少有一个逻辑端口；</p><p>B:用于标识进程的逻辑地址，不同进程的标识；</p><p>C:有效端口：0<del>65535，其中0</del>1024系统使用或保留端口。 </p></li><li><p><strong>传输协议</strong></p><p><strong>UDP</strong>：将数据源和目的封装成数据包中，不需要建立连接；每个数据报的大小在限制在64k；因无连接，是不可靠协议；不需要建立连接，速度快。</p><p><strong>TCP</strong>：建立连接，形成传输数据的通道；在连接中进行大数据量传输；通过三次握手完成连接，是可靠协议；必须建立连接，效率会稍低。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">udp：面向无连接， 不可靠， 速度快， 将数据封包传输，数据包最大64k。 </span><br><span class="line">举例：聊天留言，在线视频，视频会议，发短信，邮局包裹。 </span><br><span class="line"></span><br><span class="line">tcp：面向连接，安全可靠，效率稍低，通过三次握手确保连接的建立。 </span><br><span class="line">举例：下载，打电话，QQ聊天(你在线吗,在线,就回应下,就开始聊天了)。</span><br></pre></td></tr></table></figure></li></ol><h3 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">获取任意主机：getByName</span><br><span class="line">主机名：getHostName</span><br><span class="line">主机Ip地址：getHostAddress</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InetAddressDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">add</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;8.8.8.8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> add.getHostName();</span><br><span class="line"><span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> add.getHostAddress();</span><br><span class="line"></span><br><span class="line">System.out.println(name + <span class="string">&quot;---&quot;</span> + ip);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h4><p><code>Q</code>：没有构造方法，那么如何使类提供的功能呢？</p><blockquote><p>如果一个类没有构造方法 </p><ol><li><p>成员全部都是静态的（例如：Math、Arrays、Collections）；</p></li><li><p>单例设计模式（例如：Runtime）；</p></li><li><p>类中有静态方法返回该类的对象。</p></li></ol></blockquote><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>Socket套接字：网络上具有唯一标识的IP地址和端口号组合在一起才能构成唯一能识别的标识符套接字。</p><p>Socket原理机制：</p><ul><li><p>通信的两端都有Socket。</p></li><li><p>网络通信其实就是Socket间的通信。</p></li><li><p>数据在两个Socket间通过IO传输。</p></li></ul><p><img src="https://s2.ax1x.com/2019/02/26/koJRqf.png" alt="Socket原理"></p><h2 id="UDP-传输"><a href="#UDP-传输" class="headerlink" title="UDP 传输"></a>UDP 传输</h2><ul><li><p>DatagramSocket与DatagramPacket </p></li><li><p>建立发送端，接收端。 </p></li><li><p>建立数据包。 </p></li><li><p>调用Socket的发送接收方法。 </p></li><li><p>关闭Socket。 </p></li><li><p>发送端与接收端是两个独立的运行程序。 </p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">UDP传输-发送端思路</span><br><span class="line">    <span class="number">1</span>:建立udp的socket服务</span><br><span class="line">    <span class="number">2</span>:将要发送的数据封装成数据包</span><br><span class="line">    <span class="number">3</span>:通过udp的socket服务,将数据包发送出</span><br><span class="line">    <span class="number">4</span>:关闭资源</span><br><span class="line"></span><br><span class="line">UDP传输-接收端思路</span><br><span class="line">    <span class="number">1</span>:建立udp的socket服务.</span><br><span class="line">    <span class="number">2</span>:通过receive方法接收数据</span><br><span class="line">    <span class="number">3</span>:将收到的数据存储到数据包对象中</span><br><span class="line">    <span class="number">4</span>:通过数据包对象的功能来完成对接收到数据进行解析.</span><br><span class="line">    <span class="number">5</span>:可以对资源进行关闭</span><br></pre></td></tr></table></figure><p>举个🌰：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收端 ReceiveDemo.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">10086</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> buf.length;</span><br><span class="line"></span><br><span class="line"><span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buf, length);</span><br><span class="line"></span><br><span class="line">ds.receive(dp);<span class="comment">// 阻塞式方法，没数据就等着。</span></span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] buffer = dp.getData();</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> dp.getLength();</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer,<span class="number">0</span>, len);</span><br><span class="line"></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">address</span> <span class="operator">=</span> dp.getAddress();</span><br><span class="line"><span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> address.getHostAddress();</span><br><span class="line"></span><br><span class="line">System.out.println(ip + <span class="string">&quot; said : &quot;</span> + str);</span><br><span class="line"></span><br><span class="line">ds.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送端 SendDemo.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line"><span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] buf = <span class="string">&quot;hello udp&quot;</span>.getBytes();</span><br><span class="line"><span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> buf.length;</span><br><span class="line"></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">address</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buf, length, address, <span class="number">10086</span>);</span><br><span class="line"></span><br><span class="line">ds.send(dp);</span><br><span class="line">ds.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>UDP 案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line">从键盘录入数据进行发送，如果输入的是<span class="number">886</span>那么客户端就结束输入数据。</span><br><span class="line">这个时候完全可以把发送端代码发给大家了，我把接收端代码开启，大家就可以实现聊天了，但是，大家都要看我们的屏幕，即使我把接收端发给大家也是一样的，如何改进呢，使用广播地址即可。</span><br><span class="line">最后，把刚才发送和接收程序分别用线程进行封装，完成一个UDP的聊天程序。</span><br><span class="line"></span><br><span class="line">这个时候，就需要和io结合起来使用了。还得注意一个问题，这个时候接收端，要一直开启，否则接收一句就关闭了。所以，用死循环，并且，服务不关闭。代码如下：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SendDemo2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"> </span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>((line=br.readLine())!=<span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="string">&quot;886&quot;</span>.equals(line))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">byte</span>[] by = line.getBytes();</span><br><span class="line"><span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(by,by.length,InetAddress.getByName(“<span class="number">192.168</span><span class="number">.1</span><span class="number">.255</span><span class="string">&quot;),10000);</span></span><br><span class="line"><span class="string">ds.send(dp);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">ds.close();</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">class ReceiveDemo2</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">public static void main(String[] args) throws Exception</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">DatagramSocket ds = new DatagramSocket(10000);  //如果10000端口已经被使用了,这个服务起不来</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">//我这边是循序接收的啊.无限循环</span></span><br><span class="line"><span class="string">while(true)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">byte[] by = new byte[1024];</span></span><br><span class="line"><span class="string">DatagramPacket dp = new DatagramPacket(by,by.length);</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ds.receive(dp);</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">//通过数据包对象的方法获取其中的数据内容,包括地址,端口,数据主体</span></span><br><span class="line"><span class="string">String ip = dp.getAddress().getHostAddress();</span></span><br><span class="line"><span class="string">int port = dp.getPort();</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">byte[] by2 = dp.getData();</span></span><br><span class="line"><span class="string">String text = new String(by2,0,dp.getLength());</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">System.out.println(ip+&quot;</span>...<span class="string">&quot;+port+&quot;</span>...<span class="string">&quot;+text);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">//关闭资源</span></span><br><span class="line"><span class="string">//ds.close();</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">用线程封装后的代码如下：</span></span><br><span class="line"><span class="string">public class SendThread implements Runnable &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">private DatagramSocket ds;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">public SendThread(DatagramSocket ds) &#123;</span></span><br><span class="line"><span class="string">this.ds = ds;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@Override</span></span><br><span class="line"><span class="string">public void run() &#123;</span></span><br><span class="line"><span class="string">// 创建UDP发送端的服务</span></span><br><span class="line"><span class="string">try &#123;</span></span><br><span class="line"><span class="string">// 把键盘录入数据用高效缓冲流封装</span></span><br><span class="line"><span class="string">BufferedReader br = new BufferedReader(new InputStreamReader(</span></span><br><span class="line"><span class="string">System.in));</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">String line = null;</span></span><br><span class="line"><span class="string">while ((line = br.readLine()) != null) &#123;</span></span><br><span class="line"><span class="string">if (&quot;</span><span class="number">886</span><span class="string">&quot;.equals(line)) &#123;</span></span><br><span class="line"><span class="string">break;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">byte[] bys = line.getBytes();</span></span><br><span class="line"><span class="string">// 数据包</span></span><br><span class="line"><span class="string">DatagramPacket dp = new DatagramPacket(bys, bys.length,</span></span><br><span class="line"><span class="string">InetAddress.getByName(&quot;</span><span class="number">192.168</span><span class="number">.1</span><span class="number">.255</span><span class="string">&quot;), 12345);</span></span><br><span class="line"><span class="string">// 发送数据</span></span><br><span class="line"><span class="string">ds.send(dp);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 关闭资源</span></span><br><span class="line"><span class="string">ds.close();</span></span><br><span class="line"><span class="string">&#125; catch (IOException e) &#123;</span></span><br><span class="line"><span class="string">e.printStackTrace();</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">public class ReceiveThread implements Runnable &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">private DatagramSocket ds;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">public ReceiveThread(DatagramSocket ds) &#123;</span></span><br><span class="line"><span class="string">this.ds = ds;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@Override</span></span><br><span class="line"><span class="string">public void run() &#123;</span></span><br><span class="line"><span class="string">try &#123;</span></span><br><span class="line"><span class="string">// 为了循环多次接受</span></span><br><span class="line"><span class="string">while (true) &#123;</span></span><br><span class="line"><span class="string">// 创建字节数组作为数据包的缓冲区</span></span><br><span class="line"><span class="string">byte[] bys = new byte[1024];</span></span><br><span class="line"><span class="string">DatagramPacket dp = new DatagramPacket(bys, bys.length);</span></span><br><span class="line"><span class="string">// 读取数据包数据</span></span><br><span class="line"><span class="string">ds.receive(dp);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 解析数据包</span></span><br><span class="line"><span class="string">String ip = dp.getAddress().getHostAddress();</span></span><br><span class="line"><span class="string">int port = dp.getPort();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">String text = new String(dp.getData(), 0, dp.getLength());</span></span><br><span class="line"><span class="string">System.out.println(ip + &quot;</span>***<span class="string">&quot; + port + &quot;</span>***<span class="string">&quot; + text);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125; catch (IOException e) &#123;</span></span><br><span class="line"><span class="string">e.printStackTrace();</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">public class ChatDemo &#123;</span></span><br><span class="line"><span class="string">public static void main(String[] args) throws IOException &#123;</span></span><br><span class="line"><span class="string">DatagramSocket sds = new DatagramSocket();</span></span><br><span class="line"><span class="string">DatagramSocket rds = new DatagramSocket(12345);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">SendThread st = new SendThread(sds);</span></span><br><span class="line"><span class="string">ReceiveThread rt = new ReceiveThread(rds);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Thread t1 = new Thread(st);</span></span><br><span class="line"><span class="string">Thread t2 = new Thread(rt);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">t1.start();</span></span><br><span class="line"><span class="string">t2.start();</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="TCP-传输"><a href="#TCP-传输" class="headerlink" title="TCP 传输"></a>TCP 传输</h2><ul><li><p>Socket和ServerSocket</p></li><li><p>建立客户端和服务器端</p></li><li><p>建立连接后，通过Socket中的IO流进行数据的传输</p></li><li><p>关闭socket</p></li><li><p>同样，客户端与服务器端是两个独立的应用程序。</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">客户端思路</span><br><span class="line">    1:建立客户端的Socket服务,并明确要连接的服务器。</span><br><span class="line">    2:如果连接建立成功,就表明,已经建立了数据传输的通道.就可以在该通道通过IO进行数据的读取和写入.该通道称为Socket流,Socket流中既有读取流,也有写入流.</span><br><span class="line">    3:通过Socket对象的方法,可以获取这两个流</span><br><span class="line">    4:通过流的对象可以对数据进行传输</span><br><span class="line">    5:如果传输数据完毕,关闭资源</span><br><span class="line"></span><br><span class="line">服务端思路</span><br><span class="line">    1:建立服务器端的socket服务，需要一个端口</span><br><span class="line">    2:服务端没有直接流的操作,而是通过accept方法获取客户端对象，在通过获取到的客户端对象的流和客户端进行通信</span><br><span class="line">    3:通过客户端的获取流对象的方法,读取数据或者写入数据</span><br><span class="line">    4:如果服务完成,需要关闭客户端,然后关闭服务器，但是,一般会关闭客户端,不会关闭服务器,因为服务端是一直提供服务的</span><br></pre></td></tr></table></figure><p>举个🌰：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向服务器发送数据</span></span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> s.getOutputStream();</span><br><span class="line">os.write(<span class="string">&quot;吼吼吼&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从服务器接收返回的数据</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> s.getInputStream();</span><br><span class="line"><span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> is.read(buf);</span><br><span class="line"><span class="type">String</span> <span class="variable">Client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="number">0</span>, len);</span><br><span class="line">System.out.println(<span class="string">&quot;client : &quot;</span> + Client);</span><br><span class="line"></span><br><span class="line">s.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听 9999 端口，与客户端建立连接</span></span><br><span class="line"><span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> ss.accept();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> s.getInputStream();</span><br><span class="line"><span class="type">byte</span>[] str = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> is.read(str);</span><br><span class="line"><span class="type">String</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(str, <span class="number">0</span>, len);</span><br><span class="line">System.out.println(<span class="string">&quot;server : &quot;</span> + server);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向客户端返回一个数据</span></span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> s.getOutputStream();</span><br><span class="line">os.write(<span class="string">&quot;数据已收到&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭连接</span></span><br><span class="line">s.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TCP传输容易出现的问题"><a href="#TCP传输容易出现的问题" class="headerlink" title="TCP传输容易出现的问题"></a>TCP传输容易出现的问题</h3><p>客户端连接上服务端，两端都在等待，没有任何数据传输。</p><p>通过例程分析：因为read方法或者readLine方法是阻塞式。</p><p>解决办法：自定义结束标记，使用shutdownInput，shutdownOutput方法。</p><hr>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-多线程</title>
      <link href="/2019/02/26/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2019/02/26/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="多线程概述"><a href="#多线程概述" class="headerlink" title="多线程概述"></a>多线程概述</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>正在运行的程序，是系统进行资源分配和调用的独立单位。 </p><p>每一个进程都有它自己的内存空间和系统资源。 </p><h4 id="多进程的意义"><a href="#多进程的意义" class="headerlink" title="多进程的意义"></a>多进程的意义</h4><p>单进程计算机只能做一件事情。而现在的计算机都可以一边玩游戏(游戏进程),一边听音乐(音乐进程)，所以常见的操作系统都是多进程操作系统。比如：Windows，Mac和Linux等，能在同一个时间段内执行多个任务。</p><p>对于单核计算机来讲，游戏进程和音乐进程是同时运行的吗?不是。</p><p>因为CPU在某个时间点上只能做一件事情，计算机是在游戏进程和音乐进程间做着频繁切换，且切换速度很快，所以，我们感觉游戏和音乐在同时进行，其实并不是同时执行的。</p><p>多进程的作用不是提高执行速度，而是提高CPU的使用率。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>是进程中的单个顺序控制流，是一条执行路径。</p><p>一个进程如果只有一条执行路径，则称为单线程程序。 </p><p>一个进程如果有多条执行路径，则称为多线程程序。 </p><h4 id="多线程的意义"><a href="#多线程的意义" class="headerlink" title="多线程的意义"></a>多线程的意义</h4><p>多线程的作用不是提高执行速度，而是为了提高应用程序的使用率。</p><p>而多线程却给了我们一个错觉：让我们认为多个线程是并发执行的。其实不是。</p><p>因为多个线程共享同一个进程的资源(堆内存和方法区)，但是栈内存是独立的，一个线程一个栈。所以他们仍然是在抢CPU的资源执行。一个时间点上只有能有一个线程执行。而且谁抢到，这个不一定，所以，造成了线程运行的随机性。</p><h3 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h3><p>并行：前者是逻辑上同时发生，指在某一个时间内同时运行多个程序。</p><p>并发：后者是物理上同时发生，指在某一个时间点同时运行多个程序。</p><p>那么，我们能不能实现真正意义上的并发呢，是可以的，多个CPU就可以实现，不过得知道如何调度和控制它们。</p><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h3><p><code>Q</code>：Java 程序的运行原理及 JVM 的启动是多线程的吗?</p><blockquote><p>Java 命令去启动 JVM，JVM会启动一个进程，该进程会启动一个主线程。<br>JVM 的启动是多线程的，因为它最低有两个线程启动了，主线程和垃圾回收线程。</p></blockquote><h2 id="多线程实现"><a href="#多线程实现" class="headerlink" title="多线程实现"></a>多线程实现</h2><h3 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h3><ul><li>自定义类 MyThread 继承 Thread 类；</li><li>MyThread 类里面重写 run()；</li><li>创建对象；</li><li>启动线程。</li></ul><h4 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h4><ul><li><p>MyThread.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">System.out.println(getName() + <span class="string">&quot;---&quot;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>MyThreadTest.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadTest</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">MyThread</span> <span class="variable">my1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line"><span class="type">MyThread</span> <span class="variable">my2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line"></span><br><span class="line">my1.setName(<span class="string">&quot;ahoj&quot;</span>);</span><br><span class="line">my2.setName(<span class="string">&quot;baozi&quot;</span>);</span><br><span class="line"></span><br><span class="line">my1.start();</span><br><span class="line">my2.start();</span><br><span class="line"></span><br><span class="line">System.out.println(Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Q-amp-A-1"><a href="#Q-amp-A-1" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h4><p><code>Q1</code>：为什么是 run() 方法呢？</p><blockquote><p>不是类中的所有代码都需要被线程执行的。这个时候，为了区分哪些代码能够被线程执行，java提供了Thread类中的run()用来包含那些被线程执行的代码。</p></blockquote><p><code>Q2</code>：线程能不能多次启动(start)？</p><blockquote><p><strong>不可以</strong><br>通过Thread实例的start()，一个Thread的实例只能产生一个线程。一个Thread的实例一旦调用start()方法，这个实例的started标记就标记为true，事实中不管这个线程后来有没有执行到底，只要调用了一次start()就再也没有机会运行了。<br>一个线程对象只能调用一次start方法.从new到等待运行是单行道,所以如果你对一个已经启动的线程对象再调用一次start方法的话,会产生:IllegalThreadStateException异常. 可以被重复调用的是run()方法。</p></blockquote><p><code>Q3</code>：run()和start()方法的区别</p><blockquote><p>run()方法: 在本线程内调用该Runnable对象的run()方法，可以重复多次调用；<br>start()方法: 启动一个线程，调用该Runnable对象的run()方法，不能多次启动一个线程</p></blockquote><h4 id="Thread-类的方法"><a href="#Thread-类的方法" class="headerlink" title="Thread 类的方法"></a>Thread 类的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>;<span class="comment">// 设置线程名称也可以通过构造的方式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Thread <span class="title function_">currentThread</span><span class="params">()</span>;<span class="comment">// 返回当前正在执行的线程对象</span></span><br></pre></td></tr></table></figure><h3 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h3><p>步骤：</p><ul><li>自定义类MyRunnable实现Runnable接口；</li><li>重写run()方法；</li><li>创建MyRunnable类的对象；</li><li>创建Thread类的对象，并把C步骤的对象作为构造参数传递；</li><li>启动线程。</li></ul><h4 id="CODE，卖电影票案例"><a href="#CODE，卖电影票案例" class="headerlink" title="CODE，卖电影票案例"></a>CODE，卖电影票案例</h4><ul><li><p>SellTickets.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTickets</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>; </span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);<span class="comment">// 模拟现实中延迟的情况，延迟0.1秒</span></span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在出售第 &quot;</span> + (tickets--) + <span class="string">&quot; 张票&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>SellTicketsDemo.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicketsDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">SellTickets</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTickets</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(st, <span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(st, <span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(st, <span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="继承接口的好处"><a href="#继承接口的好处" class="headerlink" title="继承接口的好处"></a>继承接口的好处</h4><p>可以避免由于Java单继承带来的局限性。<br>适合多个相同程序的代码去处理同一个资源的情况，把线程同程序的代码，数据有效分离，较好的体现了面向对象的设计思想。</p><h2 id="线程调度和优先级"><a href="#线程调度和优先级" class="headerlink" title="线程调度和优先级"></a>线程调度和优先级</h2><p>计算机只有一个 CPU，那么 CPU 在某一个时刻只能执行一条指令，线程只有得到 CPU时间片，也就是使用权，才可以执行指令。那么Java是如何对线程进行调用的呢？</p><h3 id="线程调度模型"><a href="#线程调度模型" class="headerlink" title="线程调度模型"></a>线程调度模型</h3><ul><li><p>分时调度模型</p><p>所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片。</p></li><li><p>抢占式调度模型</p><p>优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些。 </p></li></ul><p>Java使用的是抢占式调度模型。</p><h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>默认优先级：5 </p><p>优先级范围：1（低） ~ 10（高） </p><p>线程优先级仅代表几率，在多次运行的时候才能看到比较好的效果，1、2次说明不了什么问题。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getPriority</span><span class="params">()</span>;<span class="comment">// 获取优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setPriority</span><span class="params">(<span class="type">int</span> newPriority)</span>; <span class="comment">// 设置优先级</span></span><br></pre></td></tr></table></figure><h2 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">线程休眠</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis)</span></span><br><span class="line"></span><br><span class="line">线程加入</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span>：等待该线程终止，为了让某些线程执行完毕别人才可以执行。</span><br><span class="line"></span><br><span class="line">线程礼让</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">yield</span><span class="params">()</span>：暂停正在执行的线程对象，并执行其他线程代码。在一定程度上礼让，但不能保证就是你执行一次我执行一次。</span><br><span class="line"></span><br><span class="line">后台线程</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setDaemon</span><span class="params">(<span class="type">boolean</span> on)</span>：将线程标记为守护线程或用户线程。</span><br><span class="line">当正在运行的线程都是守护线程时，Java虚拟机退出，该方法必须在启动线程前调用。</span><br><span class="line">举例：坦克大战中的坦克就是守护老巢的守护线程，当老巢报废后，结束！</span><br><span class="line"></span><br><span class="line">中断线程</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>：过于暴力，直接停止线程，后面的代码也不会执行。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span>：把线程的状态终止，并抛出一个异常，后面的代码还会继续执行完。</span><br></pre></td></tr></table></figure><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p>新建、就绪、运行、阻塞、死亡。</p><p><img src="https://wx2.sinaimg.cn/mw690/006wR0dcly1g0itc1css9j30s60eqdj9.jpg" alt="线程生命周期"></p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>线程安全问题在理想状态下，不容易出现，但一旦出现对软件的影响是非常大的。</p><h3 id="卖电影票案例出现的问题"><a href="#卖电影票案例出现的问题" class="headerlink" title="卖电影票案例出现的问题"></a>卖电影票案例出现的问题</h3><p>为了更符合真实的场景，加入了休眠100毫秒。<a href="#CODE%EF%BC%8C%E5%8D%96%E7%94%B5%E5%BD%B1%E7%A5%A8%E6%A1%88%E4%BE%8B">卖电影票案例</a></p><p>问题1：相同的票出现多次</p><p>CPU的一次操作必须是原子性的，例如 ticket– 就不是原子性的操作。</p><p>问题2：还出现了负数的票</p><p>随机性和延迟导致的</p><h3 id="多线程安全问题的原因"><a href="#多线程安全问题的原因" class="headerlink" title="多线程安全问题的原因"></a>多线程安全问题的原因</h3><ol><li>是否有多线程环境</li><li>是否有共享数据</li><li>是否有多条语句操作共享数据</li></ol><h3 id="解决多线程安全问题"><a href="#解决多线程安全问题" class="headerlink" title="解决多线程安全问题"></a>解决多线程安全问题</h3><p>基本思想：让程序没有安全问题的环境。</p><p>把多个语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可。</p><h4 id="解决方案-1-同步代码块"><a href="#解决方案-1-同步代码块" class="headerlink" title="解决方案 1 同步代码块"></a>解决方案 1 同步代码块</h4><p>同步代码块，格式如下，这里的 对象 可以是任意的对象，相当于一把钥匙，这个钥匙只能有一把。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象)&#123;</span><br><span class="line">    需要同步的代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个🌰：​​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTickets</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line"><span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在出售第 &quot;</span> + (tickets--) + <span class="string">&quot; 张票&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解决方案-2-同步方法"><a href="#解决方案-2-同步方法" class="headerlink" title="解决方案 2 同步方法"></a>解决方案 2 同步方法</h4><p>把同步加在方法上，这里的锁对象是this。</p><p>举个🌰：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTickets</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">sellTickets();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sellTickets</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在出售第 &quot;</span> + (tickets--) + <span class="string">&quot; 张票&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解决方案-3-静态同步方法"><a href="#解决方案-3-静态同步方法" class="headerlink" title="解决方案 3 静态同步方法"></a>解决方案 3 静态同步方法</h4><p>把同步加在方法上，这里的锁对象是当前类的字节码文件对象。</p><p>举个🌰：此时锁对象是当前类的字节码文件对象 SellTickets.class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTickets</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">sellTickets();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sellTickets</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在出售第 &quot;</span> + (tickets--) + <span class="string">&quot; 张票&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JDK5-中-Lock-锁的使用"><a href="#JDK5-中-Lock-锁的使用" class="headerlink" title="JDK5 中 Lock 锁的使用"></a>JDK5 中 Lock 锁的使用</h3><p>虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了锁，为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lock 接口</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// ReentrantLock 是Lock的实现类</span></span><br></pre></td></tr></table></figure><p>举个🌰：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTickets</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义锁对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">lock.lock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在出售 &quot;</span> + (tickets--) + <span class="string">&quot; 张票&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                </span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程同步的特点"><a href="#线程同步的特点" class="headerlink" title="线程同步的特点"></a>线程同步的特点</h3><p>同步的前提：多个线程、多个线程使用的是同一个锁对象 </p><p>同步的好处：同步的出现解决了多线程的安全问题。</p><p>同步的弊端：当线程相当多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率。</p><p>这就是线程同步，效率低。不同步效率高的解释。</p><h3 id="Q-amp-A-2"><a href="#Q-amp-A-2" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h3><p><code>Q1</code>：在集合中有一些是线程不安全的集合，当需要使用多线程的时候怎么办？</p><blockquote><p>用Collections工具类的方法把一个线程不安全的集合类变成一个线程安全的集合类。例如：<code>List&lt;String&gt; list1 = Collections.synchronizedList(new ArrayList&lt;String&gt;());</code></p></blockquote><p><code>Q2</code>：那么，到底使用谁？</p><blockquote><p>如果锁对象是this，就可以考虑使用同步方法。 否则能使用同步代码块的尽量使用同步代码块。 </p></blockquote><h2 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h2><p>同步弊端 </p><ul><li>效率低 </li><li>如果出现了同步嵌套，就容易产生死锁问题 </li></ul><p>死锁问题及其代码 </p><ul><li>是指两个或者两个以上的线程在执行的过程中，因争夺资源产生的一种互相等待现象 </li></ul><p>举个🌰：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyLock.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLock</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">objA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">objB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DieLock.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DieLock</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> flag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">DieLock</span><span class="params">(<span class="type">boolean</span> flag)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.flag = flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (MyLock.objA) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;if objA&quot;</span>);</span><br><span class="line"><span class="keyword">synchronized</span> (MyLock.objB) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;if objB&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (MyLock.objB) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;else objB&quot;</span>);</span><br><span class="line"><span class="keyword">synchronized</span> (MyLock.objA) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;else objA&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DieLockDemo.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DieLockDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">DieLock</span> <span class="variable">dl1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DieLock</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="type">DieLock</span> <span class="variable">dl2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DieLock</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">dl1.start();</span><br><span class="line">dl2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/02/26/koVLSe.jpg" alt="死锁"></p><h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><p>针对同一个资源的操作有不同种类的线程。</p><p>举例：卖票有进的，也有出的。</p><p>通过设置线程(生产者)和获取线程(消费者)针对同一个学生对象进行操作。</p><p><img src="https://s2.ax1x.com/2019/02/26/koZklQ.jpg" alt="生产者、消费者"></p><h3 id="等待唤醒机制"><a href="#等待唤醒机制" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h3><p>Object 类中提供了三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wait():等待唤醒，立即释放锁，将来醒过来的时候是从此处醒来。 </span><br><span class="line">notify():唤醒，唤醒并不代表可以立马执行，还必须抢CPU执行权 </span><br><span class="line">notifyAll():唤醒所有线程 </span><br></pre></td></tr></table></figure><p>这些方法的调用，必须通过锁对象来调用。</p><p><img src="https://s2.ax1x.com/2019/02/26/koezPf.png" alt="进程间通信，等待唤醒机制"></p><p>举个🌰：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetThread.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">GetThread</span><span class="params">(Student s)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.s = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (s) &#123;</span><br><span class="line">s.get();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SetThread.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SetThread</span><span class="params">(Student s)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.s = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (s) &#123;</span><br><span class="line"><span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">s.set(<span class="string">&quot;xiaohei&quot;</span>, <span class="number">21</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">s.set(<span class="string">&quot;baozi&quot;</span>, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line">x++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Student.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> flag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.flag) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.wait();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"><span class="built_in">this</span>.age = age;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.flag = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">this</span>.notify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">this</span>.flag) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.wait();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot;---&quot;</span> + <span class="built_in">this</span>.age);</span><br><span class="line"><span class="built_in">this</span>.flag = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">this</span>.notify();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StudentDemo.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">GetThread</span> <span class="variable">gt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetThread</span>(s);</span><br><span class="line"><span class="type">SetThread</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SetThread</span>(s);</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(gt);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(st);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Q-amp-A-3"><a href="#Q-amp-A-3" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h3><p><code>Q</code>：wait()、notify()、notifyAll()，用来操作线程为什么定义在了Object类中？</p><blockquote><p>这些方法存在与同步中。</p><p>使用这些方法时必须要标识所属的同步的锁。</p><p>锁可以是任意对象，所以任意对象调用的方法一定定义Object类中。</p></blockquote><h2 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h2><p>Java中使用ThreadGroup来表示线程组。</p><p>它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控制。 </p><p>默认情况下，所有的线程都属于主线程组。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ThreadGroup <span class="title function_">getThreadGroup</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>也可以给线程设置分组 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread(ThreadGroup group, Runnable target, String name);</span><br></pre></td></tr></table></figure><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>程序启动一个新线程成本是比较高的，因为它涉及到要与操作系统进行交互。而使用线程池可以很好的提高性能，尤其是当程序中要创建大量生存期很短的线程时，更应该考虑使用线程池。</p><p>线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。</p><p>在JDK5之前，我们必须手动实现自己的线程池，从JDK5开始，Java内置支持线程池。</p><p>JDK5新增了一个Executors工厂类来产生线程池，有如下几个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span>;</span><br><span class="line">创建一个具有缓存功能的线程池 </span><br><span class="line">缓存：百度浏览过的信息再次访问 </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span>;</span><br><span class="line">创建一个可重用的，具有固定线程数的线程池</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span>;</span><br><span class="line">创建一个只有单线程的线程池，相当于上个方法的参数是<span class="number">1</span></span><br></pre></td></tr></table></figure><p>这些方法的返回值是ExecutorService对象，该对象表示一个线程池，可以执行Runnable对象或者Callable对象代表的线程。它提供了如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br></pre></td></tr></table></figure><p>线程池的好处：线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExecutorsDemo.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorsDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);<span class="comment">// 创建Runnable实例</span></span><br><span class="line"></span><br><span class="line">pool.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());<span class="comment">// 提交Runnable实例</span></span><br><span class="line">pool.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());<span class="comment">// 提交Runnable实例</span></span><br><span class="line"></span><br><span class="line">pool.shutdown();<span class="comment">// 关闭线程池</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyRunnable.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名内部类方式使用多线程"><a href="#匿名内部类方式使用多线程" class="headerlink" title="匿名内部类方式使用多线程"></a>匿名内部类方式使用多线程</h2><p>匿名内部类方式使用多线程 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">    代码…</span><br><span class="line">&#125;.start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    代码…</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; <span class="number">100</span>; x++) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;---&quot;</span> + x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;.start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; <span class="number">100</span>; x++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&quot;</span> + x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>定时器是一个应用十分广泛的线程工具，可用于调度多个定时任务以后台线程的方式执行。在Java中，可以通过Timer和TimerTask类来实现定义调度的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Timer</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Timer</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">schedule</span><span class="params">(TimerTask task, <span class="type">long</span> delay)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">schedule</span><span class="params">(TimerTask task,<span class="type">long</span> delay,<span class="type">long</span> period)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TimerTask</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p>开发中，Quartz是一个完全由java编写的开源调度框架。 </p><hr>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-IO</title>
      <link href="/2019/02/24/Java-IO/"/>
      <url>/2019/02/24/Java-IO/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="File"><a href="#File" class="headerlink" title="File"></a>File</h2><h3 id="概述和构造方法"><a href="#概述和构造方法" class="headerlink" title="概述和构造方法"></a>概述和构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">File类的概述</span><br><span class="line">    文件和目录(路径名)的抽象表示形式</span><br><span class="line">    仅仅是一个路径的表示，不代码具体的事物一定是存在的。</span><br><span class="line">    </span><br><span class="line">构造方法</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">File</span><span class="params">(String pathname)</span>：根据路径得到 File 对象</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">File</span><span class="params">(String parent,String child)</span>：根据一个目录和一个子文件（或目录）得到一个 File 对象</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">File</span><span class="params">(File parent,String child)</span>：根据一个父 File 对象和一个子文件（或目录）得到一个File对象</span><br></pre></td></tr></table></figure><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">创建功能</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">createNewFile</span><span class="params">()</span>：创建文件，存在则不创建</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">mkdir</span><span class="params">()</span>：创建文件夹，存在则不创建，要想在某个目录下创建内容，该目录必须存在。</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">mkdirs</span><span class="params">()</span>：创建多级文件夹，父文件夹不存在就创建，存在则不创建。</span><br><span class="line"></span><br><span class="line">删除功能</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">()</span>：Java 中的删除不走回收站，还要注意，文件夹里面有东西是删除不了的。</span><br><span class="line"></span><br><span class="line">重命名功能</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">renameTo</span><span class="params">(File dest)</span>：注意这个和 mv 命令有些像，前后路径不一样，做移动并改名。</span><br><span class="line"></span><br><span class="line">判断功能</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDirectory</span><span class="params">()</span>：判断是否位文件</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFile</span><span class="params">()</span>：判断是否为文件</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exists</span><span class="params">()</span>：判断是否存在</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canRead</span><span class="params">()</span>：判断是否可读</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canWrite</span><span class="params">()</span>：判断是否可写</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHidden</span><span class="params">()</span>：判断是否隐藏</span><br><span class="line"></span><br><span class="line">基本获取功能</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getAbsolutePath</span><span class="params">()</span>：获取绝对路径</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getPath</span><span class="params">()</span>：获取相对路径</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>：获取名称</span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">length</span><span class="params">()</span>：获取长度，字节数</span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">lastModified</span><span class="params">()</span>：获取最后一次修改时间，返回的是毫秒值。</span><br><span class="line"></span><br><span class="line">高级获取功能</span><br><span class="line"><span class="keyword">public</span> String[] list()</span><br><span class="line"><span class="keyword">public</span> File[] listFiles()</span><br></pre></td></tr></table></figure><h3 id="文件过滤器的使用栗子🌰"><a href="#文件过滤器的使用栗子🌰" class="headerlink" title="文件过滤器的使用栗子🌰"></a>文件过滤器的使用栗子🌰</h3><p>需求：判断E盘目录下是否有后缀名为.jpg的文件，如果有，就输出此文件名称</p><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDemo2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// 封装 e:\\ 目录</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;e:\\&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取该目录下所有文件或者文件夹的 String 数组</span></span><br><span class="line"><span class="comment">// public String[] list(FilenameFilter filter)</span></span><br><span class="line">String[] strArray = file.list(<span class="keyword">new</span> <span class="title class_">FilenameFilter</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File dir, String name)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">File</span>(dir, name).isFile() &amp;&amp; name.endsWith(<span class="string">&quot;.jpg&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历输出</span></span><br><span class="line"><span class="keyword">for</span> (String s : strArray) &#123;</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><h3 id="概述和分类"><a href="#概述和分类" class="headerlink" title="概述和分类"></a>概述和分类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">概述</span><br><span class="line">    IO流用来处理设备之间的数据传输</span><br><span class="line">    上传文件和下载文件</span><br><span class="line">    Java对数据的操作是通过流的方式</span><br><span class="line">    Java用于操作流的对象都在IO包中</span><br><span class="line"></span><br><span class="line">分类(IO流的分类如果没有明确指定，默认指按照数据类型分)</span><br><span class="line">按照数据流向</span><br><span class="line">输入流读入数据</span><br><span class="line">输出流写出数据</span><br><span class="line">按照数据类型</span><br><span class="line">字节流</span><br><span class="line">字节输入流</span><br><span class="line">字节输出流</span><br><span class="line">字符流</span><br><span class="line">字符输入流</span><br><span class="line">字符输出流</span><br></pre></td></tr></table></figure><ul><li><p>什么情况下使用哪种流呢?</p><p>如果数据所在的文件通过 windows 自带的记事本打开并能读懂里面的内容，就用字符流。其他用字节流。</p><p>如果你什么都不知道，就用字节流。</p><p><em><strong>计算机如何识别是中文还是英文呢？</strong></em></p><p>计算机是如何识别什么时候该把两个字节转换为一个中文呢?<br>在计算机中中文的存储分两个字节：</p><ul><li>第一个字节肯定是负数。</li><li>第二个字节常见的是负数，可能有正数。但是没影响。</li></ul><p>看下面的栗子🌰：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">en</span> <span class="operator">=</span> <span class="string">&quot;ANDYOU&quot;</span>;</span><br><span class="line"><span class="type">byte</span>[] en_b = en.getBytes();</span><br><span class="line">System.out.print(<span class="string">&quot;en_b : &quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">byte</span> b : en_b) &#123;</span><br><span class="line">System.out.print(b + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;\n------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">zh</span> <span class="operator">=</span> <span class="string">&quot;爱你&quot;</span>;</span><br><span class="line"><span class="type">byte</span>[] zh_b = zh.getBytes();</span><br><span class="line">System.out.print(<span class="string">&quot;zh_b : &quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">byte</span> b : zh_b) &#123;</span><br><span class="line">System.out.print(b + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">en_b : 65 78 68 89 79 85 </span><br><span class="line">------------</span><br><span class="line">zh_b : -25 -120 -79 -28 -67 -96</span><br></pre></td></tr></table></figure></li></ul><h3 id="常用基类"><a href="#常用基类" class="headerlink" title="常用基类"></a>常用基类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">字节流的抽象基类：</span><br><span class="line">    InputStream ，OutputStream。</span><br><span class="line">字符流的抽象基类：</span><br><span class="line">    Reader ， Writer。</span><br><span class="line">由这四个类派生出来的子类名称都是以其父类名作为子类名的后缀。</span><br><span class="line">如：InputStream的子类FileInputStream。</span><br><span class="line">如：Reader的子类FileReader。</span><br></pre></td></tr></table></figure><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object</span><br><span class="line">|---java.io.InputStream</span><br><span class="line">|---java.io.OutputStream</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InputStream</span>;<span class="comment">//此抽象类是表示字节输入流的所有类的超类。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">OutputStream</span>; <span class="comment">//此抽象类是表示输出字节流的所有类的超类。</span></span><br></pre></td></tr></table></figure><h4 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object</span><br><span class="line">|---java.io.InputStream</span><br><span class="line">    |---java.io.FilterInputStream</span><br><span class="line">    |---java.io.BufferedInputStream</span><br><span class="line">    |---java.io.BufferedOutputStream</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedInputStream</span>; </span><br><span class="line"><span class="comment">// 在读取或跳过流中的字节时，可根据需要从包含的输入流再次填充该内部缓冲区，一次填充多个字节。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedOutputStream</span>;</span><br><span class="line"><span class="comment">// 该类实现缓冲的输出流。通过设置这种输出流，应用程序就可以将各个字节写入底层输出流中，而不必针对每次字节写入调用底层系统。</span></span><br></pre></td></tr></table></figure><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object</span><br><span class="line">|---java.io.Reader</span><br><span class="line">|---java.io.Writer</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Reader</span>; <span class="comment">// 用于读取字符流的抽象类。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Writer</span>; <span class="comment">// 写入字符流的抽象类。</span></span><br></pre></td></tr></table></figure><h4 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object</span><br><span class="line">|---java.io.Reader</span><br><span class="line">|---java.io.BufferedReader</span><br><span class="line">|---java.io.BufferedWriter</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedReader</span>; <span class="comment">// 从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedWriter</span>; <span class="comment">// 将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。</span></span><br><span class="line"></span><br><span class="line">特殊功能,根据系统来读取或写入换行符</span><br><span class="line">    BufferedWriter</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">newLine</span><span class="params">()</span></span><br><span class="line">    BufferedReader</span><br><span class="line">        String <span class="title function_">readLine</span><span class="params">()</span></span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">字符流操作要注意的问题</span><br><span class="line">    flush()的作用</span><br><span class="line">    flush()和close()的区别</span><br><span class="line">        clone()关闭流对象，但是要刷新一下缓冲区，关闭后流对象不可用。</span><br><span class="line">        flush()刷新流对象，刷新完流对象还可以用。</span><br></pre></td></tr></table></figure><h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h3><h4 id="转换流出现的原因及思想"><a href="#转换流出现的原因及思想" class="headerlink" title="转换流出现的原因及思想"></a>转换流出现的原因及思想</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">由于字节流操作中文不是特别方便，所以，java就提供了转换流。</span><br><span class="line">字符流=字节流+编码表。</span><br></pre></td></tr></table></figure><h4 id="编码表概述和常见编码表"><a href="#编码表概述和常见编码表" class="headerlink" title="编码表概述和常见编码表"></a>编码表概述和常见编码表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">编码表</span><br><span class="line">由字符及其对应的数值组成的一张表</span><br><span class="line">常见编码表</span><br><span class="line">    ASCII：美国标准信息交换码。</span><br><span class="line">    用一个字节的<span class="number">7</span>位可以表示。</span><br><span class="line"></span><br><span class="line">    ISO8859-<span class="number">1</span>：拉丁码表。欧洲码表</span><br><span class="line">    用一个字节的<span class="number">8</span>位表示。</span><br><span class="line"></span><br><span class="line">    GB2312：中国的中文编码表，简体中文。</span><br><span class="line"></span><br><span class="line">    GBK：中国的中文编码表升级，融合了更多的中文文字符号。</span><br><span class="line"></span><br><span class="line">    GB18030：GBK的取代版本</span><br><span class="line"></span><br><span class="line">    BIG-<span class="number">5</span>码 ：通行于台湾、香港地区的一个繁体字编码方案，俗称“大五码”。</span><br><span class="line"></span><br><span class="line">    Unicode：国际标准码，融合了多种文字。</span><br><span class="line">    所有文字都用两个字节来表示,Java语言使用的就是unicode</span><br><span class="line"></span><br><span class="line">    UTF-<span class="number">8</span>：最多用三个字节来表示一个字符。</span><br><span class="line"></span><br><span class="line">    UTF-<span class="number">8</span>不同，它定义了一种“区间规则”，这种规则可以和ASCII编码保持最大程度的兼容：</span><br><span class="line">    它将Unicode编码为<span class="number">00000000</span>-<span class="number">0000007F</span>的字符，用单个字节来表示</span><br><span class="line">    它将Unicode编码为00000080-000007FF的字符用两个字节表示 </span><br><span class="line">    它将Unicode编码为00000800-0000FFFF的字符用<span class="number">3</span>字节表示</span><br></pre></td></tr></table></figure><h4 id="转换流概述"><a href="#转换流概述" class="headerlink" title="转换流概述"></a>转换流概述</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OutputStreamWriter 字符输出流</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OutputStreamWriter</span><span class="params">(OutputStream out)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OutputStreamWriter</span><span class="params">(OutputStream out,String charsetName)</span></span><br><span class="line"></span><br><span class="line">InputStreamReader 字符输入流</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InputStreamReader</span><span class="params">(InputStream in)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InputStreamReader</span><span class="params">(InputStream in,String charsetName)</span></span><br></pre></td></tr></table></figure><h4 id="转换流简化"><a href="#转换流简化" class="headerlink" title="转换流简化"></a>转换流简化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">转换流的名字比较长，而我们常见的操作都是按照本地默认编码实现的，所以，为了简化我们的书写，转换流提供了对应的子类。</span><br><span class="line">    FileWriter</span><br><span class="line">    FileReader</span><br></pre></td></tr></table></figure><h3 id="其他流"><a href="#其他流" class="headerlink" title="其他流"></a>其他流</h3><h4 id="数据操作流"><a href="#数据操作流" class="headerlink" title="数据操作流"></a>数据操作流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">操作基本数据类型的类：</span><br><span class="line">    DataInputStream</span><br><span class="line">    DataOutputStream</span><br></pre></td></tr></table></figure><h4 id="内存操作流"><a href="#内存操作流" class="headerlink" title="内存操作流"></a>内存操作流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">内存操作流一般用于处理临时信息，因为临时信息不需要保存，使用后就可以删除。</span><br><span class="line"></span><br><span class="line">操作字节数组</span><br><span class="line">    ByteArrayInputStream</span><br><span class="line">    ByteArrayOutputStream</span><br><span class="line">操作字符数组</span><br><span class="line">    CharArrayReader</span><br><span class="line">    CharArrayWrite</span><br><span class="line">操作字符串</span><br><span class="line">    StringReader</span><br><span class="line">    StringWriter</span><br></pre></td></tr></table></figure><h4 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">打印流概述</span><br><span class="line">字节流打印流 PrintStream</span><br><span class="line">字符打印流 PrintWriter</span><br><span class="line"></span><br><span class="line">打印流特点</span><br><span class="line">    只能操作目的地，不能操作数据。</span><br><span class="line">    可以操作任意类型的数据。</span><br><span class="line">    如果启动了自动刷新，能够自动刷新。</span><br><span class="line">可以操作文件的流</span><br></pre></td></tr></table></figure><h4 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a>标准输入输出流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System类中的字段：in，out。</span><br><span class="line">它们各代表了系统标准的输入和输出设备。</span><br><span class="line">默认输入设备是键盘，输出设备是显示器。</span><br><span class="line">System.in的类型是InputStream.</span><br><span class="line">System.out的类型是PrintStream是OutputStream的子类FilterOutputStream 的子类.</span><br></pre></td></tr></table></figure><h4 id="随机访问流"><a href="#随机访问流" class="headerlink" title="随机访问流"></a>随机访问流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile概述</span><br><span class="line">RandomAccessFile类不属于流，是Object类的子类。但它融合了InputStream和OutputStream的功能。支持对随机访问文件的读取和写入。</span><br><span class="line"></span><br><span class="line">访问模式</span><br><span class="line">    <span class="string">&quot;r&quot;</span> 以只读方式打开。调用结果对象的任何 write 方法都将导致抛出 IOException。  </span><br><span class="line">    <span class="string">&quot;rw&quot;</span> 打开以便读取和写入。如果该文件尚不存在，则尝试创建该文件。  </span><br><span class="line">    <span class="string">&quot;rws&quot;</span> 打开以便读取和写入，对于 <span class="string">&quot;rw&quot;</span>，还要求对文件的内容或元数据的每个更新都同步写入到底层存储设备。  </span><br><span class="line">    <span class="string">&quot;rwd&quot;</span> 打开以便读取和写入，对于 <span class="string">&quot;rw&quot;</span>，还要求对文件内容的每个更新都同步写入到底层存储设备。 </span><br></pre></td></tr></table></figure><h4 id="合并流"><a href="#合并流" class="headerlink" title="合并流"></a>合并流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SequenceInputStream类可以将多个输入流串流在一起，合并为一个输入流，因此，该流也被称为合并流。</span><br><span class="line"></span><br><span class="line">SequenceInputStream的构造方法</span><br><span class="line">    SequenceInputStream(InputStream s1, InputStream s2);</span><br><span class="line">    SequenceInputStream(Enumeration&lt;? <span class="keyword">extends</span> <span class="title class_">InputStream</span>&gt; e);</span><br></pre></td></tr></table></figure><h4 id="序列化流"><a href="#序列化流" class="headerlink" title="序列化流"></a>序列化流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">将对象写入文件，传输。。。</span><br><span class="line">对象序列化是将对象状态转换为可保持或传输的过程。一般的格式是与平台无关的二进制流，可以将这种二进制流持久保存在磁盘上，也可以通过网络将这种二进制流传输到另一个网络结点。</span><br><span class="line">对象反序列化，是指把这种二进制流数据还原成对象。</span><br><span class="line"></span><br><span class="line">序列化流</span><br><span class="line">    ObjectOutputStream</span><br><span class="line"></span><br><span class="line">反序列化流</span><br><span class="line">    ObjectInputStream</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">序列化操作问题</span><br><span class="line">为什么要实现序列化?</span><br><span class="line">如何实现序列化?</span><br><span class="line">序列化数据后，再次修改类文件，读取数据会出问题，如何解决呢?</span><br><span class="line"></span><br><span class="line">使用<span class="keyword">transient</span>关键字声明不需要序列化的成员变量</span><br><span class="line">NotSerializableException:未序列化异常</span><br><span class="line"></span><br><span class="line">类通过实现 java.io.Serializable 接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。</span><br><span class="line">该接口居然没有任何方法，类似于这种没有方法的接口被称为标记接口。</span><br><span class="line"></span><br><span class="line">java.io.InvalidClassException: </span><br><span class="line">cn.itcast_07.Person; local <span class="keyword">class</span> <span class="title class_">incompatible</span>: </span><br><span class="line">stream <span class="type">classdesc</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">2071565876962058344</span>, </span><br><span class="line">local <span class="keyword">class</span> <span class="title class_">serialVersionUID</span> = -<span class="number">8345153069362641443</span></span><br><span class="line"></span><br><span class="line">为什么会有问题呢?</span><br><span class="line">Person类实现了序列化接口，那么它本身也应该有一个标记值。</span><br><span class="line">这个标记值假设是<span class="number">100</span>。</span><br><span class="line">开始的时候：</span><br><span class="line">Person.class -- id=<span class="number">100</span></span><br><span class="line">wirte数据： oos.txt -- id=<span class="number">100</span></span><br><span class="line">read数据: oos.txt -- id=<span class="number">100</span></span><br><span class="line"></span><br><span class="line">现在：</span><br><span class="line">Person.class -- id=<span class="number">200</span></span><br><span class="line">wirte数据： oos.txt -- id=<span class="number">100</span></span><br><span class="line">read数据: oos.txt -- id=<span class="number">100</span></span><br><span class="line">我们在实际开发中，可能还需要使用以前写过的数据，不能重新写入。怎么办呢?</span><br><span class="line">回想一下原因是因为它们的id值不匹配。</span><br><span class="line">每次修改java文件的内容的时候,class文件的id值都会发生改变。</span><br><span class="line">而读取文件的时候，会和class文件中的id值进行匹配。所以，就会出问题。</span><br><span class="line">但是呢，如果我有办法，让这个id值在java文件中是一个固定的值，这样，你修改文件的时候，这个id值还会发生改变吗?</span><br><span class="line">不会。现在的关键是我如何能够知道这个id值如何表示的呢?</span><br><span class="line">不用担心，你不用记住，也没关系，点击鼠标即可。</span><br><span class="line">你难道没有看到黄色警告线吗?</span><br><span class="line"></span><br><span class="line">我们要知道的是：</span><br><span class="line">看到类实现了序列化接口的时候，要想解决黄色警告线问题，就可以自动产生一个序列化id值。</span><br><span class="line">而且产生这个值以后，我们对类进行任何改动，它读取以前的数据是没有问题的。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">我一个类中可能有很多的成员变量，有些我不想进行序列化。请问该怎么办呢?</span><br><span class="line">使用<span class="keyword">transient</span>关键字声明不需要序列化的成员变量</span><br></pre></td></tr></table></figure><h4 id="Properties-集合"><a href="#Properties-集合" class="headerlink" title="Properties 集合"></a>Properties 集合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Properties:属性集合类。是一个可以和IO流相结合使用的集合类。</span><br><span class="line">Properties 可保存在流中或从流中加载。属性列表中每个键及其对应值都是一个字符串。 </span><br><span class="line">是Hashtable的子类，说明是一个Map集合。</span><br><span class="line"></span><br><span class="line">Properties作为Map集合的使用</span><br><span class="line"></span><br><span class="line">Properties的特殊功能</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">setProperty</span><span class="params">(String key,String value)</span>：添加元素</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getProperty</span><span class="params">(String key)</span>：获取元素</span><br><span class="line">    <span class="keyword">public</span> Set&lt;String&gt; <span class="title function_">stringPropertyNames</span><span class="params">()</span>：获取所有键的集合</span><br><span class="line"></span><br><span class="line">Properties和IO流的结合使用</span><br><span class="line">    Properties集合！</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">(Reader reader)</span>：把文件中的数据读取到集合中</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">store</span><span class="params">(Writer writer,String comments)</span>：把集合中的数据存储到文件中</span><br></pre></td></tr></table></figure><h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><p>NIO其实就是新IO的意思。 </p><p>JDK4出现NIO。新IO和传统的IO有相同的目的，都是用于进行输入输出的，但新IO使用了不同的方式来处理输入输出，采用内存映射文件的方式，将文件或者文件的一段区域映射到内存中，就可以像访问内存一样的来访问文件了，这种方式效率比旧IO要高很多，但是目前好多地方我们看到的还是旧IO的引用，所以我们仍以旧IO为主，知道NIO即可。 </p><p>JDK7的IO改进 </p><ul><li><p>Path:与平台无关的路径。 </p></li><li><p>Paths:包含了返回Path的静态方法。 </p><p>public static Path get(URI uri):根据给定的URI来确定文件路径。 </p></li><li><p>Files:操作文件的工具类。提供了大量的方法，简单了解如下方法 </p><p>public static long copy(Path source, OutputStream out) :复制文件 </p><p>public static Path write(Path path, Iterable&lt;? extends CharSequence&gt; lines, Charset cs, OpenOption… options): </p><p>把集合的数据写到文件。 </p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-异常</title>
      <link href="/2019/02/24/Java-%E5%BC%82%E5%B8%B8/"/>
      <url>/2019/02/24/Java-%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<p>拉妹子的手，可能会出错，出错了就道歉，没出错就继续。(哈哈哈)</p><p>异常：异常就是Java程序在运行过程中出现的错误。</p><p>异常由来：问题也是现实生活中一个具体事务，也可以通过 Java 的类的形式进行描述，并封装成对象。其实就是Java 对不正常情况进行描述后的对象体现。</p><span id="more"></span><h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Throwable</span><br><span class="line">|---Error严重问题，我们不处理。</span><br><span class="line">|---Exception</span><br><span class="line">|---RuntimeException运行期异常，我们需要修正代码</span><br><span class="line">|---非RuntimeException 编译期异常，必须处理的，否则程序编译不通过</span><br></pre></td></tr></table></figure><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A:JVM的默认处理</span><br><span class="line">    把异常的名称,原因,位置等信息输出在控制台，但是程序不能继续执行了。</span><br><span class="line">B:自己处理</span><br><span class="line">    a:<span class="keyword">try</span>...<span class="keyword">catch</span>...<span class="keyword">finally</span></span><br><span class="line">        自己编写处理代码,后面的程序可以继续执行</span><br><span class="line">    b:<span class="keyword">throws</span></span><br><span class="line">        把自己处理不了的，在方法上声明，告诉调用者，这里有问题</span><br></pre></td></tr></table></figure><h2 id="一些知识"><a href="#一些知识" class="headerlink" title="一些知识"></a>一些知识</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">A:编译期异常和运行期异常的区别?</span><br><span class="line">    编译期异常 必须要处理的，否则编译不通过</span><br><span class="line">    运行期异常 可以不处理，也可以处理</span><br><span class="line">B:<span class="keyword">throw</span>和<span class="keyword">throws</span>是的区别</span><br><span class="line">    <span class="keyword">throw</span>:</span><br><span class="line">        在方法体中,后面跟的是异常对象名,并且只能是一个</span><br><span class="line">        <span class="keyword">throw</span>抛出的是一个异常对象，说明这里肯定有一个异常产生了</span><br><span class="line">    <span class="keyword">throws</span>:</span><br><span class="line">        在方法声明上,后面跟的是异常的类名,可以是多个</span><br><span class="line">        <span class="keyword">throws</span>是声明方法有异常，是一种可能性，这个异常并不一定会产生</span><br><span class="line">        </span><br><span class="line">C:<span class="keyword">finally</span>关键字及其面试题</span><br><span class="line">    A:<span class="keyword">finally</span>用于释放资源，它的代码永远会执行。特殊情况：在执行到<span class="keyword">finally</span>之前jvm退出了</span><br><span class="line">    B:面试题</span><br><span class="line">        a:<span class="keyword">final</span>,<span class="keyword">finally</span>,finalize的区别?</span><br><span class="line">        b:如果在<span class="keyword">catch</span>里面有<span class="keyword">return</span>,请问<span class="keyword">finally</span>还执行吗?如果执行,在<span class="keyword">return</span>前还是后</span><br><span class="line">            会，前。</span><br><span class="line"></span><br><span class="line">            实际上在中间。这个上课我们讲过</span><br><span class="line">    C:异常处理的变形</span><br><span class="line">        <span class="keyword">try</span>...<span class="keyword">catch</span>...<span class="keyword">finally</span></span><br><span class="line">        <span class="keyword">try</span>...<span class="keyword">catch</span>...</span><br><span class="line">        <span class="keyword">try</span>...<span class="keyword">catch</span>...<span class="keyword">catch</span>...</span><br><span class="line">        <span class="keyword">try</span>...<span class="keyword">catch</span>...<span class="keyword">catch</span>...fianlly</span><br><span class="line">        <span class="keyword">try</span>...<span class="keyword">finally</span></span><br></pre></td></tr></table></figure><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>继承自Exception或者RuntimeException,只需要提供无参构造和一个带参构造即可。</p><h2 id="异常的注意事项"><a href="#异常的注意事项" class="headerlink" title="异常的注意事项"></a>异常的注意事项</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A:父的方法有异常抛出,子的重写方法在抛出异常的时候必须要小于等于父的异常 </span><br><span class="line">B:父的方法没有异常抛出,子的重写方法不能有异常抛出</span><br><span class="line">C:父的方法抛出多个异常,子的重写方法必须比父少或者小</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-集合框架</title>
      <link href="/2019/02/23/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
      <url>/2019/02/23/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="Collection集合"><a href="#Collection集合" class="headerlink" title="Collection集合"></a>Collection集合</h2><h3 id="Collection集合总结"><a href="#Collection集合总结" class="headerlink" title="Collection集合总结"></a>Collection集合总结</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Collection</span><br><span class="line">|---List有序,可重复</span><br><span class="line">    |---ArrayList</span><br><span class="line">        底层数据结构是数组，查询快，增删慢。</span><br><span class="line">        线程不安全，效率高</span><br><span class="line">    |---Vector</span><br><span class="line">        底层数据结构是数组，查询快，增删慢。</span><br><span class="line">        线程安全，效率低</span><br><span class="line">    |---LinkedList</span><br><span class="line">        底层数据结构是链表，查询慢，增删快。</span><br><span class="line">        线程不安全，效率高</span><br><span class="line">|---Set无序,唯一</span><br><span class="line">    |---HashSet</span><br><span class="line">        底层数据结构是哈希表。</span><br><span class="line">        如何保证元素唯一性的呢?</span><br><span class="line">            依赖两个方法：hashCode()和equals()</span><br><span class="line">            开发中自动生成这两个方法即可</span><br><span class="line">        |---LinkedHashSet</span><br><span class="line">            底层数据结构是链表和哈希表</span><br><span class="line">            由链表保证元素有序</span><br><span class="line">            由哈希表保证元素唯一</span><br><span class="line">    |---TreeSet</span><br><span class="line">        底层数据结构是红黑树。</span><br><span class="line">        如何保证元素排序的呢?</span><br><span class="line">            自然排序</span><br><span class="line">            比较器排序</span><br><span class="line">        如何保证元素唯一性的呢?</span><br><span class="line">            根据比较的返回值是否是0来决定</span><br></pre></td></tr></table></figure><h3 id="Collection使用"><a href="#Collection使用" class="headerlink" title="Collection使用"></a>Collection使用</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">针对Collection集合我们到底使用谁呢?(掌握)</span><br><span class="line">唯一吗?</span><br><span class="line">是：Set</span><br><span class="line">排序吗?</span><br><span class="line">是：TreeSet</span><br><span class="line">否：HashSet</span><br><span class="line">如果你知道是Set，但是不知道是哪个Set，就用HashSet。</span><br><span class="line"></span><br><span class="line">否：List</span><br><span class="line">要安全吗?</span><br><span class="line">是：Vector</span><br><span class="line">否：ArrayList或者LinkedList</span><br><span class="line">查询多：ArrayList</span><br><span class="line">增删多：LinkedList</span><br><span class="line">如果知道是List，但是不知道是哪个List，就用ArrayList。</span><br><span class="line"></span><br><span class="line">如果知道是Collection集合，但是不知道使用谁，就用ArrayList。</span><br><span class="line"></span><br><span class="line">如果知道用集合，就用ArrayList。</span><br></pre></td></tr></table></figure><h4 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h4><ol><li>迭代器遍历<ul><li>注意：并发修改异常！</li></ul></li><li>增强for<ul><li>注意：底层其实就是迭代器遍历！</li></ul></li><li>普通for</li></ol><h3 id="集合中常见数据结构"><a href="#集合中常见数据结构" class="headerlink" title="集合中常见数据结构"></a>集合中常见数据结构</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在集合中常见的数据结构(掌握)</span><br><span class="line">ArrayXxx : 底层数据结构是数组，查询快，增删慢</span><br><span class="line">LinkedXxx : 底层数据结构是链表，查询慢，增删快</span><br><span class="line">HashXxx : 底层数据结构是哈希表。依赖两个方法：hashCode()和equals()</span><br><span class="line">TreeXxx : 底层数据结构是二叉树。两种方式排序：自然排序和比较器排序</span><br></pre></td></tr></table></figure><h2 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h2><p>将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。</p><h3 id="Map集合总结"><a href="#Map集合总结" class="headerlink" title="Map集合总结"></a>Map集合总结</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map</span><br><span class="line">|---HashMap</span><br><span class="line">键是哈希表结构，可以保证键的唯一性</span><br><span class="line">|---LinkedHashMap</span><br><span class="line">Map 接口的哈希表和链接列表实现，具有可预知的迭代顺序。</span><br><span class="line">由哈希表保证唯一性</span><br><span class="line">由链表保证有序性（存储和取出的顺序一致）</span><br></pre></td></tr></table></figure><h3 id="Map和Collection的区别"><a href="#Map和Collection的区别" class="headerlink" title="Map和Collection的区别"></a>Map和Collection的区别</h3><p>Map 存储的是键值对形式的元素，键唯一，值可以重复。夫妻对<br>Collection 存储的是单独出现的元素，子接口Set元素唯一，子接口List元素可重复。光棍</p><h3 id="遍历方式-1"><a href="#遍历方式-1" class="headerlink" title="遍历方式"></a>遍历方式</h3><ol><li>键找值<ul><li>获取所有键的集合</li><li>遍历键的集合,得到每一个键</li><li>根据键到集合中去找值</li></ul></li><li>键值对对象找键和值<ul><li>获取所有的键值对对象的集合</li><li>遍历键值对对象的集合，获取每一个键值对对象</li><li>根据键值对对象去获取键和值</li></ul></li></ol><p>栗子🌰：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; hm = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,String&gt;();</span><br><span class="line"></span><br><span class="line">hm.put(<span class="string">&quot;it002&quot;</span>,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">hm.put(<span class="string">&quot;it003&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">hm.put(<span class="string">&quot;it001&quot;</span>,<span class="string">&quot;java&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式1 键找值</span></span><br><span class="line">Set&lt;String&gt; set = hm.keySet();</span><br><span class="line"><span class="keyword">for</span>(String key : set) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> hm.get(key);</span><br><span class="line">    System.out.println(key+<span class="string">&quot;---&quot;</span>+value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2 键值对对象找键和值</span></span><br><span class="line">Set&lt;Map.Entry&lt;String,String&gt;&gt; set2 = hm.entrySet();</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String,String&gt; me : set2) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> me.getKey();</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> me.getValue();</span><br><span class="line">    System.out.println(key+<span class="string">&quot;---&quot;</span>+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)是针对集合进行操作的工具类</span><br><span class="line">(<span class="number">2</span>)面试题：Collection和Collections的区别</span><br><span class="line">    A:Collection 是单列集合的顶层接口，有两个子接口List和Set</span><br><span class="line">    B:Collections 是针对集合进行操作的工具类，可以对集合进行排序和查找等</span><br><span class="line">(<span class="number">3</span>)常见的几个小方法：</span><br><span class="line">    A:<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;T&gt; list)</span></span><br><span class="line">    B:<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(List&lt;?&gt; list,T key)</span></span><br><span class="line">    C:<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">max</span><span class="params">(Collection&lt;?&gt; coll)</span></span><br><span class="line">    D:<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(List&lt;?&gt; list)</span></span><br><span class="line">    E:<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(List&lt;?&gt; list)</span></span><br></pre></td></tr></table></figure><p>注意：在Collection中有一些线程不安全的集合类，当在需要多线程操作的时候，可以使用这个工具类来将线程不安全的集合转为一个线程安全的集合。</p><hr>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-初识正则表达式</title>
      <link href="/2019/02/23/Java-%E5%88%9D%E8%AF%86%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2019/02/23/Java-%E5%88%9D%E8%AF%86%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="正则表达式概述及基本使用"><a href="#正则表达式概述及基本使用" class="headerlink" title="正则表达式概述及基本使用"></a>正则表达式概述及基本使用</h2><p>指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。其实就是一种规则。有自己特殊的应用。</p><h3 id="常见规则"><a href="#常见规则" class="headerlink" title="常见规则"></a>常见规则</h3><p>规则字符在<code>java.util.regex </code>包下的<code>Pattern</code>类中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">A:字符</span><br><span class="line">    x 字符 x。举例：&#x27;a&#x27;表示字符a</span><br><span class="line">    \\ 反斜线字符。</span><br><span class="line">    \n 新行（换行）符 (&#x27;\u000A&#x27;) </span><br><span class="line">    \r 回车符 (&#x27;\u000D&#x27;)</span><br><span class="line"></span><br><span class="line">B:字符类</span><br><span class="line">    [abc] a、b 或 c（简单类） </span><br><span class="line">    [^abc] 任何字符，除了 a、b 或 c（否定） </span><br><span class="line">    [a-zA-Z] a到 z 或 A到 Z，两头的字母包括在内（范围） </span><br><span class="line">    [0-9] 0到9的字符都包括</span><br><span class="line"></span><br><span class="line">C:预定义字符类</span><br><span class="line">    . 任何字符。我的就是.字符本身，怎么表示呢? \.</span><br><span class="line">    \d 数字：[0-9]</span><br><span class="line">    \w 单词字符：[a-zA-Z_0-9]</span><br><span class="line">        在正则表达式里面组成单词的东西必须有这些东西组成</span><br><span class="line"></span><br><span class="line">D:边界匹配器</span><br><span class="line">    ^ 行的开头 </span><br><span class="line">    $ 行的结尾 </span><br><span class="line">    \b 单词边界</span><br><span class="line">        就是不是单词字符的地方。</span><br><span class="line">        举例：hello world?haha;xixi</span><br><span class="line"></span><br><span class="line">E:Greedy 数量词 </span><br><span class="line">    X? X，一次或一次也没有</span><br><span class="line">    X* X，零次或多次</span><br><span class="line">    X+ X，一次或多次</span><br><span class="line">    X&#123;n&#125; X，恰好 n 次 </span><br><span class="line">    X&#123;n,&#125; X，至少 n 次 </span><br><span class="line">    X&#123;n,m&#125; X，至少 n 次，但是不超过 m 次 </span><br></pre></td></tr></table></figure><h3 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">A:判断功能</span><br><span class="line">    String类的public boolean matches(String regex):判断此字符串是否匹配给定的正则表达式</span><br><span class="line">    </span><br><span class="line">B:分割功能</span><br><span class="line">    String类的public String[] split(String regex):根据给定正则表达式的匹配拆分此字符串。</span><br><span class="line">    </span><br><span class="line">C:替换功能</span><br><span class="line">    String类的public String replaceAll(String regex,String replacement):使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。</span><br><span class="line">    </span><br><span class="line">D:获取功能</span><br><span class="line">    Pattern和Matcher</span><br><span class="line">        Pattern p = Pattern.compile(&quot;a*b&quot;);</span><br><span class="line">        Matcher m = p.matcher(&quot;aaaaab&quot;);</span><br><span class="line"></span><br><span class="line">        find():查找存不存在</span><br><span class="line">        group():获取刚才查找过的数据</span><br></pre></td></tr></table></figure><p>获取功能的典型调用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 典型的调用如下</span></span><br><span class="line"><span class="comment">// 模式和匹配器的典型调用顺序</span></span><br><span class="line"><span class="comment">// 把正则表达式编译成模式对象</span></span><br><span class="line"><span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;a*b&quot;</span>);</span><br><span class="line"><span class="comment">// 通过模式对象得到匹配器对象，这个时候需要的是被匹配的字符串</span></span><br><span class="line"><span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(<span class="string">&quot;aaaaab&quot;</span>);</span><br><span class="line"><span class="comment">// 调用匹配器对象的功能</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> m.matches();</span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure><p>举个栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取功能：</span></span><br><span class="line"><span class="comment"> * 获取下面这个字符串中由三个字符组成的单词</span></span><br><span class="line"><span class="comment"> * da jia ting wo shuo,jin tian yao xia yu,bu shang wan zi xi,gao xing bu?</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexDemo2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// 定义字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;da jia ting wo shuo,jin tian yao xia yu,bu shang wan zi xi,gao xing bu?&quot;</span>;</span><br><span class="line"><span class="comment">// 规则</span></span><br><span class="line"><span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;\\b\\w&#123;3&#125;\\b&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把规则编译成模式对象</span></span><br><span class="line"><span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(regex);</span><br><span class="line"><span class="comment">// 通过模式对象得到匹配器对象</span></span><br><span class="line"><span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (m.find()) &#123;</span><br><span class="line">System.out.println(m.group());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C-结构体</title>
      <link href="/2019/02/20/C-%E7%BB%93%E6%9E%84%E4%BD%93/"/>
      <url>/2019/02/20/C-%E7%BB%93%E6%9E%84%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<p>结构体内存对齐的知识总结。</p><span id="more"></span><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="结构体内存对齐"><a href="#结构体内存对齐" class="headerlink" title="结构体内存对齐"></a>结构体内存对齐</h3><h4 id="什么是内存对齐"><a href="#什么是内存对齐" class="headerlink" title="什么是内存对齐"></a>什么是内存对齐</h4><p>现代计算机中内存空间都是按照 byte 划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特 定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。</p><h4 id="为什么要有内存对齐？"><a href="#为什么要有内存对齐？" class="headerlink" title="为什么要有内存对齐？"></a>为什么要有内存对齐？</h4><p>对齐的作用和原因：各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的 CPU 在访问 一个没有进行对齐的变量的时候会发生错误,那么在这种架构下编程必须保证字节对齐.其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台要求对 数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为 32 位系统）如果存放在偶地址开始的地方，那 么一个读周期就可以读出这 32bit ，而如果存放在奇地址开始的地方，就需要 2 个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该 32bit 数 据。显然在读取效率上下降很多。</p><p>总的来说，结构体的内存对齐是拿空间来换取时间。</p><h4 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h4><p>计算结构体的大小是一个特别热门的考点，要计算结构体的大小，首先要知道结构体内存对齐规则。</p><ol><li><p>第一个成员在于结构体变量偏移量为 0 的地址处；</p></li><li><p>其他成员变量要对齐到 <em><strong>对齐数</strong></em> 的整数倍的地址处；</p><p>对齐数 = 编译器默认的一个对齐数 与 该成员大小的较小值。</p><blockquote><p>对齐数在 Windows 中 VS 下默认是 8，Linux 中默认是 4（Centos 7 下默认是8）。</p></blockquote></li><li><p>机构体总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍。</p></li><li><p>如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。</p></li></ol><h4 id="一些栗子"><a href="#一些栗子" class="headerlink" title="一些栗子"></a>一些栗子</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s1</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c1;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> c2;</span><br><span class="line">&#125;;<span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s2</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c1;</span><br><span class="line">    <span class="type">char</span> c2;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;<span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s3</span> &#123;</span></span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;<span class="comment">// 16</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s4</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c1;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s3</span> <span class="title">s</span>;</span></span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">&#125;;<span class="comment">// 32</span></span><br></pre></td></tr></table></figure><h4 id="修改默认对齐数"><a href="#修改默认对齐数" class="headerlink" title="修改默认对齐数"></a>修改默认对齐数</h4><p><code>#pragma pack(n)</code></p><h3 id="结构体传参"><a href="#结构体传参" class="headerlink" title="结构体传参"></a>结构体传参</h3><p>函数传参的时候，参数是需要压栈的。如果传递一个结构体对象的时候，结构体过大，参数压栈的系统开销比较大，性能下降。</p><p>结构体传参的时候，要传结构体的地址进去。</p><h2 id="位段"><a href="#位段" class="headerlink" title="位段"></a>位段</h2><h3 id="什么是位段"><a href="#什么是位段" class="headerlink" title="什么是位段"></a>什么是位段</h3><p>举个栗子，下面的 A 就是一个位段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> _a : <span class="number">2</span>;<span class="comment">// 2 代表这个 _a 占用 2 个比特位，int 占 32 个比特位</span></span><br><span class="line">    <span class="type">int</span> _b : <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> _c : <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> _d : <span class="number">30</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>sizeof(struct A)   -&gt;   8</code></p><h3 id="定义一个位段要注意"><a href="#定义一个位段要注意" class="headerlink" title="定义一个位段要注意"></a>定义一个位段要注意</h3><p>位段的成员必须是 <code>int、unsigned int、signed int、char</code>，位段中所有成员类型必须一致。</p><p>位段的定义和使用特别依赖于平台问题（可移植性差）。</p><h3 id="位段的内存分配"><a href="#位段的内存分配" class="headerlink" title="位段的内存分配"></a>位段的内存分配</h3><ul><li>位段的成员可以是 int、unsigned int、signed int、char；</li><li>位段的空间上是按照需要以 4 个字节（int）或者 1 个字节（char）的方式来开辟的；</li><li>位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段。</li></ul><h3 id="位段的跨平台问题"><a href="#位段的跨平台问题" class="headerlink" title="位段的跨平台问题"></a>位段的跨平台问题</h3><ul><li>int 位段被方程有符号数还是无符号数是不确定的；</li><li>位段中最大位的数目不能确定（16 位机器最大 16，32 位机器最大 32，写成 27，在 16 位机器会出问题）；</li><li>位段中的成员在内存中从左向右分配，还是从右向左分配尚未定义；</li><li>当一个结构包含两个位段，第二个位段成员比较大，无法容纳第一个位段剩余的位时，时舍弃剩余的位还是利用，这是不确定的。</li></ul><h3 id="位段的应用"><a href="#位段的应用" class="headerlink" title="位段的应用"></a>位段的应用</h3><p>定制协议报头。</p><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1549199987764&di=44d99729d3a4ff041fcc15287de8c4f0&imgtype=0&src=http://s16.sinaimg.cn/mw690/006VAGvMzy7dvQMDJVR3f&690" alt="ip"></p><hr>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-基础</title>
      <link href="/2019/02/20/Java-%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/02/20/Java-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="名词释义"><a href="#名词释义" class="headerlink" title="名词释义"></a>名词释义</h2><p><strong>JVM</strong>（<em>Java Virtual Machine，Java虚拟机</em> ）</p><p>因为有了  JVM，所以同一个 Java 程序在三个不同的操作系统中都可以执行。这样就实现了 Java 程序的跨平台性。也称 Java 具有良好的可移植性。 </p><p><strong>JRE</strong>（<em>Java Runtime Environment，Java运行环境</em>  ）</p><p>包括Java虚拟机和 Java 程序所需的核心类库等，如果想要运行一个开发好的 Java 程序，计算机中只需要安装 JRE 即可。 </p><p><strong>JDK</strong>（<em>Java Developme Kit，Java开发工具包</em>  ）</p><p>JDK 是提供给开发人员使用的，其中包含了 Java 的开发工具，也包括了 JRE 。所以安装了JDK，就不用再单独安装 JRE 了。其中的开发工具：编译工具 Javac.exe ，打包工具 Jar.exe 等。 </p><p>简单而言：使用 JDK 开发完成的 Java 程序，交给 JRE 去运行，由 JVM 保证跨平台。 </p><h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><p>在开发中命名我们要尽量做到“见名知意”，这是一个良好的习惯。</p><h4 id="包"><a href="#包" class="headerlink" title="包"></a>包</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">全部小写。</span><br><span class="line">单级包：ahojcn</span><br><span class="line">多级包：cn.ahoj</span><br></pre></td></tr></table></figure><h4 id="类或接口"><a href="#类或接口" class="headerlink" title="类或接口"></a>类或接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一个单词：单词的首字母必须大写（Student、Dog）</span><br><span class="line">多个单词：每个单词的首字母必须大写（HelloWorld、StudentName）</span><br></pre></td></tr></table></figure><h4 id="方法或变量"><a href="#方法或变量" class="headerlink" title="方法或变量"></a>方法或变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一个单词：单词的首字母小写（main、age）</span><br><span class="line">多个单词：从第二个单词开始，每个单词的首字母大写（studentAge、showAllClass()）</span><br></pre></td></tr></table></figure><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一个单词：全部大写</span><br><span class="line">多个单词：每个字母都大写，用_隔开</span><br></pre></td></tr></table></figure><h2 id="数据的表示"><a href="#数据的表示" class="headerlink" title="数据的表示"></a>数据的表示</h2><h3 id="2、8、10、16进制"><a href="#2、8、10、16进制" class="headerlink" title="2、8、10、16进制"></a>2、8、10、16进制</h3><p>二进制：<code>0b</code>开头 </p><p>八进制：<code>0</code>开头 </p><p>十进制：整数默认是十进制的 </p><p>十六进制：<code>0x</code>开头 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">0b1001</span>);<span class="comment">// 2</span></span><br><span class="line">System.out.println(<span class="number">0100</span>); <span class="comment">// 8</span></span><br><span class="line">System.out.println(<span class="number">1001</span>); <span class="comment">// 10</span></span><br><span class="line">System.out.println(<span class="number">0xffff</span>); <span class="comment">// 16</span></span><br></pre></td></tr></table></figure><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Java 是强类型语言，对于每一种数据都定义了明确的具体数据类型，在内存中分配了不同大小的内存空间。</p><p>基本数据类型： </p><ol><li><p>数值型： </p><ul><li><p>整数类型：<code>byte(1),short(2),int(4),long(8，超过了int范围需要加L或l，建议使用L)</code> </p></li><li><p>浮点类型：<code>float(4，单精度浮点数用f或F标记，建议使用F，不加默认是double类型),double(8)</code> </p></li><li><p>字符型：<code>char(2)</code> </p></li><li><p>布尔型：<code>boolean(1)</code> </p></li></ul></li><li><p>引用数据类型： </p><ul><li><p>类：<code>class</code> </p></li><li><p>接口：<code>interface</code> </p></li><li><p>数组：<code>[]</code> </p></li></ul></li></ol><p>***变量使用注意事项： 作用域，初始化值，一行建议只定义一个变量。  ***</p><h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>注意：boolean类型不能转换为其他的数据类型 </p><ol><li><p>默认转换 </p><ul><li><p>byte，short，char =&gt; int =&gt; long =&gt; float =&gt; double </p></li><li><p>byte，short，char 相互之间不转换，他们参与运算首先转换为 int 类型 </p></li></ul></li><li><p>强制转换 </p><ul><li>目标类型 变量名 = (目标类型)(被转换的数据) </li></ul><p>例如：<code>byte c = (byte)(a+b);</code> </p></li></ol><h2 id="一些特别的"><a href="#一些特别的" class="headerlink" title="一些特别的"></a>一些特别的</h2><ol><li><p>跳出多重循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">OUT:    <span class="comment">// 相当于给循环起了个名字</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="keyword">break</span> OUT;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>….</p></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跳表</title>
      <link href="/2019/02/18/%E8%B7%B3%E8%A1%A8/"/>
      <url>/2019/02/18/%E8%B7%B3%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>此文是学习《数据结构与算法之美》时的笔记。</p><span id="more"></span><h2 id="如何理解跳表"><a href="#如何理解跳表" class="headerlink" title="如何理解跳表"></a>如何理解跳表</h2><p><img src="https://static001.geekbang.org/resource/image/e1/6d/e18303fcedc068e5a168de04df956f6d.jpg" alt="单链表"></p><p>对于单链表来讲，即便链表中存储的数据是有序的，要查找某个数据，也只能从头到尾遍历链表。时间复杂度很高，为O(n)。</p><p>跳表，就可以提高查找效率。</p><p><img src="https://static001.geekbang.org/resource/image/14/8e/14753c824a5ee4a976ea799727adc78e.jpg" alt="1级索引跳表"></p><p>如上图，对链表建立一级索引，每两个结点提取一个结点到上一级，down表示down指针，指向下一级结点。</p><p>如果现在要查找值为16的结点，先在索引层遍历，13\le 16 \le17，通过13这个结点的down指针，下降到原始链表着一层，继续遍历，这个时候只需要再遍历2个结点，就可以找到目标。如果直接遍历原始链表，需要遍历10个结点，现在只需要遍历7个。</p><p>加了一层索引之后，查找的效率提高了，那再加一层会不会提升更多？</p><p><img src="https://static001.geekbang.org/resource/image/49/65/492206afe5e2fef9f683c7cff83afa65.jpg" alt="2级索引的跳表"></p><p>在加一层索引后，查找16就只需要遍历6个结点。</p><p>当数据规模大一点的时候，效率就很突出了。</p><p><img src="https://static001.geekbang.org/resource/image/46/a9/46d283cd82c987153b3fe0c76dfba8a9.jpg" alt="pic"></p><p>从上图中，查找62只需要遍历11个结点，所以当脸变长度n比较大时，比如1k、1w的时候，建立索引之后，效率提升就很明显！</p><h2 id="跳表查找复杂度"><a href="#跳表查找复杂度" class="headerlink" title="跳表查找复杂度"></a>跳表查找复杂度</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>在单链表中查找一个数据的时间复杂度为O( n )。</p><p>在跳表中，每2个结点抽出一个结点作为上一级索引的结点，那第一级索引的结点个数(大约)为\frac {2}{n}，第二级索引的结点个数(大约)是\frac n{4}，第三级为\frac {n}{8}，以此类推，第k级索引的结点个数是第k-1级索引的结点个数的\frac {1}{2}，那第k级索引结点的个数就是\frac {n}{2^k}。假设索引有h级，最高级的索引有2个结点。所以有\frac {n}{2^h}=2，解得：h=\log_2n-1。如果包含原始链表着一层，整个跳表的高度就是\log_2n。在跳表中查询某个数据的时候，如果每一层需要遍历<strong>m</strong>个结点，那么跳表中查询一个数据的时间复杂度为O(m\times\log n)。</p><p>按照上面这种索引结构，m=3，也就是说每一级索引都最多只需要遍历3个结点。解释：假设要查找的数据是x，在第k级索引中，遍历到y结点之后，发现x大于y，小于后面的结点z，所以通过down指针，从第k级索引下降到k-1级。在第k-1级索引中，y和z之间只有3个结点(包括y和z)，索引在k-1级索引中最多需要遍历3个基点，依次类推，每一级索引都最多只需要遍历3个结点。</p><p><img src="https://static001.geekbang.org/resource/image/d0/0c/d03bef9a64a0368e6a0d23ace8bd450c.jpg" alt="上"></p><p>所以，在跳表中查询任意数据的时间复杂度为O(\log n)。这个复杂度和二分查找是一样的。</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>跳表通过空间换时间，是不是很浪费内存？</p><p>假设原始链表的大小为n，每两个结点抽一个，第一级索引大约有\frac {n}{2}个结点，第二级索引大约有\frac {n}{4}个结点，以此类推，每上升一级就减少一半，直到剩下两个结点，等比数列。求和得到最终耗费n-2。所以跳表的空间复杂度是O( n)。也就是说，数据规模越大，跳表索引耗费的空间就越大。</p><p><img src="https://static001.geekbang.org/resource/image/10/55/100e9d6e5abeaae542cf7841be3f8255.jpg" alt="空间复杂度1"></p><p>每3个或者5个结点抽取一个作为索引，会不会更省内存？</p><p>每3个结点抽1个，等比数列\frac{n}{3}+\frac{n}{9}+\frac{n}{27}+…+9+3+1=\frac{n}{2}。空间复杂度还是O( n)，但是比每2个结点抽取一个的构建方法减少了一半的索引存储空间。</p><p>实际上，在开发中，要处理的数据不一定是整数，原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，所以当对象比索引结点大很多时，索引占用的额外空间就可以忽略了。</p><h2 id="高效的动态插入和删除"><a href="#高效的动态插入和删除" class="headerlink" title="高效的动态插入和删除"></a>高效的动态插入和删除</h2><p>跳表动态的插入、删除操作的时间复杂度为O(log n)​。</p><p><strong>插入操作</strong></p><p>在链表中，只要找到了插入的位置，插入结点的时间复杂度是O( 1)。主要的时间花费在查找上，查找的时间复杂度是O( \log n)。</p><p><img src="https://static001.geekbang.org/resource/image/65/6c/65379f0651bc3a7cfd13ab8694c4d26c.jpg" alt="insert"></p><p><strong>删除操作</strong></p><p>删除操作中要注意！如果这个结点在索引中也有出现，除了删除原始链表中的，还要删除索引中的。因为单链表中的删除操作需要拿到要删除结点的前驱结点，然后通过指针操作完成。</p><h2 id="跳表索引动态更新"><a href="#跳表索引动态更新" class="headerlink" title="跳表索引动态更新"></a>跳表索引动态更新</h2><p>如果不更新索引，就有可能出现某2个索引结点之间数据非常多的情况，极端情况下退化成单链表。</p><p>一般通过一个随机函数来决定将这个结点插入到哪几级索引中，比如，随机函数生成了K，那么就把这个结点添加到第一级至第K级索引中。</p><p><img src="https://static001.geekbang.org/resource/image/a8/a7/a861445d0b53fc842f38919365b004a7.jpg" alt="rand"></p><p>随机函数的选择很有讲究，从概率上来讲，能够保证跳表的索引大小和数据大小平衡性，不至于性能过度退化。</p><p><a href="https://github.com/wangzheng0822/algo/blob/master/java/17_skiplist/SkipList.java">跳表的一种Java实现</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>跳表使用空间换时间，通过构建多级索引来提高查询效率，实现了基于链表的”二分查找”。</p><p>跳表是一种动态数据结构，支持快速的插入、删除、查找操作，时间复杂度都是O(\log n)​。</p><p>跳表的空间复杂度是O(n)​。不过跳表的实现非常灵活，可以通过改变索引构建策略，有效平衡执行效率和内存消耗。</p><hr><blockquote><p>数据结构与算法之美</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="/2019/02/18/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2019/02/18/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<p>之前在bilibili看到一个有趣的视频，关于二分查找的。<a href="https://www.bilibili.com/video/av15833965">戳我看这个有趣的视频</a></p><p>此文是学习《数据结构与算法之美》时的笔记。</p><span id="more"></span><h2 id="二分思想"><a href="#二分思想" class="headerlink" title="二分思想"></a>二分思想</h2><p>就如上面视频中的栗子，猜数字游戏，如果从头开始一个一个的猜是非常低效的。</p><p>在实际的开发场景中，假设有1w条订单数据，已经按照订单的金额从小到大排序，每个定干的金额不同，最小单位是元。</p><p>如果从第一个订单开始，遍历这1w条订单，直到找到目标为止，这种方法在最坏情况下可能要便利完所有数据才能找到。</p><p>但是用二分法，每次都通过跟区间中间元素对比，将整个带查找的区间缩小为之前的一半，直到查找的需要的数据或者区间缩小为0。</p><h2 id="二分查找实现-递归和非递归"><a href="#二分查找实现-递归和非递归" class="headerlink" title="二分查找实现(递归和非递归)"></a>二分查找实现(递归和非递归)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非递归实现</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bsearch</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">  <span class="type">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> high = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[mid] == value) </span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) </span><br><span class="line">    &#123;</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">      high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="comment">/*while*/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>循环退出条件：<code>low&lt;=high</code></p></li><li><p>mid的取值：<code>mid=(low+high)/2</code>在low和high比较大的话两者之和容易溢出。</p></li></ol><p>改进：<code>low+(high-low)/2</code></p><p>更高效：<code>low+((high-low)&gt;&gt;1)</code></p><ol start="3"><li>low和high的更新</li></ol><p><code>low=mid+1</code>和<code>high=mid-1</code>这里的+1和-1，如果写成<code>low=mid或high=mid</code>就可能发生死循环。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分查找的递归实现</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bsearch</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n, <span class="type">int</span> val)</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> b(a, <span class="number">0</span>, n - <span class="number">1</span>, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">b</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> value)</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (low &gt; high) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> mid =  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (a[mid] == value) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> bsearchInternally(a, mid+<span class="number">1</span>, high, value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> bsearchInternally(a, low, mid<span class="number">-1</span>, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>二分查找的被查找区间缩小速度是一个等比数列，公比q为1/2。</p><p>假设数据规模为n，每次查找后数据规模都会缩小为原来的一半，最坏情况下，直到查找区间被缩小为空停止。</p><p><code>n/2^k=1</code>时，k就是总共缩小的次数，每次缩小只涉及2个数据的比较，经过k次区间缩小操作，时间复杂度为O(k)。k等于以2为底n的对数，解得时间复杂度为<code>O(logn)</code>。</p><p><code>O(logn)</code>在某些情况下比<code>O(1)</code>时间复杂度的算法高效。<code>O(1)</code>时忽略掉常熟、系数和低阶。当数据规模够大时，如<code>O(10000)</code>，此时<code>log(n)</code>的算法效率比<code>O(1)</code>的高。</p><h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><ol><li><p>二分查找依赖顺序结构</p></li><li><p>二分查找针对的是有序数据</p></li><li><p>数据量太小不适合二分查找</p><p>比如在10个元素的数组中查找一个元素，遍历会来的更方便一些。而且查找速度也差不多。</p></li><li><p>数据量太大也不适合二分查找</p><p>为了支持随机访问，内存空间需要连续。</p></li></ol><h2 id="二分查找的变体问题"><a href="#二分查找的变体问题" class="headerlink" title="二分查找的变体问题"></a>二分查找的变体问题</h2><ol><li><p>查找第一个值等于给定值的元素</p><p>当区间中间值不等于要查找的元素时，需要继续查找。</p><p>当区间中间值等于要查找的元素时，看看中间值的前一个值是否等于要查找的元素，如果等则更新high=mid-1，否则现在这个元素就是要查找的元素。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">bsearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> n, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span>  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &gt; value) &#123;</span><br><span class="line">      high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ((mid == <span class="number">0</span>) || (a[mid - <span class="number">1</span>] != value)) <span class="keyword">return</span> mid;</span><br><span class="line">      <span class="keyword">else</span> high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>查找最后一个值等于给定值的元素</p><p>跟第一种一样，不过这次要和mid后面的一个元素进行比较。更新low=mid+1。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">bsearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> n, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span>  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &gt; value) &#123;</span><br><span class="line">      high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ((mid == n - <span class="number">1</span>) || (a[mid + <span class="number">1</span>] != value)) <span class="keyword">return</span> mid;</span><br><span class="line">      <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>查找第一个大于等于给定值的元素</p><p>如果mid的值小于要查找的值，则目标值在[mid+1,high]之间，更新low。</p><p>如果mid的值大于要查找的值，目标值在[low,mid-1]之间，更新high。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public <span class="type">int</span> <span class="title function_">bsearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> n, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">  <span class="type">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="type">int</span> mid =  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &gt;= value) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((mid == <span class="number">0</span>) || (a[mid - <span class="number">1</span>] &lt; value)) <span class="keyword">return</span> mid;</span><br><span class="line">      <span class="keyword">else</span> high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>查找最后一个小于等于给定值的元素</p><p>要查找的值大于当前mid中的值，目标值在[low,mid-1]之间，更新high=mid-1。</p><p>要查找的值小于mid+1的值，则要查找的值在[mid+1,high]之间，更新low=mid+1。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">bsearch7</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> n, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span>  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &gt; value) &#123;</span><br><span class="line">      high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ((mid == n - <span class="number">1</span>) || (a[mid + <span class="number">1</span>] &gt; value)) <span class="keyword">return</span> mid;</span><br><span class="line">      <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>数据结构与算法之美</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C-指针</title>
      <link href="/2019/02/17/C-%E6%8C%87%E9%92%88/"/>
      <url>/2019/02/17/C-%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<p>还是总结下，嘿嘿，这个之前还没理解。要注意，数组和指针没啥关系！</p><span id="more"></span><h2 id="理解指针"><a href="#理解指针" class="headerlink" title="理解指针"></a>理解指针</h2><h3 id="指针是什么，举个栗子"><a href="#指针是什么，举个栗子" class="headerlink" title="指针是什么，举个栗子"></a>指针是什么，举个栗子</h3><p>我们隔壁的隔壁宿舍最近经营起了零食店。</p><p>我：来5包卫龙大面筋，送到413！</p><p>老板：么马达！来咧！</p><p>现在，假设这栋宿舍楼没有门牌号。</p><p>我：来5包卫龙大面筋，送到……额……4楼一上楼从最左边往右第13个宿舍！</p><p>老板：…… !!!???</p><p>其实指针就像门牌号一样，便于定位查找内存中的数据。</p><p>4GB的内存条有$2^{32}$个房间存数据，没有门牌号怎么找？从第一个开始数？哈哈。</p><p>在C语言中可以这样理解一个变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *b = &amp;a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>int a = 10;</code>就是<strong>a</strong>这个人从房地产商(系统)那里买来一间房子，里面放着自己的东西<strong>10</strong>，此时<strong>a</strong>这个人的地址是系统知道的，然后<strong>a</strong>把这个地址(&amp;)告诉了他的好朋友<strong>b</strong>，并且给了<strong>b</strong>这间房子的钥匙(*)，这样<strong>b</strong>就可以通过地址找到这个房子地址并且在房间里取或者放自己的东西了。如果<strong>a</strong>不想让<strong>b</strong>乱动家里东西，可以和<strong>b</strong>说“不许乱动哦！”(加上const，嘿嘿)。</p><h3 id="指针变量"><a href="#指针变量" class="headerlink" title="指针变量"></a>指针变量</h3><p>这个其实挺好理解，在中文中，一般把强调的重点放在后面，指针变量是个<strong>变量</strong>。像这样理解的还有：数组<strong>指针</strong>、指针<strong>数组</strong>。</p><p>指针变量是个变量，这个变量里面存的是地址数据。</p><p>指针变量的大小：</p><p>不论是什么类型（包括void *，这个下面细说～）：</p><ul><li>32位环境下，指针变量的大小是4字节。</li><li>64位环境下，指针变量的大小是8字节。</li></ul><p>emmm，怎么理解呢？</p><p>计算机给能访问的内存地址是规范的长度，全0到全1，32位系统下可编址的范围32个比特位(4字节)，64位机器可编址的范围为64个比特位(8字节)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;void*\t%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">void</span> *));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;char*\t%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>*));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;int*\t%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">int</span> *));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;float*\t%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">float</span>*));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;double*\t%d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">double</span>*));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>光说不顶用，来验证下，在64位环境下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>*<span class="number">8</span></span><br><span class="line"><span class="type">char</span>*<span class="number">8</span></span><br><span class="line"><span class="type">int</span>*<span class="number">8</span></span><br><span class="line"><span class="type">float</span>*<span class="number">8</span></span><br><span class="line"><span class="type">double</span>*<span class="number">8</span></span><br></pre></td></tr></table></figure><p>32位机下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>*<span class="number">4</span></span><br><span class="line"><span class="type">char</span>*<span class="number">4</span></span><br><span class="line"><span class="type">int</span>*<span class="number">4</span></span><br><span class="line"><span class="type">float</span>*<span class="number">4</span></span><br><span class="line"><span class="type">double</span>*<span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="void-是个什么鬼"><a href="#void-是个什么鬼" class="headerlink" title="void *是个什么鬼"></a>void *是个什么鬼</h3><p>可以做这样的事：<code>void *vp;</code></p><p>但是void*类型的指针不能被解引用，因为解引用后它不知道要访问多大的空间(int*解引用可以访问4字节的空间，char*解引用后可以访问1字节的空间)。</p><p>void*可以接收任意类型的指针，这样就可以用它来做一些接口方面的事，这就方便了许多。</p><h2 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h2><p>对于以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;char* : %lu\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="type">char</span>*));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;short* : %lu\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="type">short</span>*));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;int* : %lu\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>*));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;float* : %lu\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="type">float</span>*));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;double* : %lu\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="type">double</span>*));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;long double* : %lu\n&quot;</span>,<span class="keyword">sizeof</span>(<span class="type">long</span> <span class="type">double</span>*));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在64位机器下运行结果为：</p><p><img src="https://camo.githubusercontent.com/98b19b496e93806971e221b986c1327fd609b9cc/68747470733a2f2f7778312e73696e61696d672e636e2f6d773639302f30303677523064636c793166776576763836786a666a333069753039303734792e6a7067" alt="-64"></p><p>在32位机器下运行结果为：</p><p><img src="https://camo.githubusercontent.com/9196131c1403410461d37d3836786465697e69ca/68747470733a2f2f7778332e73696e61696d672e636e2f6d773639302f30303677523064636c7931667765767631327078746a33316b77306a71646f6f2e6a7067" alt="gcc main.c -m32"></p><p><em><strong>那么问题来了，既然占用大小都是一样的，为什么还要有这么多类型呢？</strong></em></p><h3 id="指针类型的作用"><a href="#指针类型的作用" class="headerlink" title="指针类型的作用"></a>指针类型的作用</h3><ul><li>指针类型决定了对指针解引用的时候有多大的权限（能操作几个字节）。比如：<code>char*</code>的指针解引用只能访问一个字节，而<code>int*</code>的指针解引用就能访问四个字节。</li><li>指针类型决定了指针指向前或者向后一步有多大距离。</li></ul><p>看下面的这段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0x11223344</span>;</span><br><span class="line">    <span class="type">int</span> *pi = &amp;i;</span><br><span class="line">    *pi = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> c = <span class="number">0x11223344</span>;</span><br><span class="line">    <span class="type">char</span> *pc = &amp;c;</span><br><span class="line">    *pc = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Debug看内存变化：</p><p><a href="https://camo.githubusercontent.com/fa302cfc6e28d6ee72a86a23d8f8e9cbd10d451e/68747470733a2f2f7778332e73696e61696d672e636e2f6d773639302f30303677523064636c7931667765776c32706c77726a33306c303037343734722e6a7067"><img src="https://camo.githubusercontent.com/fa302cfc6e28d6ee72a86a23d8f8e9cbd10d451e/68747470733a2f2f7778332e73696e61696d672e636e2f6d773639302f30303677523064636c7931667765776c32706c77726a33306c303037343734722e6a7067" alt="p"></a></p><p><a href="https://camo.githubusercontent.com/57a12eddf6d4ca658d9fd2bc6ede68ce474a3b0d/68747470733a2f2f7778322e73696e61696d672e636e2f6d773639302f30303677523064636c7931667765776c6c6d666e336a3330626f30366d3379762e6a7067"><img src="https://camo.githubusercontent.com/57a12eddf6d4ca658d9fd2bc6ede68ce474a3b0d/68747470733a2f2f7778322e73696e61696d672e636e2f6d773639302f30303677523064636c7931667765776c6c6d666e336a3330626f30366d3379762e6a7067" alt="img"></a></p><p>发现：<code>i=0x11223344</code>在执行<code>*pi=0;</code>后全部变为了0，<code>c=0x11223344</code>在执行<code>*pc=0;</code>后只有高位变成了0</p><p>说明：int*类型的指针解引用后，操作权限是4个字节(int的大小)。char*解引用后，操作权限仅为一个字节。</p><p>指针类型决定了对指针解引用的时候有多大的权限（能操作几个字节）。</p><p>再来看看第二个小点，对于以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *pi = &amp;n;</span><br><span class="line">    <span class="type">char</span> *pc = (<span class="type">char</span>*)&amp;n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;n : %p\n&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pi : %p\n&quot;</span>, pi);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pi+1 : %p\n&quot;</span>, pi+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-----------------------\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pc : %p\n&quot;</span>, pc);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pc+1 : %p\n&quot;</span>, pc+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有在64位机下有如下输出：</p><p><a href="https://camo.githubusercontent.com/a923b880ac9b3ed9eba1143f3e79703fe214c301/68747470733a2f2f7778342e73696e61696d672e636e2f6d773639302f30303677523064636c793166776578346f373074356a3330696d3038737766642e6a7067"><img src="https://camo.githubusercontent.com/a923b880ac9b3ed9eba1143f3e79703fe214c301/68747470733a2f2f7778342e73696e61696d672e636e2f6d773639302f30303677523064636c793166776578346f373074356a3330696d3038737766642e6a7067" alt="pic"></a></p><p>可以看到：<code>pi=pc=&amp;n</code></p><p>但是：<code>pi+1</code> 和 <code>pc+1</code> 不同，<code>pi+1 - pi</code> = 8，<code>pc+1 - pc</code> = 1</p><p>指针类型决定了指针指向前或者向后一步有多大距离。</p><h3 id="指针的题目"><a href="#指针的题目" class="headerlink" title="指针的题目"></a>指针的题目</h3><ol><li>题</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)(&amp;a+<span class="number">1</span>); <span class="comment">// p指向5后面的那个地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>, *(a+<span class="number">1</span>), *(p<span class="number">-1</span>));  <span class="comment">//2,5</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>题</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> Num;</span><br><span class="line">    <span class="type">char</span> *pcName;</span><br><span class="line">    shortsDate;</span><br><span class="line">    <span class="type">char</span> cha[<span class="number">2</span>];</span><br><span class="line">    shortsBa[<span class="number">4</span>];</span><br><span class="line">&#125;*p;</span><br><span class="line">假设结构体test的大小为<span class="number">20</span>个字节，p的地址为<span class="number">0x100000</span>。</span><br><span class="line">p + <span class="number">0x1</span> = ?<span class="comment">// p+1 =&gt; +20</span></span><br><span class="line">(<span class="type">unsigned</span> <span class="type">long</span>)p + <span class="number">0x1</span> = ?<span class="comment">// 0x100001 (eg: int a = 0, a + 1 = 1)</span></span><br><span class="line">(<span class="type">unsigned</span> <span class="type">int</span> *)p + <span class="number">0x1</span> = ?<span class="comment">// 0x100004 (加一个指针的大小，32位平台下4)</span></span><br></pre></td></tr></table></figure><ol start="3"><li>题</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p1 = (<span class="type">int</span> *)(&amp;a+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> *p2 = (<span class="type">int</span> *)((<span class="type">int</span>)a+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x,%x\n&quot;</span>, p1[<span class="number">-1</span>], *p2);</span><br><span class="line">    <span class="comment">// p1[-1] 输出 4</span></span><br><span class="line">    <span class="comment">// *p2 这个编译可以通过，但是运行错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在内存中：</p><p><img src="https://wx4.sinaimg.cn/mw690/006wR0dcly1fxnh37huqmj31o60u0abh.jpg" alt="指针笔试题3"></p><ol start="4"><li>题</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>][<span class="number">2</span>] = &#123; (<span class="number">0</span>,<span class="number">1</span>), (<span class="number">2</span>,<span class="number">3</span>), (<span class="number">4</span>,<span class="number">5</span>) &#125;;</span><br><span class="line">    <span class="type">int</span> *p = a[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p[<span class="number">0</span>]); <span class="comment">// 输出1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意逗号表达式：运算结果为后面的值</p><p>所以：</p><p><img src="https://wx3.sinaimg.cn/mw690/006wR0dcly1fxnhbmau9fj30fi0fuq3k.jpg" alt="4"></p><ol start="5"><li>题</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> (*p)[<span class="number">4</span>];<span class="comment">//注意这里！</span></span><br><span class="line">    p = a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p,%d\n&quot;</span>, &amp;p[<span class="number">4</span>][<span class="number">2</span>]-&amp;a[<span class="number">4</span>][<span class="number">2</span>], &amp;p[<span class="number">4</span>][<span class="number">2</span>]-&amp;a[<span class="number">4</span>][<span class="number">2</span>]); <span class="comment">//输出： -4的补码，-4</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://wx1.sinaimg.cn/mw690/006wR0dcly1fxnhvji5v2j31nw0poq6g.jpg" alt="5"></p><p>输出他们之间元素的个数。</p><p>因为<code>p[4][2]</code>的地址小于<code>a[4][2]</code>的地址，所以为<code>-4</code>，但是由于输出的时候，<code>%p</code>输出的是地址，也就是一个无符号的数，所以将<code>-4</code>的补码输出，<code>%d</code>正常输出。</p><ol start="6"><li>题</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> aa[<span class="number">2</span>][<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line">    <span class="type">int</span> *p1 = (<span class="type">int</span> *)(&amp;aa + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> *p2 = (<span class="type">int</span> *)(*(aa + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>, *(p1<span class="number">-1</span>), *(p2<span class="number">-1</span>));<span class="comment">// 输出10，5</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&amp;aa+1</code>跨过了整个数组<code>aa</code>的长度，指向元素10后的地址。</p><p><code>aa+1</code>代表的跨过了一个<code>aa</code>的元素，而<code>aa</code>是一个二维数组，它的元素是一个一维数组。如下图：</p><p><img src="https://wx3.sinaimg.cn/mw690/006wR0dcly1fxnigcsmz0j30oy0fiaaw.jpg" alt="6"></p><ol start="7"><li>题</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *a[] = &#123;<span class="string">&quot;work&quot;</span>, <span class="string">&quot;at&quot;</span>, <span class="string">&quot;360&quot;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> **pa = a;</span><br><span class="line">    pa++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *pa);<span class="comment">// 输出at</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://wx4.sinaimg.cn/mw690/006wR0dcly1fxnipjqiicj31460c475c.jpg" alt="7"></p><ol start="8"><li>题</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *c[] = &#123; <span class="string">&quot;ENTER&quot;</span>, <span class="string">&quot;NEW&quot;</span>, <span class="string">&quot;POINT&quot;</span>, <span class="string">&quot;FIRST&quot;</span> &#125;;</span><br><span class="line">    <span class="type">int</span> **cp[] = &#123; c+<span class="number">3</span>, c+<span class="number">2</span>, c+<span class="number">1</span>, c &#125;;</span><br><span class="line">    <span class="type">char</span> ***cpp = cp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, **++cpp);<span class="comment">// POINT</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *--*++cpp+<span class="number">3</span>);<span class="comment">// ER</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *cpp[<span class="number">-2</span>]+<span class="number">3</span>);<span class="comment">// ST</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, cpp[<span class="number">-1</span>][<span class="number">-1</span>]+<span class="number">1</span>);<span class="comment">// EW</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>++、—</code>的优先级高于<code>*</code>，<code>*</code>的优先级高于<code>+</code>。<code>++cpp</code>会影响<code>cpp</code>的值，但<code>cpp+1</code>不会影响。<code>[]</code>的优先级大于<code>*</code>。</p><p><img src="https://wx2.sinaimg.cn/mw690/006wR0dcly1fxnj61eghkj31fy0l0q5n.jpg" alt="8.1"></p><p><code>**++cpp</code>：先<code>++</code>，此时的<code>cpp</code>指向<code>cp[1]</code>，解引用为<code>c[2]</code>，再解引用即为<code>POINT</code>。</p><p><img src="https://wx2.sinaimg.cn/mw690/006wR0dcly1fxnjdh5q1zj31fq0k00ve.jpg" alt="8.2"></p><p><code>*--*++cpp+3</code>：经过上一步，<code>cpp</code>现在的指向如上图。</p><p>先<code>++</code>，此时<code>cpp</code>指向<code>cp[2]</code>，解引用即为<code>cp[2]</code>，再<code>--</code>，此时改变了<code>cp[2]</code>的指向，他指向<code>c[0]</code>，再解引用即为<code>c[0]</code>，给<code>c[0]+3</code>，输出的结果为<code>ER</code>。</p><p><img src="https://wx2.sinaimg.cn/mw690/006wR0dcly1fxnjlyh6yzj31jm0hy0vf.jpg" alt="8.3"></p><p><code>*cpp[-2]+3</code>：经过上一步，现在的指向如上图所示。</p><p><code>cpp[-2]</code>指向了<code>cp[0]</code>，解引用指向<code>c[3]</code>，<code>c[3]+3</code>输出<code>ST</code>。</p><p><code>cpp[-1][-1]+1</code>：经过上一步并没有改变指针的指向。</p><p><code>cpp[-1][-1]</code>代表<code>c[1]</code>，再<code>+1</code>输出<code>EW</code>。</p><h2 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h2><h3 id="数组名"><a href="#数组名" class="headerlink" title="数组名"></a>数组名</h3><p>除了以下两种情况外，一般情况下，数组名都代表数组首元素的地址。</p><p>数组名代表整个数组的情况：</p><ol><li><p><code>sizeof</code>中的数组名(<strong>只出现数组名</strong>)代表整个数组。<code>sizeof(arr)</code>这里的数组名代表的是整个数组，但是<code>sizeof(arr+0)</code>代表首元素<strong>地址</strong>的大小。</p></li><li><p><code>&amp;arr</code>代表整个数组。(实际上<code>&amp;arr</code>表示的是数组的地址，而不是数组首元素的地址，数组的地址+1，会跳过整个数组的大小)</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(arr) -&gt; %d\n&quot;</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(arr+0) -&gt; %d\n&quot;</span>, <span class="keyword">sizeof</span>(arr+<span class="number">0</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(&amp;arr) -&gt; %d\n&quot;</span>, <span class="keyword">sizeof</span>(&amp;arr));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;arr -&gt; %p\n&quot;</span>, arr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;arr -&gt; %p\n&quot;</span>, &amp;arr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;arr+1 -&gt; %p\n&quot;</span>, arr+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;arr+1 -&gt; %p\n&quot;</span>, &amp;arr+<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(arr) -&gt; <span class="number">20</span></span><br><span class="line"><span class="keyword">sizeof</span>(arr+<span class="number">0</span>) -&gt; <span class="number">8</span><span class="comment">// 64bit环境下指针的大小为8字节，32bit环境下指针的大小为4字节，这里arr+0代表的是首元素地址</span></span><br><span class="line"><span class="keyword">sizeof</span>(&amp;arr) -&gt; <span class="number">8</span><span class="comment">// 数组的地址大小(也是一个地址)，占8个字节。</span></span><br><span class="line">arr -&gt; <span class="number">0x7ffeef8929a0</span></span><br><span class="line">&amp;arr -&gt; <span class="number">0x7ffeef8929a0</span></span><br><span class="line">arr+<span class="number">1</span> -&gt; <span class="number">0x7ffeef8929a4</span><span class="comment">// 跳过了一个元素</span></span><br><span class="line">&amp;arr+<span class="number">1</span> -&gt; <span class="number">0x7ffeef8929b4</span><span class="comment">// 这里跳过了整个数组的大小(20)</span></span><br></pre></td></tr></table></figure><p>对指针+1，实际上加的是这个指针类型的大小，比如整型指针+1，地址+4。</p><h3 id="区分指针数组和数组指针"><a href="#区分指针数组和数组指针" class="headerlink" title="区分指针数组和数组指针"></a>区分指针数组和数组指针</h3><p>指针<strong>数组</strong>：是一个数组，数组的元素的指针。</p><p>数组<strong>指针</strong>：是一个指针，指向数组的指针。</p><p>从字面意思上来看就是谁在后就是什么东西。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p1[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> (*p2)[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p><code>int *p1[10]</code>这里的p1先和<code>[]</code>结合，所以他是数组，是指针数组。</p><p><code>int (*p2)[10]</code>p2先和<code>*</code>结合，是指针，是数组指针。</p><h3 id="数组指针的使用"><a href="#数组指针的使用" class="headerlink" title="数组指针的使用"></a>数组指针的使用</h3><p>数组指针  指向数组，那么数组指针中存的就是数组的地址咯。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> (*p)[<span class="number">10</span>] = &amp;arr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但一般不这么使用。一个数组指针的使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_arr</span><span class="params">(<span class="type">int</span> (*arr)[<span class="number">5</span>], <span class="type">int</span> row, <span class="type">int</span> col)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;col; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i][j] = i+j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">disp_arr</span><span class="params">(<span class="type">int</span> (*arr)[<span class="number">5</span>], <span class="type">int</span> row, <span class="type">int</span> col)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;col; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    init_arr(arr, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    disp_arr(arr, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组传参，指针传参"><a href="#数组传参，指针传参" class="headerlink" title="数组传参，指针传参"></a>数组传参，指针传参</h3><ul><li><p>一维数组传参</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test11</span><span class="params">(<span class="type">int</span> arr[])</span>&#123;;&#125;  <span class="comment">// ok</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test12</span><span class="params">(<span class="type">int</span> arr[<span class="number">10</span>])</span>&#123;;&#125;    <span class="comment">// ok</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test13</span><span class="params">(<span class="type">int</span> *arr)</span>&#123;;&#125;   <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test21</span><span class="params">(<span class="type">int</span> *arr[<span class="number">20</span>])</span>&#123;;&#125;   <span class="comment">// ok</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test22</span><span class="params">(<span class="type">int</span> **arr)</span>&#123;;&#125;  <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr1[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *arr2[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">//// 数组指针</span></span><br><span class="line">    test11(arr1);</span><br><span class="line">    test12(arr1);</span><br><span class="line">    test13(arr1);</span><br><span class="line"></span><br><span class="line">    test21(arr2);</span><br><span class="line">    test22(arr2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二维数组传参</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>])</span>&#123;;&#125; <span class="comment">// ok</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> arr[][])</span>&#123;;&#125;   <span class="comment">// error!</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> arr[][<span class="number">5</span>])</span>&#123;;&#125;  <span class="comment">// ok</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> *arr)</span>&#123;;&#125;  <span class="comment">// error!</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span>* arr[<span class="number">5</span>])</span>&#123;;&#125; <span class="comment">// error!</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> (*arr)[<span class="number">5</span>])</span>&#123;;&#125; <span class="comment">// OK!</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> **arr)</span>&#123;;&#125; <span class="comment">// error!</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    test(arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>一级指针传参</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> *p, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *(p+i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p = arr;</span><br><span class="line">    <span class="type">int</span> size = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    print(p, size);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二级指针传参</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> **p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, **p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *p = &amp;n;</span><br><span class="line">    <span class="type">int</span> **pp = &amp;p;</span><br><span class="line">    test(&amp;p);</span><br><span class="line">    test(pp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><h3 id="函数指针-1"><a href="#函数指针-1" class="headerlink" title="函数指针"></a>函数指针</h3><p>函数名代表的是函数地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ahoj\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test    %p\n&quot;</span>, test);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;test   %p\n&quot;</span>, &amp;test);</span><br><span class="line">    test();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test    <span class="number">0x100000ef0</span></span><br><span class="line">&amp;test   <span class="number">0x100000ef0</span></span><br><span class="line">ahoj</span><br></pre></td></tr></table></figure><p>函数也是有地址滴，要保存函数地址，就要用到函数指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*pf1)();<span class="comment">// 函数指针，先和*结合，再与()结合。pf1是一个指针，指向一个无参数的函数，返回值为void</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">pf2</span><span class="params">()</span>;<span class="comment">// 返回值为void *的函数</span></span><br></pre></td></tr></table></figure><p>到这里才理解了《C陷阱和缺陷》里的那段代码：<code>(*(void (*)())0)();</code></p><p>这里的$0$被强制转换为<code>void(*)()</code>，函数指针=&gt;解引用，0代表一个函数的地址（地址为0处的函数）</p><p>再来看个代码：<code>void (*signal(int, void(*)(int)))(int);</code></p><p>这是一段函数声明，函数的返回值为：signal先与*结合=&gt;是个函数指针，指向一个参数为<code>(int, 函数指针类型)</code>的一个函数。参数为：int。</p><p>对于上面的两行代码，太复杂，需要简化一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(*<span class="type">pfun_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;<span class="comment">// pfun_t是一个函数指针，指向一个参数为int的函数</span></span><br><span class="line"><span class="type">pfun_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span>, <span class="type">pfun_t</span>)</span>;<span class="comment">// signal的返回值是个函数指针，参数是int和一个函数指针</span></span><br></pre></td></tr></table></figure><h3 id="函数指针数组"><a href="#函数指针数组" class="headerlink" title="函数指针数组"></a>函数指针数组</h3><p>数组用来存放相同类型数据的，那么把函数的地址存到一个数组中，这个数组就叫做<strong>函数指针数组</strong>。</p><p><code>int (*parr[10])();</code></p><p><code>parr</code>先和<code>[]</code>结合，说明<code>parr</code>是个数组，数组的内容是什么类型呢？是<code>int (*)()</code>类型的函数指针。</p><ul><li><p>函数指针数组的用途：<strong>转移表</strong>（例子：计算器）</p><p>普通版：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">diiv</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a/b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">int</span> input = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(input)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;=========\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;( 1. +  )\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;( 2. -  )\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;( 3. *  )\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;( 4. \\  )\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;=========\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;choice&gt;&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">        <span class="keyword">switch</span>(input)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;&lt;(a b)&gt;&quot;</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">                ret = add(x, y);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;&lt;(a b)&gt;&quot;</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">                ret = sub(x, y);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;&lt;(a b)&gt;&quot;</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">                ret = mul(x, y);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;&lt;(a b)&gt;&quot;</span>);</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">                ret = diiv(x, y);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;error!\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数指针数组实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">int</span> input = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> (*p[<span class="number">5</span>])(<span class="type">int</span> x, <span class="type">int</span> y) = &#123;<span class="number">0</span>, add, sub, mul, diiv&#125;;   <span class="comment">// 转移表</span></span><br><span class="line">    <span class="keyword">while</span>(input)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;=========\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;( 1. +  )\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;( 2. -  )\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;( 3. *  )\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;( 4. \\  )\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;=========\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;choice&gt;&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">        <span class="keyword">if</span>((input&lt;=<span class="number">4</span> &amp;&amp; input&gt;=<span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;a b &gt;&quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">            ret = (*p[input])(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;error!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="指向函数指针数组的指针"><a href="#指向函数指针数组的指针" class="headerlink" title="指向函数指针数组的指针"></a>指向函数指针数组的指针</h3><p>上面这个东西，首先是个指针，指向一个数组，数组的元素是函数指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 函数指针pf</span></span><br><span class="line">    <span class="type">void</span> (*pf)(<span class="type">const</span> <span class="type">char</span> *) = test;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 函数指针的数组pfarr</span></span><br><span class="line">    <span class="type">void</span> (*pfarr[<span class="number">5</span>])(<span class="type">const</span> <span class="type">char</span> *str);</span><br><span class="line">    pfarr[<span class="number">0</span>] = test;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指向函数指针数组pfarr的指针ppfarr</span></span><br><span class="line">    <span class="type">void</span> (*(*ppfarr)[<span class="number">10</span>])(<span class="type">const</span> <span class="type">char</span> *) = &amp;pfarr;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><blockquote><p>回调函数就是一个通过函数指针调用的函数。如果把函数的地址作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，称为这是一个回调函数。</p><p>回调函数不是由该函数的实现方法直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对事件或条件进行相应。</p><p><a href="https://baike.baidu.com/item/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/7545973?fr=aladdin">百度百科</a></p></blockquote><p>简单认识qsort函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">qsort</span><span class="params">(<span class="type">void</span> *base, <span class="type">size_t</span> nel, <span class="type">size_t</span> width, <span class="type">int</span> (*compar)(<span class="type">const</span> <span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *))</span>;</span><br></pre></td></tr></table></figure><p>返回值<code>void</code>，第一个参数是要排序的数组，第二个参数要排序数组元素的个数，第三个参数时每个元素的大小（所占字节数，比如int类型占4字节），第四个参数是一个比较大小用的回调函数（这个函数返回一个整数，参数为两个指针）。</p><p>qsort函数的使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">int_cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> * p1, <span class="type">const</span> <span class="type">void</span> *p2)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//    return (*(int *)p1 &lt; *(int *)p2); //这样只对正整数有效</span></span><br><span class="line">    <span class="type">int</span> x = *(<span class="type">int</span> *)p1;</span><br><span class="line">    <span class="type">int</span> y = *(<span class="type">int</span> *)p2;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; y)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x == y)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">11</span>,<span class="number">33</span>,<span class="number">22</span>,<span class="number">-11</span>,<span class="number">-22</span>,<span class="number">-300</span>,<span class="number">32</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    qsort(arr, <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), <span class="keyword">sizeof</span>(<span class="type">int</span>), int_cmp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用冒泡排序模拟实现qsort这种类型的排序函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">int_cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> * p1, <span class="type">const</span> <span class="type">void</span> *p2)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//    return (*(int *)p1 &lt; *(int *)p2); //这样只对正整数有效</span></span><br><span class="line">    <span class="type">int</span> x = *(<span class="type">int</span> *)p1;</span><br><span class="line">    <span class="type">int</span> y = *(<span class="type">int</span> *)p2;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; y)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x == y)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">void</span> *p1, <span class="type">void</span> *p2, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> tmp = *((<span class="type">char</span> *)p1+i);</span><br><span class="line">        *((<span class="type">char</span> *)p1+i) = *((<span class="type">char</span> *)p2+i);</span><br><span class="line">        *((<span class="type">char</span> *)p2+i) = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">myqsort</span><span class="params">(<span class="type">void</span> *base,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> len,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> width,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> (*cmp)(<span class="type">void</span> *p1, <span class="type">void</span> *p2))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;len<span class="number">-1</span>-i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( cmp((<span class="type">char</span> *)base+j*width,(<span class="type">char</span> *)base+(j+<span class="number">1</span>)*width) &gt; <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                swap((<span class="type">char</span> *)base+j*width,</span><br><span class="line">                     (<span class="type">char</span> *)base+(j+<span class="number">1</span>)*width,</span><br><span class="line">                     <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">11</span>,<span class="number">33</span>,<span class="number">22</span>,<span class="number">-11</span>,<span class="number">-22</span>,<span class="number">-300</span>,<span class="number">32</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    qsort(arr, <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), <span class="keyword">sizeof</span>(<span class="type">int</span>), int_cmp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>参考：《C和指针》、《剑指offer》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C-数据在内存中存储</title>
      <link href="/2019/02/17/C-%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8/"/>
      <url>/2019/02/17/C-%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<p>C语言中各种数据类型在内存中是怎么存储的。</p><span id="more"></span><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>char、short、int、long</p><h3 id="存整数"><a href="#存整数" class="headerlink" title="存整数"></a>存整数</h3><ol><li><p>无符号数：原、反、补码一样</p></li><li><p>有符号数：</p><ul><li><p>正数：原、反、补码一样</p></li><li><p>负数：补码表示</p></li></ul></li></ol><p>举个栗子：</p><p>-10 : 有符号 =&gt; 负数 =&gt; 存它的补码<br>原： 1000 1010<br>反： 1111 0101<br>补： 1111 0110     (最终存入内存中的-10)</p><h3 id="取整数"><a href="#取整数" class="headerlink" title="取整数"></a>取整数</h3><p>看是什么类型(有符号整数 / 无符号整数)</p><ol><li><p>无符号整数：直接取</p></li><li><p>有符号整数：</p><ul><li><p>正数：直接取</p></li><li><p>负数：补 =&gt; 原再取</p></li></ul></li></ol><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">signed</span> <span class="type">char</span> b = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> c = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d,b=%d,c=%d\n&quot;</span>, a, b, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<code>-1,-1,255</code></p><p>a和b的结果是一样的，这里就分析下a：</p><p>存：a是有符号数负数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">-1</span></span><br><span class="line">    原： <span class="number">1000</span> <span class="number">0001</span></span><br><span class="line">    反： <span class="number">1111</span> <span class="number">1110</span></span><br><span class="line">    补： <span class="number">1111</span> <span class="number">1111</span></span><br><span class="line">    <span class="number">1.</span>存的时候不考虑类型，直接存 <span class="number">-1</span> 的补码 <span class="number">1111</span> <span class="number">1111</span></span><br><span class="line">    <span class="number">2.</span>在%d输出的时候，会发生整型提升，整型提升默认的是按照变量的原始类型添加前面的比特位，这里的a是有符号的所以前面添加 <span class="number">1</span>，变为 <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span>，这样的话用%d输出，结果是 <span class="number">-1</span>。</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="number">-1</span></span><br><span class="line">    还是一样的，存的时候不考虑类型，存 <span class="number">-1</span> 的补码 <span class="number">1111</span> <span class="number">1111</span></span><br><span class="line">    在%d输出的时候，整型提升，添加比特位，这里的c是<span class="type">unsigned</span>类型的，所以前面添加 <span class="number">0</span>，变为：</span><br><span class="line">    <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">11111111</span></span><br><span class="line">    这样，以%d输出就是<span class="number">255</span>咯。</span><br></pre></td></tr></table></figure><h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><p>float、double、long double，浮点数的表示范围在float.h中定义</p><h3 id="浮点数的表示"><a href="#浮点数的表示" class="headerlink" title="浮点数的表示"></a>浮点数的表示</h3><p>根据国际标准IEEE 754，任意一个二进制浮点数可以表示为：(-1) ^ S * M * 2^E</p><ul><li>(-1)^S表示符号位，S=0时，为正，S=1时，为负。</li><li>M表示有效数字，大于等于1，小于2。</li><li>2^E表示指数位。</li></ul><p>栗子：</p><p>十进制5.0，写成二进制101.0，相当于1.01 * 2^2，其中S=0，M=1.01，E=2。</p><p>十进制-5.0，二进制为-101.0，相当于-1.01 * 2^2，其中S=1，M=1.01，E=2。</p><h3 id="浮点数的存储"><a href="#浮点数的存储" class="headerlink" title="浮点数的存储"></a>浮点数的存储</h3><p>对于32位的浮点数(单精度)，最高的1位是符号位S，接着的8位是指数E，剩下的23位为有效数字M。</p><p>对于64位的浮点数(双精度)，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M。</p><p>对于有效数字M和指数E，还有一些特别的规定：</p><ol><li><p>有效数字M</p><p>在计算机内部存储M时，默认这个数的第一位总是1，因此可以被舍去，只保存小数点后面的部分。比如在保存1.01的时候，只保存01，等到读取的时候，再讲第一位的1加上去。这样，就节省出了1位有效数字。以32位浮点数为例，留给M的只有23位，舍去第一位后，就可以保存24位有效数字。</p></li><li><p>指数E</p><p>由内存分配可以看出，E没有符号位，E是一个无符号整数。这意味着，如果E为8位，它的取值范围位0-255。如果E位11位，它的取值范围为0-2047。但是，在科学计数法中E是可以出现负数的，所以IEEE规定，存入内存时E的真实值必须再加上一个中间数，对于8位的E，中间数位127；对于11位的E，中间数是1023。</p></li></ol><p>比如：2^{10}的E是10，保存为32位浮点数时，必须保存成10+127=137，即10001001。</p><ul><li><p>E不全为0或不全为1</p><p>此时指数E的计算值减去127(或1023)，得到真实值，再在有效数字M前加上第一位的1。</p><p>比如：0.5的二进制形式为0.1，由于规定M的正数部分必须为1，即小数点右移1位，为1.0 * 2 ^ {-1}，其阶码为-1+127=126，表示为01111110，而尾数1.0去掉整数部分为0，补齐0到23位，最终0.5的二进制表示为：<code>0 01111110 00000000000000000000000</code>。</p></li><li><p>E全为0(浮点数0)</p><p>这时，浮点数的指数 E 等于1-127(或1-1023)即为真实值，有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示+0 ~ -0，以及接近于0的很小的数字。</p></li><li><p>E全为1(最小、最大浮点数)</p><p>这时，如果有效数字M全为 0 ，表示 +∞ 和 -∞ (正负取决于符号位S)。</p></li></ul><h3 id="关于浮点数的栗子"><a href="#关于浮点数的栗子" class="headerlink" title="关于浮点数的栗子"></a>关于浮点数的栗子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">9</span>;</span><br><span class="line">    <span class="comment">// 第一部分</span></span><br><span class="line">    <span class="type">float</span> *pFloat = (<span class="type">float</span>*)&amp;n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n:%d\n&quot;</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*pFloat:%f\n&quot;</span>, *pFloat);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第二部分</span></span><br><span class="line">    *pFloat = <span class="number">9.0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n:%d\n&quot;</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*pFloat:%f\n&quot;</span>, *pFloat);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://wx2.sinaimg.cn/mw690/006wR0dcly1fx4bfr4hy3j30ew066t94.jpg" alt="pic"></p><p>第一部分：</p><p>首先把<code>0x00000009</code>(16进制)拆分：符号位S=0，后面8位E=00000000，最后23位M=000 0000 0000 0000 0000 1001。</p><p>9最终表示为浮点数为：<code>0000 0000 0000 0000 0000 0000 0000 1001</code>。指数位E全为0，改写成浮点数为：(-1) ^ 0 * 0.000 0000 0000 0000 0000 0000 0000 1001 * 2 ^ {-126} = 1.001 * 2 ^ {-146}​。</p><p>显然，这是一个很小的接近于0的正数，所以用十进制小数表示为0.000000。</p><p>第二部分：</p><p>浮点数9.0表示为二进制：1001.0，即1.001 * 2 ^ 3。</p><p>M=1.001，E=3+127=130。</p><p>写成二进制：<code>0 10000010 001 0000 0000 0000 0000 0000</code>，这个32位的二进制数，表示成十进制正是，1091567616。</p><hr>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C-大小端</title>
      <link href="/2019/02/17/C-%E5%A4%A7%E5%B0%8F%E7%AB%AF/"/>
      <url>/2019/02/17/C-%E5%A4%A7%E5%B0%8F%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<p>大端存储模式：数据的低位保存在内存的高地址中，数据的高位，保存在内存的低地址中。<br>小端存储模式：数据的低位保存在内存的低地址中，数据的高位，保存在内存的高地址中。</p><span id="more"></span><h2 id="为什么会有大小端"><a href="#为什么会有大小端" class="headerlink" title="为什么会有大小端"></a>为什么会有大小端</h2><p>举个例子：</p><p>30个人，问问他们吃煮鸡蛋是从大头砸还是从小头砸或者是中间，反转我们宿舍6个人不都一样。科学家们也一样，关于数据在内存里先存大的还是先存小的，也有争议。</p><p><strong>大端小端没有谁优谁劣，各自优势便是对方劣势：</strong></p><p>小端模式 ：强制转换数据不需要调整字节内容，1、2、4字节的存储方式一样。<br>大端模式 ：符号位的判定固定为第一个字节，容易判断正负。</p><blockquote><p>在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器），另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如果将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。例如一个16bit的short型x，在内存中的地址为0x0010，x的值为0x1122，那么0x11为高字节，0x22为低字节。对于大端模式，就将0x11放在低地址中，即0x0010中，0x22放在高地址中，即0x0011中。小端模式，刚好相反。我们常用的X86结构是小端模式，而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。</p></blockquote><h2 id="如何判断大小端"><a href="#如何判断大小端" class="headerlink" title="如何判断大小端"></a>如何判断大小端</h2><ol><li><p>定义一个变量<code>int a = 1234;</code>然后看这个变量在内存中的存储方式。</p></li><li><p>百度2015年系统工程师笔试题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">check1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (*(<span class="type">char</span> *)&amp;i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">check2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">    &#125;un;</span><br><span class="line">    un.i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> un.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(check1())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;小端\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;大端\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>错题整理</title>
      <link href="/2019/01/12/%E9%94%99%E9%A2%98%E6%95%B4%E7%90%86/"/>
      <url>/2019/01/12/%E9%94%99%E9%A2%98%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>整理了一下一些错题，以便日后回顾。</p><span id="more"></span><h2 id="考试错题"><a href="#考试错题" class="headerlink" title="考试错题"></a>考试错题</h2><ol><li><p>编程实现一个对8bit数据(unsigned char)的指定位(比如第n位)的置0或者置1操作，其他位保持不变。</p><p>函数原型：<code>void bit_set(unsigned char *p_data, unsigned char pos, int flag)</code></p><p>这道题考试的时候我是这么写的：将这个p_data左移、右移。刚才在写关于位段的错题时，想起来还可以这么搞，但是还是移位操作比较方便，嘿嘿，我就试试。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> A(uc, x) uc##x</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sup</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> uc1 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> uc2 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> uc3 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> uc4 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> uc5 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> uc6 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> uc7 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> uc8 : <span class="number">1</span>;</span><br><span class="line">&#125; *pSUP_S;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bit_set</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *p_data, <span class="type">unsigned</span> <span class="type">char</span> pos, <span class="type">int</span> flag)</span></span><br><span class="line">&#123;</span><br><span class="line">    pSUP_S ps = (pSUP_S)p_data;</span><br><span class="line">    <span class="keyword">switch</span>(pos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            ps-&gt;A(uc, <span class="number">1</span>) = flag;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            ps-&gt;A(uc, <span class="number">2</span>) = flag;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            ps-&gt;A(uc, <span class="number">3</span>) = flag;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            ps-&gt;A(uc, <span class="number">4</span>) = flag;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            ps-&gt;A(uc, <span class="number">5</span>) = flag;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            ps-&gt;A(uc, <span class="number">6</span>) = flag;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            ps-&gt;A(uc, <span class="number">7</span>) = flag;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            ps-&gt;A(uc, <span class="number">8</span>) = flag;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a%<span class="number">2</span>);</span><br><span class="line">        a /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> a = <span class="number">1</span>;</span><br><span class="line">    bit_set(&amp;a, <span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">    print(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr></li><li><p>给出以下定义：</p><p><code>char x[] = &quot;abcdefg&quot;;</code></p><p><code>char y[] = &#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;&#125;;</code></p><p>则正确的叙述为（C）</p><p>A）数组x和数组y等价    B）数组x和数组y的长度相同</p><p>C）数组x的长度大于数组y的长度    D）数组x的长度小于y的长度</p><p><em><strong>分析：粗心大意！选项都不看清就选答案？</strong></em></p><hr></li><li><p>设有如下定义：</p><p><code>unsigned long arr[] = &#123;6,7,8,9,10&#125;;</code></p><p><code>unsigned long *p;</code></p><p>则下列程序段的输出结果为（6,12）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = arr;</span><br><span class="line">*(p + <span class="number">3</span>) += <span class="number">3</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>, *p, *(p + <span class="number">3</span>));</span><br></pre></td></tr></table></figure><p><em><strong>分析：粗心大意！慌什么慌，稳住啊。给数组解引用又不是给你解引用，题看完再写啊。</strong></em></p><hr></li><li><p>全局变量可以定义在被多个.c文件包含着的头文件中（❌）</p><p><em><strong>分析：注意区分定义和声明的概念，definition、declaration！</strong></em></p><hr></li><li><p>下面这道题虽然没错，但是还是想写出来，自己以后看到也注意点，别忘了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> a = <span class="number">200</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> b = <span class="number">100</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> c = <span class="number">0</span>;</span><br><span class="line">c = a + b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d &quot;</span>,a+b,c);</span><br></pre></td></tr></table></figure><blockquote><p>C的整型算数运算总是至少以缺省整型类型的精度来进行的，为了获得这个精度，表达式中的字符型和短整型操作数在使用之前被转换为普通整型。《C和指针》</p></blockquote><p><em><strong>分析：输出结果为<code>300,44</code>，注意整形提升问题，<a href="https://github.com/ahojcn/Practice/blob/master/Notes/C/%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8.md">整形提升笔记</a></strong></em></p><hr></li><li><p>下面这个题也是粗心大意造成的，但是还是有一点就是没有区分清楚指针数组和数组指针等概念。<a href="http://ahoj.cc/2019/01/cjqmi1m1m0003td09e812j5rm/">关于指针的笔记</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> *pcArr[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">unRec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> a;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> b[<span class="number">7</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> c;</span><br><span class="line">&#125;REC_S;</span><br><span class="line">REC_S stMax, *pstMax;</span><br></pre></td></tr></table></figure><p>当四字节对齐方式时：</p><p><code>sizeof(pcArr) = 400</code>，<em><strong>是一个10•10的指针数组，数组里存放的是指针。</strong></em></p><p><code>sizeof(stMax) = 16</code>，<em><strong>注意这里是union，慌什么！？</strong></em></p><p><code>sizeof(pstMax) = 4</code>，<em><strong>指针的大小</strong></em></p><p><code>sizeof(*pstMax) = 16</code>，<em><strong>钥匙(&amp;)重4kg，拿着钥匙进了你家门。</strong></em></p><hr></li><li><p>结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> l1;</span><br><span class="line">    <span class="type">char</span> c2;</span><br><span class="line">    <span class="type">char</span> c3;</span><br><span class="line">    <span class="type">long</span> l4;</span><br><span class="line">    <span class="type">long</span> l5;</span><br><span class="line">&#125; *p;</span><br><span class="line">p = (<span class="keyword">struct</span> B*)<span class="number">0x100</span>;</span><br></pre></td></tr></table></figure><p><code>p + 0x1 = 0x110</code><em><strong>，结构体大小是16，指针p的一步长为16，向前走一步加16(10H)。</strong></em></p><p><code>(unsigned long)p + 0x1 = 101</code><em><strong>，注意是强转成了一个数。</strong></em></p><p><code>(unsigned long *)p + 0x1 = 0x104</code>，<em><strong>强转成了指针。</strong></em></p><hr></li><li><p>有如下定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> uc1 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> uc2 : <span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> uc2 : <span class="number">6</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> uc3 : <span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> uc4;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> uc5 : <span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> uc6;</span><br><span class="line">&#125; AAA_S;</span><br></pre></td></tr></table></figure><p>问：AAA_S在1字节对齐和4字节对齐的情况下，占用的空间大小是：6字节、12字节</p><p><em><strong>分析：对于结构体内存对齐这块掌握的还是不好，也没有整理过笔记什么的，考完试整理一篇笔记，复习复习(预习)。</strong></em></p><hr></li><li><p>以下程序的执行结果为：2 29 0 0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(4)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> puc[<span class="number">4</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagPIM</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ucPiml;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ucData0 : <span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ucData1 : <span class="number">2</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ucData2 : <span class="number">3</span>;</span><br><span class="line">&#125; *pstPimData;</span><br><span class="line">pstPimData = (<span class="keyword">struct</span> tagPIM *)puc;</span><br><span class="line"><span class="built_in">memset</span>(puc, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">pstPimData-&gt;ucPiml = <span class="number">2</span>;<span class="comment">// 2-&gt; 10b</span></span><br><span class="line">pstPimData-&gt;ucData0 = <span class="number">3</span>;<span class="comment">// 3-&gt; 11b</span></span><br><span class="line">pstPimData-&gt;ucData1 = <span class="number">4</span>;<span class="comment">// 4-&gt; 100b</span></span><br><span class="line">pstPimData-&gt;ucData2 = <span class="number">5</span>;<span class="comment">// 5-&gt; 101b</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%02x %02x %02x %02x\n&quot;</span>, puc[<span class="number">0</span>], puc[<span class="number">1</span>], puc[<span class="number">2</span>], puc[<span class="number">3</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()</span></span><br></pre></td></tr></table></figure><p><em><strong>分析：首先，结构体tagPIM占4个字节，puc[0]-puc[3]分别指向这4个字节，并初始化为了0，但是tagPIM只用了前两个字节，所以puc[2]和puc[3]的输出结果为0，其余的如下图分析：</strong></em></p><p><em><strong>要注意的几点：第一、ucData0放3(11b)的时候，从低地址开始放，放不下的扔掉，对于ucData1也是。第二、要注意是小端，输出结果的时候是从右往左看的二进制数，还要注意输出的是以16进制的形式输出。</strong></em></p><p><img src="https://wx4.sinaimg.cn/mw690/006wR0dcly1fz40lpyceqj31400u0kjl.jpg" alt="如图"></p><hr></li><li><p><em><strong>注意函数传递的时候，形参的问题。</strong></em></p></li><li><p>添加下面分割线内的代码的初衷是为了给<code>gui_show_image</code>这句代码的执行加上限制条件，请问这样修改有没有隐患，若有，该如何修改？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ......</span></span><br><span class="line">gui_push_clip();</span><br><span class="line"><span class="comment">/*我是分割线*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> AAA</span></span><br><span class="line"><span class="keyword">if</span> (show_status == MMI_TRUE)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/*我是分割线*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> BBB</span></span><br><span class="line">    gui_show_image(x, y, image_id);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">gui_pop_clip();</span><br><span class="line">update_dt_display();</span><br><span class="line"><span class="comment">// ......</span></span><br></pre></td></tr></table></figure><p><em><strong>分析：这句话我第一眼看没啥啊，仔细看🧐下：如果宏BBB没有被定义，程序的逻辑就变成了下面这样：</strong></em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (show_status == MMI_TRUE)</span><br><span class="line">    gui_pop_clip();</span><br></pre></td></tr></table></figure><p><em><strong>修改的方法：加大括号，要养成良好的编码习惯。</strong></em></p></li></ol><h2 id="牛客的错题整理"><a href="#牛客的错题整理" class="headerlink" title="牛客的错题整理"></a>牛客的错题整理</h2><ol><li><p>双链表中至多只有一个节点的后继指针为空（🙆‍♂️）</p><p><em><strong>非循环双链表最后一个节点的后继指针为空；循环双链表没有一个节点的后继指针为空。</strong></em></p></li><li><p>一个长度为99的循环链表，指针A和指针B都指向了链表中的同一个节点，A以步长为1向前移动，B以步长为3向前移动，一共需要同时移动多少步A和B才能再次指向同一个节点？（99）</p><p><em><strong>我选的50，但并不是50，首先是个循环链表，再来就是只有99个元素，设A走x步，那么B走3x步，两个碰到需要$(3x-x) MOD 99 = 0$，x取99才满足。</strong></em></p></li><li><p>在有n个结点的二叉链表中，值为非空的链域的个数为（n-1）</p><p><em><strong>值为空的链域个数为n+1个，为非空的个数为n-1个。</strong></em></p></li><li><p>向一个有127个元素的顺序表中插入一个新元素并保持原来顺序不变，平均要移动（63.5）个元素。</p><p><em><strong>插入：$\frac {n}{2}$，删除：$\frac {n-1}{2}$，查找：$\frac {n+1}{2}$</strong></em></p></li><li><p><em><strong>广义表第一个元素是表头，其余元素是表尾，如果只有一个元素，那么表尾为空即<code>()</code>，在广义表中注意区分空表和有一个为空表的元素的情况。</strong></em></p></li><li><p><em><strong>广义表有如下三个特性：1.层次性：广义表的元素可以是子表，而子表的元素还可以是子表，由此，广义表是一个多层次的结构。2.共享性：广义表可为其他表所共享。3.递归表：广义表可以是其自身的一个子表。</strong></em></p></li><li><p>十字链表是无向图的一种存储结构（🙅‍♂️）。</p><p><em><strong>无向图存储：邻接矩阵、邻接表、多重邻接表。有向图存储：邻接矩阵、邻接表、十字链表</strong></em></p></li></ol><hr><blockquote><p>荐读：《C++/C高质量编程指南》、《C语言深度剖析》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归问题</title>
      <link href="/2019/01/07/%E9%80%92%E5%BD%92%E9%97%AE%E9%A2%98/"/>
      <url>/2019/01/07/%E9%80%92%E5%BD%92%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>学习《数据结构与算法之美》时的笔记。</p><span id="more"></span><h2 id="如何理解递归"><a href="#如何理解递归" class="headerlink" title="如何理解递归"></a>如何理解递归</h2><p>例：领导分配给你一个任务量为n的任务，你做了一部分，然后把剩下的n-1分配给别人，别人又做了一部分，把剩下的n-2分配给了另一个人，直到最后一个人，做了一部分，然后把任务完成返回给他上一个人。</p><p>这个任务下发的过程叫<strong>递</strong>，任务返回的过程叫<strong>归</strong>。</p><p>基本上，所有的递归问题都可以用递推公式来表示，上面这个例子，递推公式表示为：<code>f(n)=f(n-1)+1 其中，f(1)=1</code>。</p><p>上述递归问题的代码表示如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) </span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> f(n<span class="number">-1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归需要满足的条件"><a href="#递归需要满足的条件" class="headerlink" title="递归需要满足的条件"></a>递归需要满足的条件</h2><p>1）一个问题可以分解为几个字问题的解</p><p>2）这个问题与分解之后的字问题，除了数据规模不同，求解思路完全一样</p><p>3）存在递归终止条件</p><p>举个栗子：</p><p>树的定义是一种递归形式的定义，对于树的前序遍历，有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(<span class="keyword">struct</span> TreeNode *root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)<span class="comment">// 递归的终止条件</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 处理root */</span></span><br><span class="line">    PreOrder(root-&gt;left);<span class="comment">// 递推，左子树</span></span><br><span class="line">    PreOrder(root-&gt;right);<span class="comment">// 递推，右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一些树的相关题目中，以这种递推的思想来处理问题还是比较方便的。</p><h2 id="递归代码如何实现"><a href="#递归代码如何实现" class="headerlink" title="递归代码如何实现"></a>递归代码如何实现</h2><p>写递归代码最关键的是写出递推公式，找到终止条件。</p><p>青蛙跳台阶问题：</p><p>假设有n个台阶，每次青蛙可以跳1个台阶或者2个台阶，请问走完这n个台阶有多少种走法？</p><p>例如：有7个台阶，可以2，2，2，1上去，也可以1，2，1，1，2这样上去，总之走法很多，如何编程实现呢？</p><p>分析：根据第一步走法把所有走法分为2类，第一类：第一步走了1个台阶，第二类：第一步走了2个台阶。所以n个台阶的走法 =（先走1个台阶后，n-1个台阶的走法）+（先走2个台阶后，n-2个台阶的走法）</p><p>用递推公式表示就是：</p><p><code>f(n) = f(n-1)+f(n-2)</code></p><p>递推的终止条件：</p><p>当有一个台阶时，不需要再继续递归，只有一中走法。</p><p>当有两个台阶时，可以每次走1个台阶，走两次，也可以一次两个。</p><p>当有三个台阶时，就分解为有一个台阶和两个台阶的问题了。</p><p>所以有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) </span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">2</span>) </span><br><span class="line">      <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> f(n<span class="number">-1</span>) + f(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>人脑几乎没办法把整个递归的过程一步一步想清楚，所以很多时候，我们只需要把它抽象成一个递推公式，不用想一层一层的调用关系，这些交给计算机来做就好了。</strong></p><h2 id="要注意栈溢出！"><a href="#要注意栈溢出！" class="headerlink" title="要注意栈溢出！"></a>要注意栈溢出！</h2><p>如果递归求解的数据规模很大，调用层次很深，就会有栈溢出的发生。</p><p>我的一次栈溢出的经历：在练习用递归模拟strlen函数功能时，如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_strlen</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(*str == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + my_strlen(str++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里传进去的始终是str，所以没有终止的一直压栈，导致栈溢出。</p><p><strong>解决栈溢出的方法：</strong></p><p>1）限制递归深度</p><blockquote><p>这种做法并不能完全解决问题，因为最大允许的递归深度和当前线程剩余的栈空间大小有关，事先无法计算，如果实时计算，代码过于复杂，影响可读性。所以对于最大深度比较小的情况，如10、50，就可以用这种方法，否则这种方法并不是很实用。</p></blockquote><p>2）在堆区模拟系统的工作栈</p><blockquote><p>如果需要可以采用这种方法。</p></blockquote><h2 id="警惕重复计算"><a href="#警惕重复计算" class="headerlink" title="警惕重复计算"></a>警惕重复计算</h2><p>以青蛙跳台阶的问题为例：</p><p><img src="https://static001.geekbang.org/resource/image/e7/bf/e7e778994e90265344f6ac9da39e01bf.jpg" alt="图片引用自极客时间"></p><p>从图中可以看到：想要计算f(5)，需要先计算f(4)和f(3)，而f(4)还需要计算f(3)，因此，f(3)被重复计算了多次，这就是重复计算问题！</p><p>还有个例子：递归方法求第n个斐波那契数，也会有同一n重复计算多次的现象。</p><p>当计算第50个斐波那契数时，f(3)被计算了上亿次，这个计算花了10分钟左右！</p><p><strong>重复计算的解决方法：</strong></p><p>为了避免这种重复计算带来的负面开销，可以通过引入散列表来保存已经求过的f(k)。当递归调用到f(k)时，先看下是否求解过了，如果是直接从散列表中取这个值，就不需要再次计算了。</p><h2 id="递归代码改写为非递归代码"><a href="#递归代码改写为非递归代码" class="headerlink" title="递归代码改写为非递归代码"></a>递归代码改写为非递归代码</h2><p>递归有利有弊，递归的问题不仅仅就上面说的重复计算和栈溢出，递归的空间复杂度有时也比较高。</p><p>如果用递归方法求第n个斐波那契数，时间开销比较大，还是用循环比较好。</p><p>对于上文中两个例子改写如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 领导分配工作 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) </span><br><span class="line">  &#123;</span><br><span class="line">    ret = ret + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 青蛙跳台阶问题 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) </span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">2</span>) </span><br><span class="line">      <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> pre = <span class="number">2</span>;</span><br><span class="line">  <span class="type">int</span> prepre = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) </span><br><span class="line">  &#123;</span><br><span class="line">    ret = pre + prepre;</span><br><span class="line">    prepre = pre;</span><br><span class="line">    pre = ret;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这种思路其实是将递归改成了“手动”递归，本质没有变，增加了实现难度。</strong></p><h2 id="经典递归问题"><a href="#经典递归问题" class="headerlink" title="经典递归问题"></a>经典递归问题</h2><ul><li>在n个球中，任意取m个(不放回)，求有多少种取法</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (n&lt;m)    <span class="comment">// 3个球取4个出来 显然是0种取法</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m==<span class="number">0</span>)   <span class="comment">// 3个球取0个出来 有1种取法</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n==m)   <span class="comment">// 3个球取3个出来 有1种取法</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f(n<span class="number">-1</span>, m<span class="number">-1</span>) + f(n<span class="number">-1</span>, m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> k = f(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, k);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>求n个元素的全排列</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// abc acb bac bca cab cba</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">char</span> data[], <span class="type">int</span> length, <span class="type">int</span> cur)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(cur==length)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, data);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=cur; i&lt;length; i++)</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="comment">// 试探</span></span><br><span class="line"><span class="type">char</span> tmp = data[i];</span><br><span class="line">data[i] = data[cur];</span><br><span class="line">data[cur] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(data, length, cur+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#123;<span class="comment">// 回溯</span></span><br><span class="line"><span class="type">char</span> tmp = data[i];</span><br><span class="line">data[i] = data[cur];</span><br><span class="line">data[cur] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> data[] = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="type">int</span> length = <span class="keyword">sizeof</span>(data)/<span class="keyword">sizeof</span>(data[<span class="number">0</span>]) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">//printf(&quot;%d\n&quot;,length);</span></span><br><span class="line">f(data, length, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>两个串的最大公共子序列的长度</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可解!</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">MAX</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">char</span> *s1, <span class="type">char</span> *s2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(s1)*<span class="built_in">strlen</span>(s2) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s1[<span class="number">0</span>] == s2[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> f(s1+<span class="number">1</span>, s2+<span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> MAX(f(s1+<span class="number">1</span>, s2), f(s1, s2+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *s2 = <span class="string">&quot;xbacd&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ret = f(s1, s2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ret);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>字符串反转</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反转串</span></span><br><span class="line"><span class="comment">// 例如：abc  -&gt;  cba</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ReverseString</span><span class="params">(<span class="type">char</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">strlen</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(length &lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> tmp = p[<span class="number">0</span>];</span><br><span class="line">        p[<span class="number">0</span>] = p[length<span class="number">-1</span>];</span><br><span class="line">        p[length<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        ReverseString(p+<span class="number">1</span>);</span><br><span class="line">        p[length<span class="number">-1</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> p[] = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">    ReverseString(p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, p);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>组合问题</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组合问题</span></span><br><span class="line"><span class="comment">// 3个A 2个B可以组成多少 种 排列</span></span><br><span class="line"><span class="comment">// 如：AAABB AABBA等</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// m个A n个B</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m == <span class="number">0</span> || n == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 假设首位置为A，则剩下m-1个A和n个B的组合问题 + 首位置为B...</span></span><br><span class="line">    <span class="keyword">return</span> f(m<span class="number">-1</span>, n) + f(m, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f(<span class="number">3</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>杨辉三角</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 杨辉三角</span></span><br><span class="line"><span class="comment">// 计算第m层第n个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 1</span></span><br><span class="line"><span class="comment"> 1 1</span></span><br><span class="line"><span class="comment"> 1 2 1</span></span><br><span class="line"><span class="comment"> 1 3 3 1</span></span><br><span class="line"><span class="comment"> 1 4 6 4 1</span></span><br><span class="line"><span class="comment"> 1 5 10 10 5 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f(m<span class="number">-1</span>, n) + f(m<span class="number">-1</span>, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> leval = <span class="number">5</span>;  <span class="comment">// 第5行 0-5共6个元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=leval; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, f(leval, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>整数划分问题</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整数划分问题</span></span><br><span class="line"><span class="comment">// n = 6</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 6</span></span><br><span class="line"><span class="comment"> 5+1</span></span><br><span class="line"><span class="comment"> 4+2,4+1+1</span></span><br><span class="line"><span class="comment"> 3+3,3+2+1,3+1+1+1</span></span><br><span class="line"><span class="comment"> 2+2+2,2+2+1+1,2+1+1+1+1</span></span><br><span class="line"><span class="comment"> 1+1+1+1+1+1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arr-&gt;缓冲，cur-&gt;当前位置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> arr[], <span class="type">int</span> cur)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;cur; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n; i&gt;<span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur&gt;<span class="number">0</span> &amp;&amp; i&gt;arr[cur<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[cur] = i;</span><br><span class="line">        f(n-i, arr, cur+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[MAXSIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    f(<span class="number">6</span>, arr, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><blockquote><p> 参考文章：《数据结构与算法之美》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间复杂度分析</title>
      <link href="/2019/01/03/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
      <url>/2019/01/03/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>此文是学习《数据结构与算法之美》时的笔记。</p><span id="more"></span><h2 id="为什么要分析复杂度"><a href="#为什么要分析复杂度" class="headerlink" title="为什么要分析复杂度"></a>为什么要分析复杂度</h2><p>事后统计法</p><p>将代码跑一遍，通过统计、监控得到执行时间和占用空间，这种方法有很大的局限性。</p><p>1.1 测试结果非常依赖测试环境<br>最近有很多同学问我怎么选一款电脑，我首先会问什么需求(电脑用来干什么?是编程开发、还是后期制作、还是游戏或者是追剧？)。对于后期制作方面，选i7当然比i5好，i7的渲染能力是实测强于i5的。对于游戏，i7和i5性能发挥差不多，所以买i5处理器划算。当然还需要考虑散热以及预算等问题。。等等。对于编程测试环境的硬件不同会对测试结果有很大影响。</p><p>1.2 测试结果受数据规模的影响很大<br>对于同一种排序算法，待排序数据的有序度不一样，排序的执行时间就会有很大的差别。如果测试数据很小，测试结果可能无法真实的反应算法的性能。</p><h2 id="大O复杂度表示法"><a href="#大O复杂度表示法" class="headerlink" title="大O复杂度表示法"></a>大O复杂度表示法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*求1，2，3，……，n的累加和*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = sum + i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设每行代码执行时间一样为unit_time，T(n)为这段代码的执行时间。</p><p><code>T(n) = (2n+2)*unit_time</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(; j&lt;=n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = sum + i*j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码的执行时间为：<code>T(n) = (2n^2 + 2n +3)*unit_time</code></p><p>所有代码的执行时间T(n)与每行代码的执行次数n成正比</p><p>所有就有：<code>T(n) = O(f(n))</code></p><p>大O时间复杂度实际上并不表示具体代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，也称为<strong>渐进时间复杂度</strong>。当n很大时，公式中的低阶、常量、系数并不左右增长趋势，所以可以忽略。</p><p>故，以上两个例子的时间复杂度记为：<code>T(n)=O(n)    T(n) = O(n^2)</code></p><h2 id="时间复杂度分析原则"><a href="#时间复杂度分析原则" class="headerlink" title="时间复杂度分析原则"></a>时间复杂度分析原则</h2><h3 id="只关注循环次数最多的一段代码"><a href="#只关注循环次数最多的一段代码" class="headerlink" title="只关注循环次数最多的一段代码"></a>只关注循环次数最多的一段代码</h3><p>大O只表示一种变化趋势，所以在分析一个算法、一段代码的时候，只关注循环执行次数最多的那一段就可以了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fun1</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>( ; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = sum + i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fun1的总时间复杂度为<code>O(n)</code></p><h3 id="加法原则"><a href="#加法原则" class="headerlink" title="加法原则"></a>加法原则</h3><p>总复杂度等于量级最大的那段代码的时间复杂度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fun2</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sum1 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>( ; p&lt;<span class="number">100</span>; p++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum1 = sum1 + p;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> sum2 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> q = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>( ; q&lt;n; q++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum2 = sum2 + q;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> sum3 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>( ; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>( ; j&lt;=n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum3 = sum3 + i*j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sum1+sum2+sum3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一段执行了100次，和n的规模无关。</p><p>第二段代码时间复杂度为O(n)。</p><p>第三段代码时间复杂度为O(n^2)。</p><p><strong>综合这三段代码的时间复杂度，取最大量级，所以这段代码的时间复杂度为O(n^2)。</strong></p><h3 id="乘法原则"><a href="#乘法原则" class="headerlink" title="乘法原则"></a>乘法原则</h3><p>嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fun1</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>( ; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = ret + fun2(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fun2</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>( ; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = sum + i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的时间复杂度为：<code>O(n^2)</code></p><h2 id="常见的几种时间复杂度"><a href="#常见的几种时间复杂度" class="headerlink" title="常见的几种时间复杂度"></a>常见的几种时间复杂度</h2><p>指数阶：O(2^n) 和 阶乘阶：O(n!)成为非多项式量级。</p><blockquote><p>通常把时间复杂度为非多项式量级的算法问题成为NP问题(Non-Deterministic Polynomial，非确定多项式)。当数据规模n越来越大时，NP问题算法的执行时间会几句增加，非常低效。</p></blockquote><h3 id="O-1"><a href="#O-1" class="headerlink" title="O(1)"></a>O(1)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> sum = i + j;</span><br></pre></td></tr></table></figure><h3 id="O-logn-、O-nlogn"><a href="#O-logn-、O-nlogn" class="headerlink" title="O(logn)、O(nlogn)"></a>O(logn)、O(nlogn)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1 */</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>( i&lt;=n )</span><br><span class="line">&#123;</span><br><span class="line">    i = i*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 2 */</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>( i&lt;=n )</span><br><span class="line">&#123;</span><br><span class="line">    i = i*<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1 代码的复杂度为<code>log2(n)</code></p><p>2 代码的复杂度为<code>log3(n)</code></p><p>对数是可以相互转换的:<code>log3(n) = log3(2) * log2(n)</code>所以:<code>O(log3(n)) = O(C * log2(n))</code>，其中C是一个常量，我们忽略系数C。</p><p>故将对数阶时间复杂度均表示为:<code>log(n)</code></p><p><strong>如果一段代码的时间复杂度为<code>log(n)</code>，执行了n遍，时间复杂度就为<code>nlogn(n)</code>。</strong></p><h3 id="O-m-n-、O-m-n"><a href="#O-m-n-、O-m-n" class="headerlink" title="O(m+n)、O(m*n)"></a>O(m+n)、O(m*n)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fun1</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sum1 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>( ; i&lt;m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum1 = sum1 + i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> sum2 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>( ; j&lt;n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum2 = sum2 + j</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sum1+sum2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的时间复杂度为：<code>O(m+n)</code>。</p><p>针对这种情况，时间复杂度和m、n均有关，加法原则就不正确了，乘法原则依然正确。</p><hr><blockquote><p>参考文章：《数据结构与算法之美》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASM-汇编语言程序设计基础</title>
      <link href="/2018/10/03/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/10/03/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>《微型计算机原理》汇编语言程序设计基础知识总结。</p><span id="more"></span><p><strong>翻译</strong>：源程序 ==&gt; 二进制代码</p><blockquote><p>翻译过程中，伪指令起协助作用，而且当翻译结束时，伪指令消失，只剩下源程序中指令所转换的二进制代码。</p></blockquote><p><strong>伪指令</strong></p><blockquote><p>指导汇编程序将源程序汇编(翻译)成二进制代码，只构成汇编语句语法。</p></blockquote><p><strong>宏指令</strong></p><blockquote><p>简化程序，以一代多。(和C语言宏一样的道理～)<br>宏指令语句和子程序的区别：<br>宏指令语句：速度快、占用空间大。<br>子程序：速度慢(调用时需要保存临时数据，函数地址等)、占用空间小。</p></blockquote><p><strong>汇编程序举例</strong>：将数据段内存单元DATA中的数据12H与立即数16H相加，结果保存在SUM中。完整的源程序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">DESGSEGMENT;定义数据段</span><br><span class="line">DATADB<span class="number">12</span>H</span><br><span class="line">SUMDB<span class="number">0</span></span><br><span class="line">DESGENDS;定义数据段结束</span><br><span class="line"></span><br><span class="line">SSEGSEGMENT STACK;定义堆栈段</span><br><span class="line">DB<span class="number">512</span>DUP(<span class="number">0</span>)</span><br><span class="line">SSEGENDS;定义堆栈段结束</span><br><span class="line"></span><br><span class="line">CSEGSEGMENT;定义代码段开始</span><br><span class="line">ASSUMEDS:DSEG,SS:SSEG,CS:CSEG</span><br><span class="line">START:MOVAX,DSEG</span><br><span class="line">MOV DS,AX</span><br><span class="line">MOV AL,DATA</span><br><span class="line">ADD AL,<span class="number">16</span>H</span><br><span class="line">MOVSUM,AL</span><br><span class="line">MOV AH,<span class="number">4</span>CH</span><br><span class="line">INT <span class="number">21</span>H</span><br><span class="line">CSEGENDS;定义代码段结束</span><br><span class="line">END START;整个汇编程序结束，规定入口地址</span><br></pre></td></tr></table></figure><p>1）汇编语言程序一般由若干段组成，每个段都有一个名字(段名)，以<code>SEGMENT</code>作为段的开始，<code>ENDS</code>作为段的结束。</p><p>汇编语言程序段有4种：代码段、堆栈段、数据段、附加段。<br>其中代码段和堆栈段不可少，数据段和附加段根据需要设置。</p><p>2）汇编语言一行不能超过128个字符，但一条语句允许有后续行，最后均已回车结束。整个程序必须以<code>END</code>作为结束，它通知汇编程序停止汇编。<code>END</code>后的<code>START</code>表示该程序执行时的起始地址。</p><p>3）每一条汇编语句最多由4个字段组成，按照语法规则写在一个语句的4个区域内。各区域之间用空格或TAB隔开。</p><p>汇编语句的4个字段：名字或标号、操作码(指令助记符)或伪操作指令、操作数(操作数或地址)、注释。</p><h2 id="1-数据项"><a href="#1-数据项" class="headerlink" title="1. 数据项"></a>1. 数据项</h2><h3 id="1-1-常量"><a href="#1-1-常量" class="headerlink" title="1.1 常量"></a>1.1 常量</h3><p>数字</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0100B</span> 二进制</span><br><span class="line"><span class="number">75</span>Q八进制</span><br><span class="line"><span class="number">295</span>D十进制(D可省略)</span><br><span class="line"><span class="number">3</span>AFH十六进制</span><br></pre></td></tr></table></figure><p>所有的数必须以0~9输值开头，例如：<code>FA3BH</code>需写成<code>0FA3BH</code></p><p>字符、字符串<br><code>&#39;a&#39;    &#39;Hello&#39;</code>。</p><p>用标识符表示常量<br>嘿嘿，类似于C语言中<code>#define PI 3.14</code>。<br>在汇编中：<code>AL EQU 0FA3BH</code>，这个<code>EQU</code>是关键字，这样定义后<code>AL</code>就代表这个数。</p><h3 id="1-2-变量"><a href="#1-2-变量" class="headerlink" title="1.2 变量"></a>1.2 变量</h3><p>变量名：一个存储单元的地址</p><p>变量属性<br>段属性：变量所在段的段地址，用<code>SEG  变量名</code>得到变量的段地址。</p><p>偏移属性：变量与起始位置之间相距的字节数，<code>OFFSET  变量名</code>得到变量的偏移地址。</p><p>类型：存取长度单位，<code>TYPE  变量名</code>得到变量的类型。</p><ul><li><p>变量定义</p><p><strong>变量  类型  表达式</strong></p></li><li><p>变量类型</p><p>DB：1个字节</p><p>DW：2个字节</p><p>DD：4个字节</p><p>DQ：8个字节</p><p>DT：10个字节</p></li><li><p>变量定义中的表达式</p><p>常量1,常量2,…</p><p>‘一串字符’</p><p>重复因子DUP( )</p></li></ul><p>变量定义举例：</p><p><img src="https://wx2.sinaimg.cn/mw690/006wR0dcly1fx5b2h8043j30lr0f0n2v.jpg" alt="变量定义举例1"></p><p><img src="https://wx3.sinaimg.cn/mw690/006wR0dcly1fx5b2h6inwj30es0km7ag.jpg" alt="变量定义举例2"></p><p><img src="https://wx3.sinaimg.cn/mw690/006wR0dcly1fx5b8gga6bj30pk0eyn52.jpg" alt="变量定义3"></p><h3 id="1-3-标号"><a href="#1-3-标号" class="headerlink" title="1.3 标号"></a>1.3 标号</h3><ul><li><p>标号名：不能以0开头(常量是必须以0开头)，标号名代表标号那行指令所在内存单元的地址。</p></li><li><p>标号属性</p><p>段属性：<code>SEG  标号</code>取段地址。</p><p>偏移属性：<code>OFFSET  标号</code>取偏移地址。</p><p>类型属性：<code>TYPE  标号</code>取类型。</p></li><li><p>标号类型</p><p>near(近类型)：段内</p><p>far(远类型)：段间</p></li></ul><h2 id="2-运算符和表达式"><a href="#2-运算符和表达式" class="headerlink" title="2. 运算符和表达式"></a>2. 运算符和表达式</h2><blockquote><p>表达式并不是指令，所以它本身并不能执行，只能在汇编时由汇编程序预先对其进行运算，然后再将所得的值作为操作数参加指令规定的操作。</p><p>即：<strong>表达式求值是由汇编程序来完成的</strong>。</p></blockquote><ul><li><p>算数运算符(7种)</p><p>加(+)、减(-)、乘(*)、除(/)、模除(MOD)、算数左移(SHL)、算数右移(SHR)。</p><p>注意：除了加、减运算符可以使用变量和标号外，其他算数运算符只适用于常量的数值运算。</p><p>例如：设<code>NUMB=01010101B</code> ，则<code> NUMB SHL 1 = 10101010B</code>。</p></li><li><p>逻辑运算符(4种)</p><p>与(AND)、或(OR)、非(NOT)、异或(XOR)。</p><p>注意：逻辑运算符只能用于表达式求值，用来对数值进行按位逻辑运算，并得到一个数值。对地址进行逻辑运算则无意义。</p><p>例如：<code>MOV AL,0ADH AND 0EAH</code>&lt;=&gt;<code>MOV AL,0A8H</code>。</p></li><li><p>关系运算符(6个)</p><p>=(EQ)、$\ne$(NE)、$\lt$(LT)、$\gt$(GT)、$\le$(LE)、$\ge$(GE)。</p><p>注意：在数值表达式中参与关系运算的必须是两个数值或同一段中的两个存储单元的地址。关系运算符的结果是一个逻辑值(常数)，其值在汇编(翻译)时获得。当关系成立(TRUE)时，结果为$0FFFFH$，当关系不成立(FALSE)时，结果为$0$。</p></li><li><p>数值返回操作符</p><p>数值返回操作符用来分析一个存储器操作数(即变量或标号)的属性，即将它分解为其组成部分(段地址、偏移值、类型、数据字节数、数据项总数等)，并在汇编时以数值形式返回给存储器操作数。运算符总是加在运算对象之前，返回的结果是一个数值。</p><p><strong>SEG</strong>：返回其后变量或标号的段地址，例：<code>MOV AX,SEG DATA1 </code>将变量DATA1的段地址送到AX中。</p><p><strong>OFFSET</strong>：返回其后变量或标号的偏移值，例：<code>MOV SI,OFFSET DATA2</code>。</p><p><strong>TYPE</strong>：返回的数值是反应该变量或标号类型的一个数值。</p><p>如果是变量，则返回数值为字节数：DB为1，DW为2，DD为4，DQ为8，DT为10。</p><p>如果是标号，返回数值为该标号的类型值：NEAR为-1(FFH)，FAR为-2(FEH)。</p><p><strong>SIZE</strong>：返回变量所占数据区的字节总数。</p><p><strong>LENGTH</strong>：返回数据单元个数。</p><p>如果变量是DUP说明的，返回外层DUP前面的数值。</p><p>其他，返回的总是1。</p></li><li><p>属性运算符(4个)</p><p><strong>PTR</strong>：用来说明或修改位于其后的存储器操作数的类型。</p><p>如果一个变量已经定义为字变量，利用PTR运算符可以修改它的属性。例如：变量VAR已经定义为字类型，若要将VAR当作字节操作数写成<code>MOV AL,VAR</code>则会出错，因为两个操作数的字长类型不同；如果将指令写成<code>MOV AL,BYTE PTR VAR</code>是合法的。</p><p>注意！PTR运算符只对当前指令有效。</p><p><strong>THIS</strong>：(类似于C语言中的union？)，THIS用来把它后面指定的类型和距离属性赋给当前变量、标号或地址表达式，但不分配新的存储单元。</p><p>例如：<code>DATAB EQU THIS BYTE</code>  <code>DATAW DW ?</code></p><p>这里的DATAB与DATAW的段地址和偏移量相同(公用一块空间)，但变量DATAB的类型是字节，而变量DATAW的类型是字。</p><blockquote><p>注意！运算符THIS和PTR有类似的功能，但具体用法有所不同。</p><p>其中，THIS是为当前存储单元定义一个指定类型的变量或标号，也就是说为下一个能分配存储单元的变量或标号定义新的类型，因此它必须放在被修改的变量之前。例如上个栗子中的THIS就是放在DATAW之前，以便将DATAW定义为字节类型变量DATAB。而运算符PTR则是对已经定义的变量或标号修改其属性，它可以放在被修改的变量之前，也可以放在后面。</p></blockquote><p><strong>HIGH</strong>：取高8位</p><p><strong>LOW</strong>：取低8位</p><p><strong>：段超越</strong>：eg：<code>MOV AX,ES:[BS]</code></p></li></ul><h2 id="3-伪指令"><a href="#3-伪指令" class="headerlink" title="3. 伪指令"></a>3. 伪指令</h2><h3 id="3-1-数据定义伪指令"><a href="#3-1-数据定义伪指令" class="headerlink" title="3.1 数据定义伪指令"></a>3.1 数据定义伪指令</h3><p><strong>DB</strong>：1个字节，BYTE，也常常用来定义字符串。</p><p><strong>DW</strong>：2个字节，WORD。</p><p><strong>DD</strong>：4个字节，DWORD。</p><p><strong>DQ</strong>：8个字节，QBYTE。</p><p><strong>DT</strong>：10个字节，TBYTE，DT后面的每个操作数都为10个字节的压缩BCD数。</p><h3 id="3-2-符号定义伪指令"><a href="#3-2-符号定义伪指令" class="headerlink" title="3.2 符号定义伪指令"></a>3.2 符号定义伪指令</h3><ul><li><p>EQU(赋值伪指令)</p><p>格式：名字 EQU 表达式</p><p>EQU不能重复定义已使用过的符号名。</p><p><code>CONST EQU 256</code></p><p><code>N_CONST EQU 256+10</code></p><p><code>ADDR EQU [BP+8]</code></p><p><code>CB EQU DAA</code></p></li><li><p>LABEL(数据定义伪指令)</p><p>格式：名字 类型 表达式</p></li></ul><h3 id="3-3-段定义伪指令"><a href="#3-3-段定义伪指令" class="headerlink" title="3.3 段定义伪指令"></a>3.3 段定义伪指令</h3><p>格式：段名 SEGMENT [定位][组合][类别名]     // []中的一般不写</p><p>SEGMENT和ENDS伪指令：</p><p>SEGMENT和ENDS必须成对出现，他们之间为段体，给其赋予一个名字(不可省略)。</p><ul><li><p>定位类型(4种)</p><p>BYTE，字节型</p><p>WORD，字型</p><p>PARA，节型，默认为这个。</p><p>PAGE，页型</p></li><li><p>组合类型(连接类型)</p><p>即多个模块的程序中，指示连接程序如何将某个逻辑段在装入内存时与其他段进行组合。</p><p>NONE，默认不组合</p><p>PUBLIC，同类型之和、一个整的内存段</p><p>STACK</p><p>COMMON，重叠，值分配最大的那个段的存储长度</p><p>MEMORY</p><p>AT表达式</p></li><li><p>类别名(在组合中使用)</p><p>用来说明程序在运行期间CS、DS、SS、ES所放的段基址。</p></li></ul><p>ASSUME伪指令：</p><p>一般出现在代码段，且放在代码段首句。</p><p>格式：段寄存器:段名</p><p>例如笔记最开始的代码：<code>ASSUME    DS:DSEG,SS:SSEG,CS:CSEG</code></p><h3 id="3-4-过程定义伪指令"><a href="#3-4-过程定义伪指令" class="headerlink" title="3.4 过程定义伪指令"></a>3.4 过程定义伪指令</h3><p>“过程”也称为“子程序”，在主程序中任何需要的地方都可以调用。</p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">名字 PROC FAR/NEAR</span><br><span class="line">...</span><br><span class="line">ret</span><br><span class="line">名字 ENDP</span><br></pre></td></tr></table></figure><h3 id="3-5-程序结束伪指令"><a href="#3-5-程序结束伪指令" class="headerlink" title="3.5 程序结束伪指令"></a>3.5 程序结束伪指令</h3><p>格式：END 标号</p><p>告诉汇编程序到这里就结束咯。</p><p>例如笔记最开始时的那段代码：</p><p><code>END START</code></p><hr>]]></content>
      
      
      <categories>
          
          <category> ASM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ASM </tag>
            
            <tag> 微机原理 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
